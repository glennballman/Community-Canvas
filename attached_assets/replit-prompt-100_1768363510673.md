# PROMPT 24 - BUNDLE 100: Actor Types, Roles, Plans & Subscriptions

## Context
- Previous migration: 099_messages_rls_and_participants.sql
- This is migration 100
- Part of Prompt 24A - Core pricing infrastructure

## Objective
Create the multi-role tenant system with subscription plans. A single tenant can hold multiple economic roles (Contractor + Inventory + PIC simultaneously).

## CRITICAL RULES
- Do NOT add actor_type_id to cc_tenants
- Keep legacy subscription_tier column but do not use it for gating
- Subscriptions are PSP-agnostic (no Stripe dependency)

---

## Migration: server/migrations/100_actor_types_roles_plans_subscriptions.sql

```sql
-- ============================================================
-- MIGRATION 100: ACTOR TYPES, ROLES, PLANS & SUBSCRIPTIONS
-- Part of Prompt 24A - Core Pricing Infrastructure
-- ============================================================

BEGIN;

-- ============================================================
-- 1) ACTOR TYPES (Economic Roles)
-- These are the 5 buyer types in the platform
-- ============================================================

CREATE TABLE IF NOT EXISTS cc_actor_types (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  code text UNIQUE NOT NULL,
  name text NOT NULL,
  description text,
  sort_order integer NOT NULL DEFAULT 0,
  is_active boolean NOT NULL DEFAULT true,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX idx_cc_actor_types_code ON cc_actor_types(code);
CREATE INDEX idx_cc_actor_types_active ON cc_actor_types(is_active);

-- ============================================================
-- 2) TENANT ACTOR ROLES (Join Table)
-- A tenant can have MULTIPLE roles simultaneously
-- This replaces the bad idea of actor_type_id on cc_tenants
-- ============================================================

CREATE TABLE IF NOT EXISTS cc_tenant_actor_roles (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL REFERENCES cc_tenants(id) ON DELETE CASCADE,
  actor_type_id uuid NOT NULL REFERENCES cc_actor_types(id) ON DELETE CASCADE,
  
  -- Which role is primary for UI defaults
  is_primary boolean NOT NULL DEFAULT false,
  
  -- Lifecycle
  activated_at timestamptz NOT NULL DEFAULT now(),
  deactivated_at timestamptz,
  
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  
  -- One role per actor type per tenant
  UNIQUE (tenant_id, actor_type_id)
);

CREATE INDEX idx_cc_tenant_actor_roles_tenant ON cc_tenant_actor_roles(tenant_id);
CREATE INDEX idx_cc_tenant_actor_roles_actor ON cc_tenant_actor_roles(actor_type_id);
CREATE INDEX idx_cc_tenant_actor_roles_primary ON cc_tenant_actor_roles(tenant_id, is_primary) WHERE is_primary = true;

-- Enable RLS
ALTER TABLE cc_tenant_actor_roles ENABLE ROW LEVEL SECURITY;

CREATE POLICY cc_tenant_actor_roles_service_bypass ON cc_tenant_actor_roles
  FOR ALL
  USING (current_setting('app.tenant_id', true) = '__SERVICE__')
  WITH CHECK (current_setting('app.tenant_id', true) = '__SERVICE__');

CREATE POLICY cc_tenant_actor_roles_tenant_read ON cc_tenant_actor_roles
  FOR SELECT
  USING (tenant_id::text = current_setting('app.tenant_id', true));

CREATE POLICY cc_tenant_actor_roles_tenant_write ON cc_tenant_actor_roles
  FOR ALL
  USING (tenant_id::text = current_setting('app.tenant_id', true))
  WITH CHECK (tenant_id::text = current_setting('app.tenant_id', true));

-- ============================================================
-- 3) PLANS (Subscription Plans per Actor Type)
-- 15 plans total: 3 tiers × 5 actor types
-- ============================================================

CREATE TABLE IF NOT EXISTS cc_plans (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  actor_type_id uuid NOT NULL REFERENCES cc_actor_types(id) ON DELETE CASCADE,
  
  -- Identity
  code text NOT NULL,
  name text NOT NULL,
  description text,
  
  -- Pricing (PSP-agnostic)
  monthly_price numeric NOT NULL DEFAULT 0,
  annual_price numeric,
  seasonal_price numeric,
  billing_interval text NOT NULL DEFAULT 'monthly',
  currency text NOT NULL DEFAULT 'CAD',
  
  -- Tier (1=starter/free, 2=pro, 3=enterprise)
  tier_level integer NOT NULL DEFAULT 1,
  
  -- Status
  is_active boolean NOT NULL DEFAULT true,
  is_public boolean NOT NULL DEFAULT true,
  sort_order integer NOT NULL DEFAULT 0,
  
  -- Timestamps
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  
  -- Unique code per actor type
  UNIQUE (actor_type_id, code)
);

CREATE INDEX idx_cc_plans_actor ON cc_plans(actor_type_id);
CREATE INDEX idx_cc_plans_code ON cc_plans(code);
CREATE INDEX idx_cc_plans_active ON cc_plans(is_active, is_public);
CREATE INDEX idx_cc_plans_tier ON cc_plans(actor_type_id, tier_level);

-- ============================================================
-- 4) PLAN ENTITLEMENTS (Feature Flags per Plan)
-- What features/limits each plan grants
-- ============================================================

CREATE TABLE IF NOT EXISTS cc_plan_entitlements (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  plan_id uuid NOT NULL REFERENCES cc_plans(id) ON DELETE CASCADE,
  
  -- Entitlement key
  entitlement_key text NOT NULL,
  
  -- Value type and value
  value_type text NOT NULL DEFAULT 'boolean',
  boolean_value boolean,
  numeric_value integer,
  text_value text,
  
  -- Description for UI
  display_name text,
  description text,
  
  created_at timestamptz NOT NULL DEFAULT now(),
  
  -- One entitlement per key per plan
  UNIQUE (plan_id, entitlement_key)
);

CREATE INDEX idx_cc_plan_entitlements_plan ON cc_plan_entitlements(plan_id);
CREATE INDEX idx_cc_plan_entitlements_key ON cc_plan_entitlements(entitlement_key);

-- ============================================================
-- 5) SUBSCRIPTIONS (Tenant → Plan)
-- PSP-agnostic: works without Stripe
-- V3+: Tenant-owned only (party/individual subscriptions can be added later)
-- ============================================================

CREATE TABLE IF NOT EXISTS cc_subscriptions (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Owner (tenant-owned only for V3+)
  tenant_id uuid NOT NULL REFERENCES cc_tenants(id) ON DELETE CASCADE,
  
  -- What they're subscribed to
  plan_id uuid NOT NULL REFERENCES cc_plans(id),
  actor_type_id uuid NOT NULL REFERENCES cc_actor_types(id),
  
  -- Status
  status text NOT NULL DEFAULT 'active',
  
  -- Trial
  trial_ends_at timestamptz,
  
  -- Billing period
  current_period_start timestamptz NOT NULL DEFAULT now(),
  current_period_end timestamptz,
  
  -- PSP-agnostic billing
  billing_method text NOT NULL DEFAULT 'invoice',
  billing_email text,
  external_customer_id text,
  external_subscription_id text,
  
  -- Timestamps
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  cancelled_at timestamptz,
  
  -- One subscription per actor type per tenant
  UNIQUE (tenant_id, actor_type_id)
);

CREATE INDEX idx_cc_subscriptions_tenant ON cc_subscriptions(tenant_id);
CREATE INDEX idx_cc_subscriptions_plan ON cc_subscriptions(plan_id);
CREATE INDEX idx_cc_subscriptions_status ON cc_subscriptions(status);

-- Enable RLS
ALTER TABLE cc_subscriptions ENABLE ROW LEVEL SECURITY;

CREATE POLICY cc_subscriptions_service_bypass ON cc_subscriptions
  FOR ALL
  USING (current_setting('app.tenant_id', true) = '__SERVICE__')
  WITH CHECK (current_setting('app.tenant_id', true) = '__SERVICE__');

-- Tenant can read their own subscriptions
CREATE POLICY cc_subscriptions_tenant_read ON cc_subscriptions
  FOR SELECT
  USING (tenant_id::text = current_setting('app.tenant_id', true));

-- Tenant can manage their own subscriptions
CREATE POLICY cc_subscriptions_tenant_write ON cc_subscriptions
  FOR ALL
  USING (tenant_id::text = current_setting('app.tenant_id', true))
  WITH CHECK (tenant_id::text = current_setting('app.tenant_id', true));

-- ============================================================
-- 6) SUBSCRIPTION STATUS ENUM VALUES
-- For reference in application code
-- ============================================================

COMMENT ON COLUMN cc_subscriptions.status IS 'active, trialing, past_due, cancelled, paused, expired';
COMMENT ON COLUMN cc_subscriptions.billing_method IS 'invoice, eft, credit_card, stripe, external, manual';

COMMIT;
```

---

## Drizzle Schema: Add to shared/schema.ts

```typescript
// ============================================================
// ACTOR TYPES (Bundle 100)
// ============================================================

export const ccActorTypes = pgTable("cc_actor_types", {
  id: uuid("id").primaryKey().defaultRandom(),
  code: text("code").notNull().unique(),
  name: text("name").notNull(),
  description: text("description"),
  sortOrder: integer("sort_order").notNull().default(0),
  isActive: boolean("is_active").notNull().default(true),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
}, (table) => ({
  codeIdx: index("idx_cc_actor_types_code").on(table.code),
  activeIdx: index("idx_cc_actor_types_active").on(table.isActive),
}));

export const insertActorTypeSchema = createInsertSchema(ccActorTypes).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export type ActorType = typeof ccActorTypes.$inferSelect;

// ============================================================
// TENANT ACTOR ROLES (Bundle 100)
// ============================================================

export const ccTenantActorRoles = pgTable("cc_tenant_actor_roles", {
  id: uuid("id").primaryKey().defaultRandom(),
  tenantId: uuid("tenant_id").notNull().references(() => ccTenants.id, { onDelete: "cascade" }),
  actorTypeId: uuid("actor_type_id").notNull().references(() => ccActorTypes.id, { onDelete: "cascade" }),
  isPrimary: boolean("is_primary").notNull().default(false),
  activatedAt: timestamp("activated_at", { withTimezone: true }).notNull().defaultNow(),
  deactivatedAt: timestamp("deactivated_at", { withTimezone: true }),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
}, (table) => ({
  tenantIdx: index("idx_cc_tenant_actor_roles_tenant").on(table.tenantId),
  actorIdx: index("idx_cc_tenant_actor_roles_actor").on(table.actorTypeId),
  uniqueTenantActor: uniqueIndex("cc_tenant_actor_roles_tenant_actor_unique").on(table.tenantId, table.actorTypeId),
}));

export const insertTenantActorRoleSchema = createInsertSchema(ccTenantActorRoles).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export type TenantActorRole = typeof ccTenantActorRoles.$inferSelect;

// ============================================================
// PLANS (Bundle 100)
// ============================================================

export const ccPlans = pgTable("cc_plans", {
  id: uuid("id").primaryKey().defaultRandom(),
  actorTypeId: uuid("actor_type_id").notNull().references(() => ccActorTypes.id, { onDelete: "cascade" }),
  code: text("code").notNull(),
  name: text("name").notNull(),
  description: text("description"),
  monthlyPrice: numeric("monthly_price").notNull().default("0"),
  annualPrice: numeric("annual_price"),
  seasonalPrice: numeric("seasonal_price"),
  billingInterval: text("billing_interval").notNull().default("monthly"),
  currency: text("currency").notNull().default("CAD"),
  tierLevel: integer("tier_level").notNull().default(1),
  isActive: boolean("is_active").notNull().default(true),
  isPublic: boolean("is_public").notNull().default(true),
  sortOrder: integer("sort_order").notNull().default(0),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
}, (table) => ({
  actorIdx: index("idx_cc_plans_actor").on(table.actorTypeId),
  codeIdx: index("idx_cc_plans_code").on(table.code),
  tierIdx: index("idx_cc_plans_tier").on(table.actorTypeId, table.tierLevel),
}));

export const insertPlanSchema = createInsertSchema(ccPlans).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export type Plan = typeof ccPlans.$inferSelect;

// ============================================================
// PLAN ENTITLEMENTS (Bundle 100)
// ============================================================

export const ccPlanEntitlements = pgTable("cc_plan_entitlements", {
  id: uuid("id").primaryKey().defaultRandom(),
  planId: uuid("plan_id").notNull().references(() => ccPlans.id, { onDelete: "cascade" }),
  entitlementKey: text("entitlement_key").notNull(),
  valueType: text("value_type").notNull().default("boolean"),
  booleanValue: boolean("boolean_value"),
  numericValue: integer("numeric_value"),
  textValue: text("text_value"),
  displayName: text("display_name"),
  description: text("description"),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
}, (table) => ({
  planIdx: index("idx_cc_plan_entitlements_plan").on(table.planId),
  keyIdx: index("idx_cc_plan_entitlements_key").on(table.entitlementKey),
  uniquePlanKey: uniqueIndex("cc_plan_entitlements_plan_key_unique").on(table.planId, table.entitlementKey),
}));

export const insertPlanEntitlementSchema = createInsertSchema(ccPlanEntitlements).omit({
  id: true,
  createdAt: true,
});

export type PlanEntitlement = typeof ccPlanEntitlements.$inferSelect;

// ============================================================
// SUBSCRIPTIONS (Bundle 100)
// V3+: Tenant-owned only (party/individual can be added later)
// ============================================================

export const subscriptionStatusEnum = pgEnum("subscription_status", [
  "active",
  "trialing",
  "past_due",
  "cancelled",
  "paused",
  "expired"
]);

export const billingMethodEnum = pgEnum("billing_method", [
  "invoice",
  "eft",
  "credit_card",
  "stripe",
  "external",
  "manual"
]);

export const ccSubscriptions = pgTable("cc_subscriptions", {
  id: uuid("id").primaryKey().defaultRandom(),
  tenantId: uuid("tenant_id").notNull().references(() => ccTenants.id, { onDelete: "cascade" }),
  planId: uuid("plan_id").notNull().references(() => ccPlans.id),
  actorTypeId: uuid("actor_type_id").notNull().references(() => ccActorTypes.id),
  status: text("status").notNull().default("active"),
  trialEndsAt: timestamp("trial_ends_at", { withTimezone: true }),
  currentPeriodStart: timestamp("current_period_start", { withTimezone: true }).notNull().defaultNow(),
  currentPeriodEnd: timestamp("current_period_end", { withTimezone: true }),
  billingMethod: text("billing_method").notNull().default("invoice"),
  billingEmail: text("billing_email"),
  externalCustomerId: text("external_customer_id"),
  externalSubscriptionId: text("external_subscription_id"),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
  cancelledAt: timestamp("cancelled_at", { withTimezone: true }),
}, (table) => ({
  tenantIdx: index("idx_cc_subscriptions_tenant").on(table.tenantId),
  planIdx: index("idx_cc_subscriptions_plan").on(table.planId),
  statusIdx: index("idx_cc_subscriptions_status").on(table.status),
  uniqueTenantActor: uniqueIndex("cc_subscriptions_tenant_actor_unique").on(table.tenantId, table.actorTypeId),
}));

export const insertSubscriptionSchema = createInsertSchema(ccSubscriptions).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export type Subscription = typeof ccSubscriptions.$inferSelect;
export type InsertSubscription = z.infer<typeof insertSubscriptionSchema>;
```

---

## Acceptance Criteria

1. [ ] Migration 100 runs without errors
2. [ ] cc_actor_types table created
3. [ ] cc_tenant_actor_roles table created with unique constraint on (tenant_id, actor_type_id)
4. [ ] cc_plans table created
5. [ ] cc_plan_entitlements table created
6. [ ] cc_subscriptions table created with tenant_id NOT NULL (tenant-owned only)
7. [ ] RLS enabled on cc_tenant_actor_roles and cc_subscriptions
8. [ ] Tenant can read/write their own subscriptions (not service-only)
9. [ ] Drizzle schema updated and synced
10. [ ] NO changes made to cc_tenants table
11. [ ] NO party_id or individual_id columns on cc_subscriptions

---

## Test Queries

```sql
-- Verify tables exist
SELECT table_name 
FROM information_schema.tables 
WHERE table_schema = 'public' 
  AND table_name IN ('cc_actor_types', 'cc_tenant_actor_roles', 'cc_plans', 'cc_plan_entitlements', 'cc_subscriptions');

-- Verify cc_tenants was NOT modified
SELECT column_name 
FROM information_schema.columns 
WHERE table_name = 'cc_tenants' 
  AND column_name = 'actor_type_id';
-- Should return 0 rows

-- Verify cc_subscriptions has NO party_id or individual_id
SELECT column_name 
FROM information_schema.columns 
WHERE table_name = 'cc_subscriptions' 
  AND column_name IN ('party_id', 'individual_id');
-- Should return 0 rows

-- Verify tenant_id is NOT NULL on subscriptions
SELECT is_nullable 
FROM information_schema.columns 
WHERE table_name = 'cc_subscriptions' 
  AND column_name = 'tenant_id';
-- Should return 'NO'

-- Verify RLS is enabled
SELECT tablename, rowsecurity 
FROM pg_tables 
WHERE schemaname = 'public' 
  AND tablename IN ('cc_tenant_actor_roles', 'cc_subscriptions');

-- Verify tenant RLS policies exist (not just service bypass)
SELECT policyname 
FROM pg_policies 
WHERE tablename = 'cc_subscriptions';
-- Should include: cc_subscriptions_tenant_read, cc_subscriptions_tenant_write
```
