Good — A1 is the right shape. Before we move on, here’s the verification checklist (what I’m validating from your summary) plus the exact next prompt (A2) in Replit-ready form so we keep momentum.

A1 Verification Checklist (what must be true)

Routing & semantics

Route is /app/contractor/onboard (not /contractor/onboard) — that’s fine if consistent with your app shell.

No banned terms (“booking”) anywhere in UI copy.

Security

/api/contractor/profile/* routes are behind requireAuth + requireTenant.

Contractor can only touch their own cc_contractor_profiles row (no cross-person access).

Auto-provision logic cannot be abused to create profiles for other people.

UX

Three cards are equal weight; sticky note gets emphasis.

Camera → fallback works; no form fields required.

If any one of the security items above isn’t true, we patch immediately in A1-PATCH before A2. Otherwise: proceed.

✅ PROMPT A2 — Media Capture & AI Ingestion Pipeline (Unified)
PURPOSE

Implement the shared ingestion pipeline that powers all three contractor WOW flows:

Vehicle + trailer photo → AI proposal

Tool photo(s) → AI proposal

Sticky note photo → AI proposal

Hard invariant: AI output is proposal only until human confirms. No silent commits.

SCOPE
Frontend

Create a shared capture flow used by:

Vehicle capture page

Tool capture page

Sticky note capture page

Backend

Create ingestion records, store media, return AI proposal placeholder.

AI behavior

In this prompt:

Do NOT build real recognition yet.

Do:

Create the pipeline

Create the proposal payload shape

Return stub proposal responses with confidence + extracted fields placeholders

Ensure everything is auditable and replayable

Recognition starts in A3/B2/C1.

DATA MODEL

Create table: cc_ai_ingestions

Columns

id uuid pk default random

tenant_id uuid not null

contractor_profile_id uuid not null (FK to cc_contractor_profiles.id)

source_type text not null
Allowed: vehicle_photo | tool_photo | sticky_note

status text not null default 'proposed'
Allowed: proposed | confirmed | discarded | error

media jsonb not null default '[]'
Array items: { url, mime, bytes, width?, height?, captured_at }

ai_proposed_payload jsonb not null default '{}'

human_confirmed_payload jsonb

confidence_score numeric (0–100)

error_message text

created_at timestamptz not null default now()

updated_at timestamptz not null default now()

Indexes

(tenant_id, contractor_profile_id, created_at desc)

(tenant_id, source_type, created_at desc)

Partial index where status = 'proposed'

BACKEND ROUTES (ALL REQUIRE AUTH + TENANT)

Under /api/contractor/ingestions

1) POST /api/contractor/ingestions

Creates an ingestion record + stores uploaded media.

Input

multipart/form-data

fields:

source_type

files: media[]

Behavior

Validate source_type

Validate file types (images only for now)

Upload files using your existing media storage pattern

Insert ingestion row with media array

Create stub ai_proposed_payload based on source_type:

vehicle: { vehicle: {...}, trailer: {...} }

tools: { detected_items: [...] }

sticky_note: { text: '', possible_customer: {...}, possible_service_run: {...} }

Set confidence_score to a placeholder (e.g., 50)

Return { ok: true, ingestion }

2) GET /api/contractor/ingestions/:id

Returns ingestion record scoped to tenant + contractor_profile_id

3) POST /api/contractor/ingestions/:id/discard

Sets status = discarded (audit log)

4) POST /api/contractor/ingestions/:id/confirm

Stores human_confirmed_payload, sets status = confirmed
(Actual downstream creation of assets/runs occurs in A4/B3/C3.)

Input

JSON: { human_confirmed_payload }

Important

Confirmation is allowed even if AI payload is empty.

This ensures contractor can proceed even if AI fails.

AUDIT LOGGING (REQUIRED)

Use consistent prefix:

[CONTRACTOR AUDIT] ingestion_created

[CONTRACTOR AUDIT] ingestion_discarded

[CONTRACTOR AUDIT] ingestion_confirmed

Include:

tenant_id

contractor_profile_id

ingestion_id

source_type

actor_id

occurred_at

FRONTEND PAGES

Create three pages that all use the same shared component:

Shared component

ContractorIngestionCapture.tsx

Props: { sourceType, title, helperText, onCreatedNavigateTo }

Supports:

camera capture

file picker fallback

multi-image selection for tools

Calls POST ingestion endpoint

Shows upload progress

On success navigates to:

/app/contractor/onboard/ingestions/:id

Review page

/app/contractor/onboard/ingestions/:id

Displays:

media thumbnails

proposal payload JSON viewer (for now)

confidence score badge

Buttons:

“Confirm” (proceeds, stores human_confirmed_payload = ai_proposed_payload by default)

“Edit” (opens minimal editor stub — real editor comes in A4/B3/C4)

“Discard”

SECURITY INVARIANTS

Contractor can only access their own ingestions.

No ingestion can be created without an existing contractor profile (auto-provision ok).

Never expose ingestions to residents/visitors.

No cross-tenant access.

ACCEPTANCE CRITERIA

Contractor can:

Capture photo(s)

Create ingestion

View ingestion review page

Confirm or discard

Confirm writes record, but does not create:

assets

service runs

customers

Works on mobile and desktop

All endpoints require session auth + tenant context