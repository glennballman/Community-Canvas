**BAMFIELD OPS - PROMPT 01: Canonical Locations**

Create the location registry for all Bamfield docks, marinas, and stops with authority rules.

## Migration 078_locations.sql
```sql
BEGIN;

-- ============ LOCATIONS ============
-- Canonical registry of docks, marinas, trailheads, and stops

CREATE TABLE IF NOT EXISTS cc_locations (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid REFERENCES cc_tenants(id) ON DELETE SET NULL,
  portal_id uuid REFERENCES cc_portals(id) ON DELETE SET NULL,
  
  -- Identity
  name text NOT NULL,
  code varchar(20), -- Short code for displays (e.g., 'WGD', 'EGD')
  
  location_type text NOT NULL CHECK (location_type IN (
    'dock', 'marina', 'trailhead', 'restaurant', 'lodging', 
    'yard', 'warehouse', 'campsite', 'ferry_terminal', 'seaplane_base', 'other'
  )),
  
  -- Geography
  lat numeric(9,6),
  lon numeric(9,6),
  region varchar DEFAULT 'Barkley Sound',
  timezone varchar DEFAULT 'America/Vancouver',
  
  -- Address (optional for remote locations)
  address_line1 text,
  address_city text,
  address_province varchar DEFAULT 'BC',
  address_postal_code varchar,
  
  -- Authority & eligibility
  authority_type varchar CHECK (authority_type IN (
    'harbour_authority', 'parks_canada', 'first_nation', 
    'municipal', 'provincial', 'private', 'federal'
  )),
  authority_name text,
  authority_rules jsonb NOT NULL DEFAULT '{}'::jsonb,
  -- {permit_required: true, permit_type: 'backcountry', 
  --  restricted_hours: {start: '22:00', end: '06:00'},
  --  max_vessel_length_ft: 60}
  
  -- Capabilities (what can happen here)
  stop_capabilities jsonb NOT NULL DEFAULT '{
    "passenger_embark": true,
    "passenger_disembark": true,
    "freight_load": false,
    "freight_unload": false,
    "kayak_landing": false,
    "overnight_moorage": false,
    "fuel_available": false,
    "power_available": false,
    "water_available": false,
    "boat_launch": false
  }'::jsonb,
  
  -- Contact
  contact_name text,
  contact_phone text,
  contact_email text,
  
  -- Operational
  operating_hours_json jsonb DEFAULT '{}'::jsonb,
  -- {default: {open: '06:00', close: '22:00'}, 
  --  seasonal: [{months: [11,12,1,2], open: '08:00', close: '18:00'}]}
  
  -- Connections
  connected_locations uuid[], -- Nearby walkable/drivable locations
  travel_time_minutes_json jsonb DEFAULT '{}'::jsonb,
  -- {by_water: {to_location_id: 15}, by_road: {to_location_id: 5}}
  
  -- CivOS integration
  civos_location_id uuid,
  
  -- Media
  image_url text,
  
  -- Status
  status varchar DEFAULT 'active' CHECK (status IN ('active', 'seasonal', 'closed', 'maintenance')),
  notes text,
  
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  
  UNIQUE(portal_id, code)
);

CREATE INDEX idx_locations_type ON cc_locations(location_type, status);
CREATE INDEX idx_locations_portal ON cc_locations(portal_id) WHERE portal_id IS NOT NULL;
CREATE INDEX idx_locations_authority ON cc_locations(authority_type) WHERE authority_type IS NOT NULL;
CREATE INDEX idx_locations_geo ON cc_locations(lat, lon) WHERE lat IS NOT NULL;

ALTER TABLE cc_locations ENABLE ROW LEVEL SECURITY;

-- ============ SEED BAMFIELD LOCATIONS ============

DO $$
DECLARE
  v_portal_id uuid;
BEGIN
  -- Get Bamfield portal
  SELECT id INTO v_portal_id FROM cc_portals WHERE slug = 'bamfield' LIMIT 1;
  
  IF v_portal_id IS NULL THEN
    INSERT INTO cc_portals (slug, name, is_active)
    VALUES ('bamfield', 'Bamfield Community Portal', true)
    RETURNING id INTO v_portal_id;
  END IF;
  
  -- Port Alberni (Lady Rose departure point)
  INSERT INTO cc_locations (
    portal_id, name, code, location_type, lat, lon,
    authority_type, authority_name, authority_rules,
    stop_capabilities, notes
  ) VALUES (
    v_portal_id, 'Port Alberni Harbour Quay', 'PAHQ', 'ferry_terminal',
    49.2339, -124.8050,
    'municipal', 'City of Port Alberni',
    '{"lady_rose_terminal": true, "parking_available": true}'::jsonb,
    '{"passenger_embark":true,"passenger_disembark":true,"freight_load":true,"freight_unload":true,"kayak_landing":false,"overnight_moorage":false,"fuel_available":false,"power_available":false,"water_available":true,"boat_launch":false}'::jsonb,
    'Main departure point for MV Frances Barkley'
  ) ON CONFLICT (portal_id, code) DO UPDATE SET updated_at = now();
  
  -- Bamfield West Government Dock
  INSERT INTO cc_locations (
    portal_id, name, code, location_type, lat, lon,
    authority_type, authority_name, authority_rules,
    stop_capabilities, notes
  ) VALUES (
    v_portal_id, 'West Government Dock', 'WGD', 'dock',
    48.8337, -125.1361,
    'harbour_authority', 'Bamfield Harbour Authority',
    '{"public_access": true, "time_limit_hours": 4}'::jsonb,
    '{"passenger_embark":true,"passenger_disembark":true,"freight_load":true,"freight_unload":true,"kayak_landing":false,"overnight_moorage":false,"fuel_available":false,"power_available":false,"water_available":true,"boat_launch":false}'::jsonb,
    'West side main public dock - Lady Rose stop'
  ) ON CONFLICT (portal_id, code) DO UPDATE SET updated_at = now();
  
  -- Bamfield East Government Dock  
  INSERT INTO cc_locations (
    portal_id, name, code, location_type, lat, lon,
    authority_type, authority_name, authority_rules,
    stop_capabilities, notes
  ) VALUES (
    v_portal_id, 'East Government Dock', 'EGD', 'dock',
    48.8342, -125.1289,
    'harbour_authority', 'Bamfield Harbour Authority',
    '{"public_access": true, "time_limit_hours": 4}'::jsonb,
    '{"passenger_embark":true,"passenger_disembark":true,"freight_load":true,"freight_unload":true,"kayak_landing":false,"overnight_moorage":false,"fuel_available":false,"power_available":false,"water_available":true,"boat_launch":false}'::jsonb,
    'East side main public dock - near general store'
  ) ON CONFLICT (portal_id, code) DO UPDATE SET updated_at = now();
  
  -- Grappler Dock (boat launch)
  INSERT INTO cc_locations (
    portal_id, name, code, location_type, lat, lon,
    authority_type, authority_name, authority_rules,
    stop_capabilities, notes
  ) VALUES (
    v_portal_id, 'Grappler Inlet Dock', 'GID', 'dock',
    48.8298, -125.1195,
    'harbour_authority', 'Bamfield Harbour Authority',
    '{"boat_launch_fee": true, "daily_rate_cad": 15}'::jsonb,
    '{"passenger_embark":true,"passenger_disembark":true,"freight_load":true,"freight_unload":true,"kayak_landing":true,"overnight_moorage":false,"fuel_available":false,"power_available":false,"water_available":false,"boat_launch":true}'::jsonb,
    'Public boat launch and kayak access'
  ) ON CONFLICT (portal_id, code) DO UPDATE SET updated_at = now();
  
  -- Sechart (Broken Group staging)
  INSERT INTO cc_locations (
    portal_id, name, code, location_type, lat, lon,
    authority_type, authority_name, authority_rules,
    stop_capabilities, notes
  ) VALUES (
    v_portal_id, 'Sechart Whaling Station', 'SEC', 'dock',
    48.9167, -125.2167,
    'harbour_authority', 'Lady Rose Marine Services',
    '{"broken_group_staging": true, "kayak_rental": true}'::jsonb,
    '{"passenger_embark":true,"passenger_disembark":true,"freight_load":false,"freight_unload":false,"kayak_landing":true,"overnight_moorage":false,"fuel_available":false,"power_available":false,"water_available":false,"boat_launch":false}'::jsonb,
    'Historic whaling station - Broken Group Islands staging'
  ) ON CONFLICT (portal_id, code) DO UPDATE SET updated_at = now();
  
  -- Ucluelet
  INSERT INTO cc_locations (
    portal_id, name, code, location_type, lat, lon,
    authority_type, authority_name, authority_rules,
    stop_capabilities, notes
  ) VALUES (
    v_portal_id, 'Ucluelet Small Craft Harbour', 'USCH', 'marina',
    48.9419, -125.5467,
    'harbour_authority', 'Ucluelet Harbour Authority',
    '{"transient_moorage": true}'::jsonb,
    '{"passenger_embark":true,"passenger_disembark":true,"freight_load":true,"freight_unload":true,"kayak_landing":true,"overnight_moorage":true,"fuel_available":true,"power_available":true,"water_available":true,"boat_launch":true}'::jsonb,
    'Full-service marina - Lady Rose terminus option'
  ) ON CONFLICT (portal_id, code) DO UPDATE SET updated_at = now();
  
  -- Woods End Marina
  INSERT INTO cc_locations (
    portal_id, name, code, location_type, lat, lon,
    authority_type, authority_name, authority_rules,
    stop_capabilities, notes
  ) VALUES (
    v_portal_id, 'Woods End Marina', 'WEM', 'marina',
    48.8340, -125.1340,
    'private', 'Woods End Marina Ltd',
    '{"reservation_required": true, "guest_priority": true}'::jsonb,
    '{"passenger_embark":true,"passenger_disembark":true,"freight_load":true,"freight_unload":true,"kayak_landing":true,"overnight_moorage":true,"fuel_available":false,"power_available":true,"water_available":true,"boat_launch":false}'::jsonb,
    'Private marina - overnight moorage with power'
  ) ON CONFLICT (portal_id, code) DO UPDATE SET updated_at = now();
  
  -- Pachena Bay (WCT trailhead)
  INSERT INTO cc_locations (
    portal_id, name, code, location_type, lat, lon,
    authority_type, authority_name, authority_rules,
    stop_capabilities, notes
  ) VALUES (
    v_portal_id, 'Pachena Bay Trailhead', 'PBT', 'trailhead',
    48.7833, -125.1167,
    'parks_canada', 'Pacific Rim National Park Reserve',
    '{"permit_required": true, "permit_type": "wct_backcountry", "quota_managed": true}'::jsonb,
    '{"passenger_embark":false,"passenger_disembark":true,"freight_load":false,"freight_unload":false,"kayak_landing":false,"overnight_moorage":false,"fuel_available":false,"power_available":false,"water_available":false,"boat_launch":false}'::jsonb,
    'West Coast Trail southern terminus - Parks Canada permit required'
  ) ON CONFLICT (portal_id, code) DO UPDATE SET updated_at = now();
  
  -- Huu-ay-aht First Nation Dock
  INSERT INTO cc_locations (
    portal_id, name, code, location_type, lat, lon,
    authority_type, authority_name, authority_rules,
    stop_capabilities, notes
  ) VALUES (
    v_portal_id, 'Anacla Dock', 'ANA', 'dock',
    48.7917, -125.0917,
    'first_nation', 'Huu-ay-aht First Nations',
    '{"territory_notice": true, "respect_protocols": true}'::jsonb,
    '{"passenger_embark":true,"passenger_disembark":true,"freight_load":true,"freight_unload":true,"kayak_landing":true,"overnight_moorage":false,"fuel_available":false,"power_available":false,"water_available":false,"boat_launch":false}'::jsonb,
    'Huu-ay-aht First Nations territory - Anacla village'
  ) ON CONFLICT (portal_id, code) DO UPDATE SET updated_at = now();
  
END $$;

COMMIT;
```

## Create server/services/locationService.ts
```typescript
// server/services/locationService.ts

import { db } from '../db';
import { eq, and, or, ilike, sql, asc } from 'drizzle-orm';

// ============ TYPES ============

interface LocationSearchRequest {
  portalSlug?: string;
  portalId?: string;
  locationType?: string;
  authorityType?: string;
  capability?: string; // e.g., 'overnight_moorage', 'fuel_available'
  query?: string; // Text search
  nearLat?: number;
  nearLon?: number;
  radiusKm?: number;
  status?: string;
}

interface LocationResult {
  location: any;
  distance_km?: number;
}

// ============ FUNCTIONS ============

export async function getLocations(req: LocationSearchRequest): Promise<{
  locations: LocationResult[];
  total: number;
}> {
  let portalId = req.portalId;
  
  // Resolve portal from slug
  if (req.portalSlug && !portalId) {
    const portal = await db.query.ccPortals.findFirst({
      where: eq(ccPortals.slug, req.portalSlug)
    });
    if (portal) portalId = portal.id;
  }
  
  // Build conditions
  const conditions: any[] = [];
  
  if (portalId) {
    conditions.push(eq(ccLocations.portalId, portalId));
  }
  
  if (req.locationType) {
    conditions.push(eq(ccLocations.locationType, req.locationType));
  }
  
  if (req.authorityType) {
    conditions.push(eq(ccLocations.authorityType, req.authorityType));
  }
  
  if (req.status) {
    conditions.push(eq(ccLocations.status, req.status));
  } else {
    conditions.push(or(
      eq(ccLocations.status, 'active'),
      eq(ccLocations.status, 'seasonal')
    ));
  }
  
  if (req.query) {
    conditions.push(or(
      ilike(ccLocations.name, `%${req.query}%`),
      ilike(ccLocations.code, `%${req.query}%`)
    ));
  }
  
  // Capability filter (JSONB)
  if (req.capability) {
    conditions.push(
      sql`${ccLocations.stopCapabilities}->>${req.capability} = 'true'`
    );
  }
  
  // Query
  let locations = await db.query.ccLocations.findMany({
    where: conditions.length > 0 ? and(...conditions) : undefined,
    orderBy: [asc(ccLocations.name)]
  });
  
  // Distance calculation if coordinates provided
  let results: LocationResult[] = locations.map(loc => ({ location: loc }));
  
  if (req.nearLat && req.nearLon) {
    results = results.map(r => {
      if (r.location.lat && r.location.lon) {
        const distance = haversineDistance(
          req.nearLat!, req.nearLon!,
          Number(r.location.lat), Number(r.location.lon)
        );
        return { ...r, distance_km: Math.round(distance * 10) / 10 };
      }
      return r;
    });
    
    // Filter by radius if specified
    if (req.radiusKm) {
      results = results.filter(r => 
        r.distance_km === undefined || r.distance_km <= req.radiusKm!
      );
    }
    
    // Sort by distance
    results.sort((a, b) => (a.distance_km || 999) - (b.distance_km || 999));
  }
  
  return {
    locations: results,
    total: results.length
  };
}

export async function getLocationByCode(
  portalSlug: string,
  code: string
): Promise<any | null> {
  const portal = await db.query.ccPortals.findFirst({
    where: eq(ccPortals.slug, portalSlug)
  });
  
  if (!portal) return null;
  
  return db.query.ccLocations.findFirst({
    where: and(
      eq(ccLocations.portalId, portal.id),
      eq(ccLocations.code, code.toUpperCase())
    )
  });
}

export async function getLocationById(id: string): Promise<any | null> {
  return db.query.ccLocations.findFirst({
    where: eq(ccLocations.id, id)
  });
}

export async function getLocationTypes(portalSlug: string): Promise<string[]> {
  const portal = await db.query.ccPortals.findFirst({
    where: eq(ccPortals.slug, portalSlug)
  });
  
  if (!portal) return [];
  
  const result = await db.selectDistinct({ type: ccLocations.locationType })
    .from(ccLocations)
    .where(eq(ccLocations.portalId, portal.id));
  
  return result.map(r => r.type).filter(Boolean);
}

export async function getAuthorities(portalSlug: string): Promise<any[]> {
  const portal = await db.query.ccPortals.findFirst({
    where: eq(ccPortals.slug, portalSlug)
  });
  
  if (!portal) return [];
  
  const result = await db.selectDistinct({ 
    type: ccLocations.authorityType,
    name: ccLocations.authorityName
  })
    .from(ccLocations)
    .where(and(
      eq(ccLocations.portalId, portal.id),
      sql`${ccLocations.authorityType} IS NOT NULL`
    ));
  
  return result.filter(r => r.type);
}

// Haversine formula for distance calculation
function haversineDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {
  const R = 6371; // Earth's radius in km
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a = 
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

function toRad(deg: number): number {
  return deg * (Math.PI / 180);
}
```

## Add Location Routes

### Create server/routes/transport.ts
```typescript
// server/routes/transport.ts

import { Router } from 'express';
import { 
  getLocations, getLocationByCode, getLocationById,
  getLocationTypes, getAuthorities 
} from '../services/locationService';

const router = Router();

// ============ LOCATION ENDPOINTS ============

// GET /api/transport/portals/:slug/locations - List locations
router.get('/portals/:slug/locations', async (req, res) => {
  const { slug } = req.params;
  const { type, authority, capability, q, lat, lon, radius, status } = req.query;
  
  try {
    const result = await getLocations({
      portalSlug: slug,
      locationType: type as string,
      authorityType: authority as string,
      capability: capability as string,
      query: q as string,
      nearLat: lat ? parseFloat(lat as string) : undefined,
      nearLon: lon ? parseFloat(lon as string) : undefined,
      radiusKm: radius ? parseFloat(radius as string) : undefined,
      status: status as string
    });
    
    res.json(result);
  } catch (e: any) {
    console.error('Get locations error:', e);
    res.status(500).json({ error: 'Failed to get locations' });
  }
});

// GET /api/transport/portals/:slug/locations/types - List location types
router.get('/portals/:slug/locations/types', async (req, res) => {
  const { slug } = req.params;
  
  try {
    const types = await getLocationTypes(slug);
    res.json({ types });
  } catch (e: any) {
    console.error('Get location types error:', e);
    res.status(500).json({ error: 'Failed to get types' });
  }
});

// GET /api/transport/portals/:slug/locations/authorities - List authorities
router.get('/portals/:slug/locations/authorities', async (req, res) => {
  const { slug } = req.params;
  
  try {
    const authorities = await getAuthorities(slug);
    res.json({ authorities });
  } catch (e: any) {
    console.error('Get authorities error:', e);
    res.status(500).json({ error: 'Failed to get authorities' });
  }
});

// GET /api/transport/portals/:slug/locations/:code - Get by code
router.get('/portals/:slug/locations/:code', async (req, res) => {
  const { slug, code } = req.params;
  
  try {
    const location = await getLocationByCode(slug, code);
    if (!location) {
      return res.status(404).json({ error: 'Location not found' });
    }
    res.json({ location });
  } catch (e: any) {
    console.error('Get location error:', e);
    res.status(500).json({ error: 'Failed to get location' });
  }
});

// GET /api/transport/locations/:id - Get by ID
router.get('/locations/:id', async (req, res) => {
  const { id } = req.params;
  
  try {
    const location = await getLocationById(id);
    if (!location) {
      return res.status(404).json({ error: 'Location not found' });
    }
    res.json({ location });
  } catch (e: any) {
    console.error('Get location error:', e);
    res.status(500).json({ error: 'Failed to get location' });
  }
});

export default router;
```

### Register routes in server/index.ts
```typescript
import transportRoutes from './routes/transport';

// Add with other routes
app.use('/api/transport', transportRoutes);
```

## Drizzle Schema Export

Add to shared/schema.ts:
- Location, InsertLocation

## Deliverables
- [ ] Migration 078_locations.sql
- [ ] cc_locations table with RLS
- [ ] 9 Bamfield-area locations seeded:
  - Port Alberni Harbour Quay (PAHQ) - Lady Rose departure
  - West Government Dock (WGD)
  - East Government Dock (EGD)
  - Grappler Inlet Dock (GID) - boat launch
  - Sechart Whaling Station (SEC) - Broken Group staging
  - Ucluelet Small Craft Harbour (USCH)
  - Woods End Marina (WEM)
  - Pachena Bay Trailhead (PBT) - Parks Canada
  - Anacla Dock (ANA) - Huu-ay-aht First Nations
- [ ] server/services/locationService.ts
- [ ] server/routes/transport.ts
- [ ] Routes registered in server/index.ts
- [ ] Test: GET /api/transport/portals/bamfield/locations returns 9 locations
- [ ] Test: GET /api/transport/portals/bamfield/locations?capability=overnight_moorage returns 2 (USCH, WEM)
- [ ] Test: GET /api/transport/portals/bamfield/locations/WGD returns West Government Dock

Report with location count and capability filter test.