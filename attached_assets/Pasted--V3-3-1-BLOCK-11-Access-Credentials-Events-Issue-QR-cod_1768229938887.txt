**V3.3.1 BLOCK 11: Access Credentials + Events**

Issue QR codes, gate codes, and track access events for check-in validation.

## Create cc_access_credentials table
```sql
CREATE TABLE cc_access_credentials (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL REFERENCES cc_tenants(id),
  reservation_id uuid NOT NULL REFERENCES cc_reservations(id) ON DELETE CASCADE,
  reservation_item_id uuid REFERENCES cc_reservation_items(id),
  
  -- Credential type
  credential_type varchar NOT NULL CHECK (credential_type IN (
    'qr', 'short_code', 'gate_code', 'dock_power_token', 'key_code'
  )),
  
  -- Credential values
  qr_token varchar UNIQUE, -- UUID or JWT for QR scanning
  short_code varchar, -- 6-digit human-readable code (e.g., '284719')
  gate_code varchar, -- Gate/door code
  
  -- Scope
  scope varchar NOT NULL CHECK (scope IN (
    'facility_access', 'gate', 'dock_power', 'parking_entry', 'parking_exit', 'room'
  )),
  
  -- Validity
  valid_from timestamptz NOT NULL,
  valid_until timestamptz NOT NULL,
  
  -- Revocation
  is_revoked boolean DEFAULT false,
  revoked_at timestamptz,
  revoked_by uuid REFERENCES cc_individuals(id),
  revoked_reason varchar,
  
  -- Metadata
  issued_at timestamptz DEFAULT now(),
  issued_by uuid REFERENCES cc_individuals(id),
  
  created_at timestamptz DEFAULT now()
);

CREATE INDEX idx_credentials_token ON cc_access_credentials(qr_token) WHERE qr_token IS NOT NULL;
CREATE INDEX idx_credentials_code ON cc_access_credentials(short_code) WHERE short_code IS NOT NULL;
CREATE INDEX idx_credentials_reservation ON cc_access_credentials(reservation_id);
CREATE INDEX idx_credentials_valid ON cc_access_credentials(valid_until) WHERE NOT is_revoked;
ALTER TABLE cc_access_credentials ENABLE ROW LEVEL SECURITY;
```

## Create cc_access_events table
```sql
CREATE TABLE cc_access_events (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL REFERENCES cc_tenants(id),
  
  -- What was validated
  credential_id uuid REFERENCES cc_access_credentials(id),
  facility_id uuid REFERENCES cc_facilities(id),
  inventory_unit_id uuid REFERENCES cc_inventory_units(id),
  
  -- Event type
  event_type varchar NOT NULL CHECK (event_type IN (
    'validate', 'check_in', 'check_out', 
    'gate_open', 'gate_deny', 
    'power_connect', 'power_disconnect',
    'patrol_scan', 'manual_override'
  )),
  
  -- Result
  result varchar NOT NULL CHECK (result IN (
    'valid', 'invalid', 'expired', 'revoked', 'not_found', 'wrong_facility'
  )),
  
  -- Context
  validation_method varchar, -- 'qr_scan', 'short_code', 'plate_lookup', 'manual'
  actor_id uuid REFERENCES cc_individuals(id), -- Who performed the action
  device_id varchar, -- Scanner/terminal ID
  
  -- Additional data
  metadata jsonb DEFAULT '{}'::jsonb,
  -- Examples:
  -- {"plate": "ABC123", "matched": true}
  -- {"scanLocation": "Main Gate", "temperature": 22}
  
  recorded_at timestamptz DEFAULT now()
);

CREATE INDEX idx_access_events_credential ON cc_access_events(credential_id);
CREATE INDEX idx_access_events_facility ON cc_access_events(facility_id, recorded_at);
ALTER TABLE cc_access_events ENABLE ROW LEVEL SECURITY;
```

## Create accessService.ts
```typescript
// server/services/accessService.ts

interface IssueCredentialRequest {
  tenantId: string;
  reservationId: string;
  reservationItemId?: string;
  credentialType: 'qr' | 'short_code' | 'gate_code' | 'dock_power_token';
  scope: 'facility_access' | 'gate' | 'dock_power' | 'parking_entry' | 'room';
  validFrom: Date;
  validUntil: Date;
  issuedBy?: string;
}

interface CredentialResult {
  id: string;
  credentialType: string;
  qrToken?: string;
  shortCode?: string;
  gateCode?: string;
  validFrom: Date;
  validUntil: Date;
}

interface ValidationResult {
  valid: boolean;
  result: 'valid' | 'invalid' | 'expired' | 'revoked' | 'not_found' | 'wrong_facility';
  credential?: {
    id: string;
    reservationId: string;
    scope: string;
    validUntil: Date;
  };
  reservation?: {
    id: string;
    confirmationNumber: string;
    customerName: string;
    facilityName: string;
    unitLabel?: string;
  };
  message?: string;
}

// Issue credential for a reservation
export async function issueCredential(req: IssueCredentialRequest): Promise<CredentialResult>

// Validate by QR token
export async function validateQrToken(
  qrToken: string, 
  facilityId?: string
): Promise<ValidationResult>

// Validate by short code
export async function validateShortCode(
  shortCode: string, 
  facilityId?: string
): Promise<ValidationResult>

// Validate by license plate (for parking)
export async function validatePlate(
  plate: string, 
  facilityId: string
): Promise<ValidationResult>

// Record access event
export async function recordAccessEvent(
  credentialId: string | null,
  facilityId: string,
  eventType: string,
  result: string,
  actorId?: string,
  metadata?: Record<string, any>
): Promise<string>

// Revoke credential
export async function revokeCredential(
  credentialId: string,
  reason: string,
  revokedBy: string
): Promise<void>

// Extend credential validity
export async function extendCredential(
  credentialId: string,
  newValidUntil: Date,
  extendedBy: string
): Promise<CredentialResult>

// Get credentials for reservation
export async function getCredentialsForReservation(
  reservationId: string
): Promise<CredentialResult[]>
```

## Short Code Generation

Generate 6-digit human-readable codes that are:
- Unique within the validity window
- Avoid confusing characters (0/O, 1/I/L)
```typescript
function generateShortCode(): string {
  const chars = '23456789ABCDEFGHJKMNPQRSTUVWXYZ'; // No 0,1,I,O,L
  let code = '';
  for (let i = 0; i < 6; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return code;
}
```

## QR Token Generation

Use UUID or JWT with embedded expiry:
```typescript
function generateQrToken(reservationId: string, validUntil: Date): string {
  // Option 1: Simple UUID
  return crypto.randomUUID();
  
  // Option 2: JWT with payload (for offline validation)
  // return jwt.sign({ reservationId, exp: validUntil.getTime() / 1000 }, SECRET);
}
```

## Integration with Reservation Confirmation

Update reservationService.confirmReservation() to auto-issue credentials:
```typescript
// In confirmReservation():
if (reservation.status === 'confirmed') {
  // Issue QR + short code
  await issueCredential({
    tenantId: reservation.tenantId,
    reservationId: reservation.id,
    credentialType: 'qr',
    scope: 'facility_access',
    validFrom: reservation.startAt,
    validUntil: reservation.endAt
  });
  
  await issueCredential({
    tenantId: reservation.tenantId,
    reservationId: reservation.id,
    credentialType: 'short_code',
    scope: 'facility_access',
    validFrom: reservation.startAt,
    validUntil: reservation.endAt
  });
}
```

## Add Credential API Routes

### In server/routes/operator.ts
```typescript
// POST /api/operator/credentials/validate
router.post('/credentials/validate', requireAuth, async (req, res) => {
  const { qrToken, shortCode, plate, facilityId } = req.body;
  
  let result: ValidationResult;
  
  if (qrToken) {
    result = await validateQrToken(qrToken, facilityId);
  } else if (shortCode) {
    result = await validateShortCode(shortCode, facilityId);
  } else if (plate) {
    result = await validatePlate(plate, facilityId);
  } else {
    return res.status(400).json({ error: 'Provide qrToken, shortCode, or plate' });
  }
  
  // Record the validation attempt
  await recordAccessEvent(
    result.credential?.id || null,
    facilityId,
    'validate',
    result.result,
    req.ctx.individualId,
    { method: qrToken ? 'qr_scan' : shortCode ? 'short_code' : 'plate_lookup' }
  );
  
  // Log activity
  await logActivity({
    tenantId: req.ctx.tenantId,
    actorId: req.ctx.individualId,
    action: 'credential.validated',
    resourceType: 'credential',
    resourceId: result.credential?.id || 'unknown',
    metadata: { result: result.result, method: req.body }
  });
  
  res.json(result);
});

// POST /api/operator/credentials/:id/revoke
router.post('/credentials/:id/revoke', requireAuth, async (req, res) => {
  await revokeCredential(req.params.id, req.body.reason, req.ctx.individualId);
  res.json({ success: true });
});

// POST /api/operator/credentials/:id/extend
router.post('/credentials/:id/extend', requireAuth, async (req, res) => {
  const result = await extendCredential(
    req.params.id, 
    new Date(req.body.validUntil), 
    req.ctx.individualId
  );
  res.json(result);
});

// GET /api/operator/reservations/:id/credentials
router.get('/reservations/:id/credentials', requireAuth, async (req, res) => {
  const credentials = await getCredentialsForReservation(req.params.id);
  res.json({ credentials });
});
```

## Deliverables
- [ ] Migration file (072_access_credentials.sql)
- [ ] cc_access_credentials table with RLS
- [ ] cc_access_events table with RLS
- [ ] server/services/accessService.ts with all functions
- [ ] Credential routes in server/routes/operator.ts
- [ ] Auto-issue credentials on reservation confirmation
- [ ] Drizzle types (AccessCredential, AccessEvent)
- [ ] Activity logging for validation attempts
- [ ] Test: Create reservation → confirm → validate short code → VALID

Report with sample credential issuance and validation test result.