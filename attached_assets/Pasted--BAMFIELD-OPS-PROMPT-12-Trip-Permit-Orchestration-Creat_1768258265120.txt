**BAMFIELD OPS - PROMPT 12: Trip Permit Orchestration**

Create the system to automatically determine required permits for a trip based on itinerary and attach permits to trips.

## Migration 088_trip_permits.sql
```sql
BEGIN;

-- ============ TRIP PERMITS ============
-- Links permits to trips and tracks permit requirements for trip itinerary

CREATE TABLE IF NOT EXISTS cc_trip_permits (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Links
  portal_id uuid REFERENCES cc_portals(id) ON DELETE SET NULL,
  trip_id uuid NOT NULL REFERENCES cc_trips(id) ON DELETE CASCADE,
  permit_id uuid REFERENCES cc_visitor_permits(id) ON DELETE SET NULL,
  permit_type_id uuid NOT NULL REFERENCES cc_permit_types(id),
  authority_id uuid NOT NULL REFERENCES cc_authorities(id),
  
  -- Requirement source
  requirement_source varchar NOT NULL CHECK (requirement_source IN (
    'location',       -- Required by location visited
    'activity',       -- Required by activity type
    'duration',       -- Required by trip duration
    'party_size',     -- Required by group size
    'vessel',         -- Required for vessel/boat
    'commercial',     -- Commercial operation requirement
    'manual'          -- Manually added
  )),
  
  source_location_id uuid REFERENCES cc_locations(id),
  source_description text,
  
  -- Status
  status varchar DEFAULT 'required' CHECK (status IN (
    'required',       -- Permit is required
    'recommended',    -- Permit is recommended
    'optional',       -- Optional enhancement
    'obtained',       -- Permit has been obtained
    'waived',         -- Requirement waived
    'not_applicable'  -- Determined not needed
  )),
  
  -- Timing
  required_by date,
  obtained_at timestamptz,
  
  -- Notes
  notes text,
  waiver_reason text,
  
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  
  UNIQUE(trip_id, permit_type_id)
);

CREATE INDEX idx_trip_permits_trip ON cc_trip_permits(trip_id, status);
CREATE INDEX idx_trip_permits_permit ON cc_trip_permits(permit_id) WHERE permit_id IS NOT NULL;
CREATE INDEX idx_trip_permits_type ON cc_trip_permits(permit_type_id);

ALTER TABLE cc_trip_permits ENABLE ROW LEVEL SECURITY;

COMMIT;
```

## Create server/services/tripPermitService.ts
```typescript
// server/services/tripPermitService.ts

import { db } from '../db';
import { eq, and, or } from 'drizzle-orm';
import { getPermitTypes, getRequiredPermits } from './authorityService';
import { createPermit, issuePermit } from './permitService';
import { logActivity } from './activityService';

// ============ TYPES ============

interface PermitRequirement {
  permitTypeId: string;
  permitTypeName: string;
  permitTypeCode: string;
  authorityId: string;
  authorityName: string;
  authorityCode: string;
  requirementSource: string;
  sourceLocationId?: string;
  sourceDescription: string;
  estimatedFee: number;
  required: boolean;
}

interface TripPermitSummary {
  trip: any;
  requirements: PermitRequirement[];
  obtained: any[];
  pending: any[];
  totalEstimatedFees: number;
  allRequirementsMet: boolean;
}

// ============ REQUIREMENT ANALYSIS ============

export async function analyzeTripPermitRequirements(
  portalSlug: string,
  tripId: string
): Promise<PermitRequirement[]> {
  const portal = await db.query.ccPortals.findFirst({
    where: eq(ccPortals.slug, portalSlug)
  });
  
  if (!portal) return [];
  
  // Get trip
  const trip = await db.query.ccTrips.findFirst({
    where: eq(ccTrips.id, tripId)
  });
  
  if (!trip) return [];
  
  const requirements: PermitRequirement[] = [];
  const addedPermitTypes = new Set<string>();
  
  // Get cart items for this trip to find locations/activities
  const carts = await db.query.ccReservationCarts.findMany({
    where: eq(ccReservationCarts.tripId, tripId)
  });
  
  for (const cart of carts) {
    const items = await db.query.ccReservationCartItems.findMany({
      where: eq(ccReservationCartItems.cartId, cart.id)
    });
    
    for (const item of items) {
      // Check moments for location-based permits
      if (item.momentId) {
        const moment = await db.query.ccPortalMoments.findFirst({
          where: eq(ccPortalMoments.id, item.momentId)
        });
        
        if (moment?.locationId) {
          const locRequirements = await getRequiredPermits(portalSlug, moment.locationId);
          for (const req of locRequirements.requiredPermits) {
            if (!addedPermitTypes.has(req.permitType.id)) {
              addedPermitTypes.add(req.permitType.id);
              requirements.push({
                permitTypeId: req.permitType.id,
                permitTypeName: req.permitType.name,
                permitTypeCode: req.permitType.code,
                authorityId: req.authority.id,
                authorityName: req.authority.name,
                authorityCode: req.authority.code,
                requirementSource: 'location',
                sourceLocationId: moment.locationId,
                sourceDescription: `Required for ${moment.name} at ${locRequirements.location?.name}`,
                estimatedFee: Number(req.permitType.baseFeeCad) || 0,
                required: req.required !== false
              });
            }
          }
        }
      }
      
      // Check transport for crossing authorities
      if (item.transportRequestId) {
        const transportReq = await db.query.ccTransportRequests.findFirst({
          where: eq(ccTransportRequests.id, item.transportRequestId)
        });
        
        if (transportReq?.destinationLocationId) {
          const destRequirements = await getRequiredPermits(portalSlug, transportReq.destinationLocationId);
          for (const req of destRequirements.requiredPermits) {
            if (!addedPermitTypes.has(req.permitType.id)) {
              addedPermitTypes.add(req.permitType.id);
              requirements.push({
                permitTypeId: req.permitType.id,
                permitTypeName: req.permitType.name,
                permitTypeCode: req.permitType.code,
                authorityId: req.authority.id,
                authorityName: req.authority.name,
                authorityCode: req.authority.code,
                requirementSource: 'location',
                sourceLocationId: transportReq.destinationLocationId,
                sourceDescription: `Required for destination: ${destRequirements.location?.name}`,
                estimatedFee: Number(req.permitType.baseFeeCad) || 0,
                required: req.required !== false
              });
            }
          }
        }
      }
    }
  }
  
  // Check trip intent for activity-based permits
  const intent = trip.intentJson as any || {};
  
  if (intent.activities?.includes('west_coast_trail') || intent.activities?.includes('hiking')) {
    // Check for WCT permit
    const wctType = await db.query.ccPermitTypes.findFirst({
      where: eq(ccPermitTypes.code, 'WCT')
    });
    
    if (wctType && !addedPermitTypes.has(wctType.id)) {
      const authority = await db.query.ccAuthorities.findFirst({
        where: eq(ccAuthorities.id, wctType.authorityId)
      });
      
      if (authority) {
        addedPermitTypes.add(wctType.id);
        requirements.push({
          permitTypeId: wctType.id,
          permitTypeName: wctType.name,
          permitTypeCode: wctType.code || '',
          authorityId: authority.id,
          authorityName: authority.name,
          authorityCode: authority.code || '',
          requirementSource: 'activity',
          sourceDescription: 'West Coast Trail hiking requires Parks Canada permit',
          estimatedFee: Number(wctType.baseFeeCad) + Number(wctType.perPersonFeeCad),
          required: true
        });
      }
    }
  }
  
  if (intent.activities?.includes('kayaking') || intent.activities?.includes('broken_group')) {
    // Check for BGI permit
    const bgiType = await db.query.ccPermitTypes.findFirst({
      where: eq(ccPermitTypes.code, 'BGI')
    });
    
    if (bgiType && !addedPermitTypes.has(bgiType.id)) {
      const authority = await db.query.ccAuthorities.findFirst({
        where: eq(ccAuthorities.id, bgiType.authorityId)
      });
      
      if (authority) {
        addedPermitTypes.add(bgiType.id);
        requirements.push({
          permitTypeId: bgiType.id,
          permitTypeName: bgiType.name,
          permitTypeCode: bgiType.code || '',
          authorityId: authority.id,
          authorityName: authority.name,
          authorityCode: authority.code || '',
          requirementSource: 'activity',
          sourceDescription: 'Broken Group Islands camping requires Parks Canada permit',
          estimatedFee: Number(bgiType.baseFeeCad) + Number(bgiType.perNightFeeCad),
          required: true
        });
      }
    }
  }
  
  // Always recommend First Nations territory acknowledgment
  const tanType = await db.query.ccPermitTypes.findFirst({
    where: eq(ccPermitTypes.code, 'TAN')
  });
  
  if (tanType && !addedPermitTypes.has(tanType.id)) {
    const authority = await db.query.ccAuthorities.findFirst({
      where: eq(ccAuthorities.id, tanType.authorityId)
    });
    
    if (authority) {
      addedPermitTypes.add(tanType.id);
      requirements.push({
        permitTypeId: tanType.id,
        permitTypeName: tanType.name,
        permitTypeCode: tanType.code || '',
        authorityId: authority.id,
        authorityName: authority.name,
        authorityCode: authority.code || '',
        requirementSource: 'location',
        sourceDescription: 'Acknowledgment of entry into Huu-ay-aht traditional territory',
        estimatedFee: 0,
        required: true
      });
    }
  }
  
  return requirements;
}

// ============ TRIP PERMIT MANAGEMENT ============

export async function createTripPermitRequirements(
  portalSlug: string,
  tripId: string
): Promise<any[]> {
  const portal = await db.query.ccPortals.findFirst({
    where: eq(ccPortals.slug, portalSlug)
  });
  
  if (!portal) throw new Error('Portal not found');
  
  // Analyze requirements
  const requirements = await analyzeTripPermitRequirements(portalSlug, tripId);
  
  const created: any[] = [];
  
  for (const req of requirements) {
    // Check if already exists
    const existing = await db.query.ccTripPermits.findFirst({
      where: and(
        eq(ccTripPermits.tripId, tripId),
        eq(ccTripPermits.permitTypeId, req.permitTypeId)
      )
    });
    
    if (!existing) {
      const [tripPermit] = await db.insert(ccTripPermits).values({
        portalId: portal.id,
        tripId,
        permitTypeId: req.permitTypeId,
        authorityId: req.authorityId,
        requirementSource: req.requirementSource,
        sourceLocationId: req.sourceLocationId,
        sourceDescription: req.sourceDescription,
        status: req.required ? 'required' : 'recommended'
      }).returning();
      
      created.push({ tripPermit, requirement: req });
    }
  }
  
  return created;
}

export async function getTripPermitSummary(
  portalSlug: string,
  tripId: string
): Promise<TripPermitSummary | null> {
  const portal = await db.query.ccPortals.findFirst({
    where: eq(ccPortals.slug, portalSlug)
  });
  
  if (!portal) return null;
  
  const trip = await db.query.ccTrips.findFirst({
    where: eq(ccTrips.id, tripId)
  });
  
  if (!trip) return null;
  
  // Get trip permit records
  const tripPermits = await db.query.ccTripPermits.findMany({
    where: and(
      eq(ccTripPermits.portalId, portal.id),
      eq(ccTripPermits.tripId, tripId)
    )
  });
  
  // Enrich with permit type info
  const requirements: PermitRequirement[] = [];
  const obtained: any[] = [];
  const pending: any[] = [];
  let totalEstimatedFees = 0;
  
  for (const tp of tripPermits) {
    const permitType = await db.query.ccPermitTypes.findFirst({
      where: eq(ccPermitTypes.id, tp.permitTypeId)
    });
    
    const authority = await db.query.ccAuthorities.findFirst({
      where: eq(ccAuthorities.id, tp.authorityId)
    });
    
    if (!permitType || !authority) continue;
    
    const estimatedFee = Number(permitType.baseFeeCad) || 0;
    totalEstimatedFees += estimatedFee;
    
    const req: PermitRequirement = {
      permitTypeId: tp.permitTypeId,
      permitTypeName: permitType.name,
      permitTypeCode: permitType.code || '',
      authorityId: tp.authorityId,
      authorityName: authority.name,
      authorityCode: authority.code || '',
      requirementSource: tp.requirementSource,
      sourceLocationId: tp.sourceLocationId,
      sourceDescription: tp.sourceDescription || '',
      estimatedFee,
      required: tp.status === 'required'
    };
    
    requirements.push(req);
    
    if (tp.status === 'obtained' && tp.permitId) {
      const permit = await db.query.ccVisitorPermits.findFirst({
        where: eq(ccVisitorPermits.id, tp.permitId)
      });
      obtained.push({ tripPermit: tp, permit, permitType, authority });
    } else if (['required', 'recommended'].includes(tp.status)) {
      pending.push({ tripPermit: tp, permitType, authority });
    }
  }
  
  const allRequirementsMet = tripPermits
    .filter(tp => tp.status === 'required')
    .every(tp => tp.status === 'obtained' || tp.status === 'waived');
  
  return {
    trip,
    requirements,
    obtained,
    pending,
    totalEstimatedFees,
    allRequirementsMet
  };
}

export async function obtainPermitForTrip(
  portalSlug: string,
  tripId: string,
  permitTypeId: string,
  applicantInfo: {
    name: string;
    email?: string;
    phone?: string;
    partySize?: number;
    partyMembers?: string[];
  },
  dates: {
    validFrom: Date;
    validTo: Date;
  }
): Promise<{
  tripPermit: any;
  permit: any;
}> {
  const portal = await db.query.ccPortals.findFirst({
    where: eq(ccPortals.slug, portalSlug)
  });
  
  if (!portal) throw new Error('Portal not found');
  
  // Get or create trip permit record
  let tripPermit = await db.query.ccTripPermits.findFirst({
    where: and(
      eq(ccTripPermits.tripId, tripId),
      eq(ccTripPermits.permitTypeId, permitTypeId)
    )
  });
  
  if (!tripPermit) {
    const permitType = await db.query.ccPermitTypes.findFirst({
      where: eq(ccPermitTypes.id, permitTypeId)
    });
    
    if (!permitType) throw new Error('Permit type not found');
    
    [tripPermit] = await db.insert(ccTripPermits).values({
      portalId: portal.id,
      tripId,
      permitTypeId,
      authorityId: permitType.authorityId,
      requirementSource: 'manual',
      sourceDescription: 'Manually obtained',
      status: 'required'
    }).returning();
  }
  
  // Create the actual permit
  const permitResult = await createPermit({
    portalSlug,
    permitTypeId,
    tripId,
    applicantName: applicantInfo.name,
    applicantEmail: applicantInfo.email,
    applicantPhone: applicantInfo.phone,
    partySize: applicantInfo.partySize,
    partyMembers: applicantInfo.partyMembers,
    validFrom: dates.validFrom,
    validTo: dates.validTo
  });
  
  // Auto-approve and issue for certain permit types (like free territory notices)
  const permitType = await db.query.ccPermitTypes.findFirst({
    where: eq(ccPermitTypes.id, permitTypeId)
  });
  
  let finalPermit = permitResult.permit;
  
  if (permitType && Number(permitType.baseFeeCad) === 0 && 
      Number(permitType.perPersonFeeCad) === 0 &&
      Number(permitType.perDayFeeCad) === 0 &&
      Number(permitType.perNightFeeCad) === 0) {
    // Auto-issue free permits
    finalPermit = await issuePermit(portalSlug, permitResult.permit.id);
  }
  
  // Update trip permit record
  const [updatedTripPermit] = await db.update(ccTripPermits)
    .set({
      permitId: finalPermit.id,
      status: 'obtained',
      obtainedAt: new Date(),
      updatedAt: new Date()
    })
    .where(eq(ccTripPermits.id, tripPermit.id))
    .returning();
  
  await logActivity({
    tenantId: 'system',
    actorId: applicantInfo.email || 'guest',
    action: 'trip_permit.obtained',
    resourceType: 'trip_permit',
    resourceId: updatedTripPermit.id,
    metadata: {
      tripId,
      permitNumber: finalPermit.permitNumber,
      permitType: permitType?.name
    }
  });
  
  return {
    tripPermit: updatedTripPermit,
    permit: finalPermit
  };
}

export async function waiveTripPermit(
  portalSlug: string,
  tripPermitId: string,
  reason: string
): Promise<any> {
  const portal = await db.query.ccPortals.findFirst({
    where: eq(ccPortals.slug, portalSlug)
  });
  
  if (!portal) throw new Error('Portal not found');
  
  const [updated] = await db.update(ccTripPermits)
    .set({
      status: 'waived',
      waiverReason: reason,
      updatedAt: new Date()
    })
    .where(and(
      eq(ccTripPermits.id, tripPermitId),
      eq(ccTripPermits.portalId, portal.id)
    ))
    .returning();
  
  return updated;
}
```

## Add Trip Permit Routes to permits.ts
```typescript
// Add to server/routes/permits.ts

import {
  analyzeTripPermitRequirements, createTripPermitRequirements,
  getTripPermitSummary, obtainPermitForTrip, waiveTripPermit
} from '../services/tripPermitService';

// ============ TRIP PERMIT ORCHESTRATION ENDPOINTS ============

// GET /api/permits/portals/:slug/trips/:tripId/analyze - Analyze permit requirements
router.get('/portals/:slug/trips/:tripId/analyze', async (req, res) => {
  const { slug, tripId } = req.params;
  
  try {
    const requirements = await analyzeTripPermitRequirements(slug, tripId);
    
    const totalEstimated = requirements.reduce((sum, r) => sum + r.estimatedFee, 0);
    const requiredCount = requirements.filter(r => r.required).length;
    
    res.json({ 
      requirements, 
      count: requirements.length,
      requiredCount,
      totalEstimatedFees: totalEstimated
    });
  } catch (e: any) {
    console.error('Analyze requirements error:', e);
    res.status(500).json({ error: 'Failed to analyze requirements' });
  }
});

// POST /api/permits/portals/:slug/trips/:tripId/requirements - Create requirement records
router.post('/portals/:slug/trips/:tripId/requirements', async (req, res) => {
  const { slug, tripId } = req.params;
  
  try {
    const created = await createTripPermitRequirements(slug, tripId);
    res.json({ created, count: created.length });
  } catch (e: any) {
    console.error('Create requirements error:', e);
    res.status(400).json({ error: e.message });
  }
});

// GET /api/permits/portals/:slug/trips/:tripId/summary - Get permit summary for trip
router.get('/portals/:slug/trips/:tripId/summary', async (req, res) => {
  const { slug, tripId } = req.params;
  
  try {
    const summary = await getTripPermitSummary(slug, tripId);
    if (!summary) {
      return res.status(404).json({ error: 'Trip not found' });
    }
    res.json(summary);
  } catch (e: any) {
    console.error('Get summary error:', e);
    res.status(500).json({ error: 'Failed to get summary' });
  }
});

// POST /api/permits/portals/:slug/trips/:tripId/obtain - Obtain permit for trip
router.post('/portals/:slug/trips/:tripId/obtain', async (req, res) => {
  const { slug, tripId } = req.params;
  const b = req.body || {};
  
  if (!b.permitTypeId || !b.applicantName || !b.validFrom || !b.validTo) {
    return res.status(400).json({ 
      error: 'permitTypeId, applicantName, validFrom, validTo required' 
    });
  }
  
  try {
    const result = await obtainPermitForTrip(
      slug,
      tripId,
      b.permitTypeId,
      {
        name: b.applicantName,
        email: b.applicantEmail,
        phone: b.applicantPhone,
        partySize: b.partySize,
        partyMembers: b.partyMembers
      },
      {
        validFrom: new Date(b.validFrom),
        validTo: new Date(b.validTo)
      }
    );
    
    res.json(result);
  } catch (e: any) {
    console.error('Obtain permit error:', e);
    res.status(400).json({ error: e.message });
  }
});

// POST /api/permits/portals/:slug/trip-permits/:id/waive - Waive requirement
router.post('/portals/:slug/trip-permits/:id/waive', async (req, res) => {
  const { slug, id } = req.params;
  const { reason } = req.body || {};
  
  if (!reason) {
    return res.status(400).json({ error: 'reason required' });
  }
  
  try {
    const tripPermit = await waiveTripPermit(slug, id, reason);
    res.json({ tripPermit });
  } catch (e: any) {
    console.error('Waive permit error:', e);
    res.status(400).json({ error: e.message });
  }
});
```

## Drizzle Schema Export

Add to shared/schema.ts:
- TripPermit, InsertTripPermit

## Deliverables
- [ ] Migration 088_trip_permits.sql
- [ ] cc_trip_permits table with RLS
- [ ] server/services/tripPermitService.ts
- [ ] Routes added to server/routes/permits.ts:
  - GET /portals/:slug/trips/:tripId/analyze
  - POST /portals/:slug/trips/:tripId/requirements
  - GET /portals/:slug/trips/:tripId/summary
  - POST /portals/:slug/trips/:tripId/obtain
  - POST /portals/:slug/trip-permits/:id/waive
- [ ] Analysis detects requirements from:
  - Locations in cart items
  - Transport destinations
  - Trip intent/activities
  - Always includes First Nations territory notice
- [ ] Free permits (TAN) auto-issue on obtain
- [ ] Summary shows obtained vs pending permits
- [ ] Test: Create trip with WCT intent → analysis returns WCT + TAN requirements
- [ ] Test: Obtain TAN permit → auto-issued (free), trip permit marked obtained

Report with trip analysis showing detected requirements and obtain result.