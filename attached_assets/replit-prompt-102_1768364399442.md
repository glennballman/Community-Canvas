# PROMPT 24 - BUNDLE 102: Jobs Cold-Start Wedge

## Context
- Previous migration: 101_seed_actor_types_and_plans.sql
- This is migration 102
- Jobs are the cold-start wedge - they can exist WITHOUT an onboarded tenant

## Objective
Create jobs as first-class objects that can be posted by tenants, operators, OR portal placeholders (for Adrenaline Canada auto-syndication). Also create cc_communities to organize jobs geographically.

## CRITICAL DESIGN PRINCIPLE
- Jobs can exist without a tenant (tenant_id is NULLABLE)
- Jobs can be AI-generated or scraped and await employer claim
- This enables cold-start: post jobs → attract workers → employers claim → full onboarding

---

## Migration: server/migrations/102_jobs_cold_start_communities.sql

```sql
-- ============================================================
-- MIGRATION 102: JOBS COLD-START WEDGE
-- Part of Prompt 24 - Jobs as First-Class Objects
-- ============================================================

BEGIN;

-- ============================================================
-- 1) COMMUNITIES (Geographic Organization)
-- ============================================================

CREATE TABLE IF NOT EXISTS cc_communities (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Identity
  name text NOT NULL,
  slug text NOT NULL UNIQUE,
  description text,
  
  -- Geography
  region_name text,
  province text DEFAULT 'BC',
  country text DEFAULT 'Canada',
  latitude numeric,
  longitude numeric,
  timezone text DEFAULT 'America/Vancouver',
  
  -- Characteristics
  population_estimate integer,
  is_remote boolean DEFAULT false,
  access_notes text,
  
  -- Associated portal (if any)
  portal_id uuid REFERENCES cc_portals(id),
  
  -- Status
  is_active boolean NOT NULL DEFAULT true,
  
  -- Timestamps
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX idx_cc_communities_slug ON cc_communities(slug);
CREATE INDEX idx_cc_communities_portal ON cc_communities(portal_id);
CREATE INDEX idx_cc_communities_active ON cc_communities(is_active);
CREATE INDEX idx_cc_communities_region ON cc_communities(region_name, province);

-- Enable RLS
ALTER TABLE cc_communities ENABLE ROW LEVEL SECURITY;

-- Communities are publicly readable
CREATE POLICY cc_communities_public_read ON cc_communities
  FOR SELECT
  USING (is_active = true);

CREATE POLICY cc_communities_service_bypass ON cc_communities
  FOR ALL
  USING (current_setting('app.tenant_id', true) = '__SERVICE__')
  WITH CHECK (current_setting('app.tenant_id', true) = '__SERVICE__');

-- ============================================================
-- 2) JOBS (First-Class, Tenant-Optional)
-- ============================================================

-- Job role categories
CREATE TYPE job_role_category AS ENUM (
  'housekeeping',
  'cook',
  'server',
  'bartender',
  'maintenance',
  'landscaping',
  'marina',
  'dock_attendant',
  'driver',
  'guide',
  'retail',
  'general_labour',
  'skilled_trade',
  'administrative',
  'management',
  'security',
  'childcare',
  'healthcare',
  'other'
);

CREATE TYPE job_employment_type AS ENUM (
  'full_time',
  'part_time',
  'seasonal',
  'contract',
  'on_call',
  'temporary'
);

CREATE TYPE job_urgency AS ENUM (
  'normal',
  'urgent',
  'emergency'
);

CREATE TYPE job_verification_state AS ENUM (
  'draft',
  'awaiting_employer',
  'verified',
  'rejected',
  'expired'
);

CREATE TYPE job_status AS ENUM (
  'open',
  'paused',
  'filled',
  'expired',
  'cancelled'
);

CREATE TABLE IF NOT EXISTS cc_jobs (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Identity
  title text NOT NULL,
  slug text,
  role_category job_role_category NOT NULL,
  employment_type job_employment_type NOT NULL,
  
  -- Location
  community_id uuid REFERENCES cc_communities(id),
  location_text text,
  latitude numeric,
  longitude numeric,
  
  -- Work Details
  description text NOT NULL,
  responsibilities text,
  requirements text,
  nice_to_have text,
  
  -- Dates
  start_date date,
  end_date date,
  is_flexible_dates boolean DEFAULT false,
  hours_per_week integer,
  shift_details text,
  
  -- Urgency
  urgency job_urgency NOT NULL DEFAULT 'normal',
  
  -- Housing & Logistics (CRITICAL for rural jobs)
  housing_provided boolean DEFAULT false,
  housing_type text,
  housing_description text,
  rv_friendly boolean DEFAULT false,
  meals_provided boolean DEFAULT false,
  transport_assistance boolean DEFAULT false,
  relocation_assistance boolean DEFAULT false,
  
  -- Compensation (truth layer - may not match disclosure)
  pay_type text,
  pay_min numeric,
  pay_max numeric,
  currency text DEFAULT 'CAD',
  benefits_description text,
  
  -- Disclosure layer (what public sees)
  disclosed_pay_min numeric,
  disclosed_pay_max numeric,
  show_pay boolean DEFAULT true,
  
  -- Provenance & Trust
  source_type text NOT NULL DEFAULT 'manual',
  source_url text,
  verification_state job_verification_state NOT NULL DEFAULT 'draft',
  disclaimer_text text,
  verified_at timestamptz,
  verified_by_user_id uuid REFERENCES cc_user_profiles(id),
  
  -- Ownership (ALL NULLABLE - this is the key design)
  tenant_id uuid REFERENCES cc_tenants(id),
  operator_id uuid REFERENCES cc_operators(id),
  party_id uuid REFERENCES cc_parties(id),
  portal_id uuid REFERENCES cc_portals(id),
  created_by_user_id uuid REFERENCES cc_user_profiles(id),
  
  -- Lifecycle
  status job_status NOT NULL DEFAULT 'open',
  filled_at timestamptz,
  expires_at timestamptz,
  
  -- Stats
  view_count integer DEFAULT 0,
  application_count integer DEFAULT 0,
  
  -- Timestamps
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX idx_cc_jobs_community ON cc_jobs(community_id);
CREATE INDEX idx_cc_jobs_status ON cc_jobs(status);
CREATE INDEX idx_cc_jobs_verification ON cc_jobs(verification_state);
CREATE INDEX idx_cc_jobs_role ON cc_jobs(role_category);
CREATE INDEX idx_cc_jobs_employment ON cc_jobs(employment_type);
CREATE INDEX idx_cc_jobs_urgency ON cc_jobs(urgency);
CREATE INDEX idx_cc_jobs_tenant ON cc_jobs(tenant_id);
CREATE INDEX idx_cc_jobs_operator ON cc_jobs(operator_id);
CREATE INDEX idx_cc_jobs_portal ON cc_jobs(portal_id);
CREATE INDEX idx_cc_jobs_slug ON cc_jobs(slug);
CREATE INDEX idx_cc_jobs_housing ON cc_jobs(housing_provided) WHERE housing_provided = true;
CREATE INDEX idx_cc_jobs_open ON cc_jobs(status, urgency) WHERE status = 'open';

-- Enable RLS
ALTER TABLE cc_jobs ENABLE ROW LEVEL SECURITY;

-- Public can read open, verified jobs
CREATE POLICY cc_jobs_public_read ON cc_jobs
  FOR SELECT
  USING (status = 'open' AND verification_state = 'verified');

-- Unverified jobs readable with disclaimer
CREATE POLICY cc_jobs_unverified_read ON cc_jobs
  FOR SELECT
  USING (status = 'open' AND verification_state IN ('draft', 'awaiting_employer'));

-- Tenant can manage their jobs
CREATE POLICY cc_jobs_tenant_manage ON cc_jobs
  FOR ALL
  USING (tenant_id::text = current_setting('app.tenant_id', true))
  WITH CHECK (tenant_id::text = current_setting('app.tenant_id', true));

-- Service bypass
CREATE POLICY cc_jobs_service_bypass ON cc_jobs
  FOR ALL
  USING (current_setting('app.tenant_id', true) = '__SERVICE__')
  WITH CHECK (current_setting('app.tenant_id', true) = '__SERVICE__');

-- ============================================================
-- 3) JOB POSTINGS (Portal Syndication)
-- Which portals show which jobs
-- ============================================================

CREATE TABLE IF NOT EXISTS cc_job_postings (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  job_id uuid NOT NULL REFERENCES cc_jobs(id) ON DELETE CASCADE,
  portal_id uuid NOT NULL REFERENCES cc_portals(id) ON DELETE CASCADE,
  
  -- Display options
  is_featured boolean DEFAULT false,
  is_pinned boolean DEFAULT false,
  is_hidden boolean DEFAULT false,
  pin_rank integer,
  
  -- Portal-specific overrides
  custom_title text,
  custom_description text,
  
  -- Auto-syndication source
  auto_syndicated boolean DEFAULT false,
  syndication_rule_id uuid,
  
  -- Timestamps
  posted_at timestamptz NOT NULL DEFAULT now(),
  expires_at timestamptz,
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE UNIQUE INDEX idx_cc_job_postings_unique ON cc_job_postings(job_id, portal_id);
CREATE INDEX idx_cc_job_postings_portal ON cc_job_postings(portal_id);
CREATE INDEX idx_cc_job_postings_featured ON cc_job_postings(portal_id, is_featured) WHERE is_featured = true;

-- Enable RLS
ALTER TABLE cc_job_postings ENABLE ROW LEVEL SECURITY;

-- Public read for visible postings
CREATE POLICY cc_job_postings_public_read ON cc_job_postings
  FOR SELECT
  USING (NOT is_hidden);

-- Service bypass
CREATE POLICY cc_job_postings_service_bypass ON cc_job_postings
  FOR ALL
  USING (current_setting('app.tenant_id', true) = '__SERVICE__')
  WITH CHECK (current_setting('app.tenant_id', true) = '__SERVICE__');

-- ============================================================
-- 4) JOB APPLICANTS
-- ============================================================

CREATE TABLE IF NOT EXISTS cc_job_applicants (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  job_id uuid NOT NULL REFERENCES cc_jobs(id) ON DELETE CASCADE,
  
  -- Applicant identity (individual_id nullable until onboarded)
  individual_id uuid REFERENCES cc_individuals(id),
  name text NOT NULL,
  email text,
  phone text,
  
  -- Application
  cover_letter text,
  resume_url text,
  resume_media_id uuid,
  
  -- Status
  status text NOT NULL DEFAULT 'applied',
  
  -- Notes
  internal_notes text,
  
  -- Routing (for non-onboarded employers)
  routed_to_email text,
  routed_at timestamptz,
  
  -- Response
  responded_at timestamptz,
  response_type text,
  
  -- Timestamps
  applied_at timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  
  -- Require email OR phone
  CONSTRAINT applicant_has_contact CHECK (email IS NOT NULL OR phone IS NOT NULL)
);

CREATE INDEX idx_cc_job_applicants_job ON cc_job_applicants(job_id);
CREATE INDEX idx_cc_job_applicants_individual ON cc_job_applicants(individual_id);
CREATE INDEX idx_cc_job_applicants_status ON cc_job_applicants(status);
CREATE INDEX idx_cc_job_applicants_email ON cc_job_applicants(email);

-- Enable RLS
ALTER TABLE cc_job_applicants ENABLE ROW LEVEL SECURITY;

-- Job owner can see applicants
CREATE POLICY cc_job_applicants_job_owner ON cc_job_applicants
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM cc_jobs j
      WHERE j.id = cc_job_applicants.job_id
        AND j.tenant_id::text = current_setting('app.tenant_id', true)
    )
  );

-- Applicant can see their own
CREATE POLICY cc_job_applicants_self ON cc_job_applicants
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM cc_individuals i
      JOIN cc_parties p ON i.party_id = p.id
      WHERE i.id = cc_job_applicants.individual_id
        AND p.tenant_id::text = current_setting('app.tenant_id', true)
    )
  );

-- Service bypass
CREATE POLICY cc_job_applicants_service_bypass ON cc_job_applicants
  FOR ALL
  USING (current_setting('app.tenant_id', true) = '__SERVICE__')
  WITH CHECK (current_setting('app.tenant_id', true) = '__SERVICE__');

-- ============================================================
-- 5) SEED INITIAL COMMUNITIES
-- ============================================================

INSERT INTO cc_communities (name, slug, description, region_name, province, is_remote, access_notes)
VALUES 
  ('Bamfield', 'bamfield', 'West Coast fishing village with marine research station', 'Alberni-Clayoquot', 'BC', true, 'Access via gravel road from Port Alberni or water taxi from Ucluelet'),
  ('Tofino', 'tofino', 'Surfing and tourism destination on Vancouver Island''s west coast', 'Alberni-Clayoquot', 'BC', false, 'Paved highway from Port Alberni'),
  ('Ucluelet', 'ucluelet', 'Fishing and tourism community near Pacific Rim National Park', 'Alberni-Clayoquot', 'BC', false, 'Paved highway from Port Alberni')
ON CONFLICT (slug) DO NOTHING;

COMMIT;
```

---

## Drizzle Schema: Add to shared/schema.ts

```typescript
// ============================================================
// COMMUNITIES (Bundle 102)
// ============================================================

export const ccCommunities = pgTable("cc_communities", {
  id: uuid("id").primaryKey().defaultRandom(),
  name: text("name").notNull(),
  slug: text("slug").notNull().unique(),
  description: text("description"),
  regionName: text("region_name"),
  province: text("province").default("BC"),
  country: text("country").default("Canada"),
  latitude: numeric("latitude"),
  longitude: numeric("longitude"),
  timezone: text("timezone").default("America/Vancouver"),
  populationEstimate: integer("population_estimate"),
  isRemote: boolean("is_remote").default(false),
  accessNotes: text("access_notes"),
  portalId: uuid("portal_id").references(() => ccPortals.id),
  isActive: boolean("is_active").notNull().default(true),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
}, (table) => ({
  slugIdx: index("idx_cc_communities_slug").on(table.slug),
  portalIdx: index("idx_cc_communities_portal").on(table.portalId),
}));

export type Community = typeof ccCommunities.$inferSelect;

// ============================================================
// JOBS (Bundle 102)
// ============================================================

export const jobRoleCategoryEnum = pgEnum("job_role_category", [
  "housekeeping", "cook", "server", "bartender", "maintenance", 
  "landscaping", "marina", "dock_attendant", "driver", "guide", 
  "retail", "general_labour", "skilled_trade", "administrative", 
  "management", "security", "childcare", "healthcare", "other"
]);

export const jobEmploymentTypeEnum = pgEnum("job_employment_type", [
  "full_time", "part_time", "seasonal", "contract", "on_call", "temporary"
]);

export const jobUrgencyEnum = pgEnum("job_urgency", [
  "normal", "urgent", "emergency"
]);

export const jobVerificationStateEnum = pgEnum("job_verification_state", [
  "draft", "awaiting_employer", "verified", "rejected", "expired"
]);

export const jobStatusEnum = pgEnum("job_status", [
  "open", "paused", "filled", "expired", "cancelled"
]);

export const ccJobs = pgTable("cc_jobs", {
  id: uuid("id").primaryKey().defaultRandom(),
  title: text("title").notNull(),
  slug: text("slug"),
  roleCategory: jobRoleCategoryEnum("role_category").notNull(),
  employmentType: jobEmploymentTypeEnum("employment_type").notNull(),
  
  communityId: uuid("community_id").references(() => ccCommunities.id),
  locationText: text("location_text"),
  latitude: numeric("latitude"),
  longitude: numeric("longitude"),
  
  description: text("description").notNull(),
  responsibilities: text("responsibilities"),
  requirements: text("requirements"),
  niceToHave: text("nice_to_have"),
  
  startDate: date("start_date"),
  endDate: date("end_date"),
  isFlexibleDates: boolean("is_flexible_dates").default(false),
  hoursPerWeek: integer("hours_per_week"),
  shiftDetails: text("shift_details"),
  
  urgency: jobUrgencyEnum("urgency").notNull().default("normal"),
  
  housingProvided: boolean("housing_provided").default(false),
  housingType: text("housing_type"),
  housingDescription: text("housing_description"),
  rvFriendly: boolean("rv_friendly").default(false),
  mealsProvided: boolean("meals_provided").default(false),
  transportAssistance: boolean("transport_assistance").default(false),
  relocationAssistance: boolean("relocation_assistance").default(false),
  
  payType: text("pay_type"),
  payMin: numeric("pay_min"),
  payMax: numeric("pay_max"),
  currency: text("currency").default("CAD"),
  benefitsDescription: text("benefits_description"),
  
  disclosedPayMin: numeric("disclosed_pay_min"),
  disclosedPayMax: numeric("disclosed_pay_max"),
  showPay: boolean("show_pay").default(true),
  
  sourceType: text("source_type").notNull().default("manual"),
  sourceUrl: text("source_url"),
  verificationState: jobVerificationStateEnum("verification_state").notNull().default("draft"),
  disclaimerText: text("disclaimer_text"),
  verifiedAt: timestamp("verified_at", { withTimezone: true }),
  verifiedByUserId: uuid("verified_by_user_id").references(() => ccUserProfiles.id),
  
  tenantId: uuid("tenant_id").references(() => ccTenants.id),
  operatorId: uuid("operator_id").references(() => ccOperators.id),
  partyId: uuid("party_id").references(() => ccParties.id),
  portalId: uuid("portal_id").references(() => ccPortals.id),
  createdByUserId: uuid("created_by_user_id").references(() => ccUserProfiles.id),
  
  status: jobStatusEnum("status").notNull().default("open"),
  filledAt: timestamp("filled_at", { withTimezone: true }),
  expiresAt: timestamp("expires_at", { withTimezone: true }),
  
  viewCount: integer("view_count").default(0),
  applicationCount: integer("application_count").default(0),
  
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
}, (table) => ({
  communityIdx: index("idx_cc_jobs_community").on(table.communityId),
  statusIdx: index("idx_cc_jobs_status").on(table.status),
  roleIdx: index("idx_cc_jobs_role").on(table.roleCategory),
}));

export const insertJobSchema = createInsertSchema(ccJobs).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
  viewCount: true,
  applicationCount: true,
});

export type Job = typeof ccJobs.$inferSelect;
export type InsertJob = z.infer<typeof insertJobSchema>;

// ============================================================
// JOB POSTINGS (Bundle 102)
// ============================================================

export const ccJobPostings = pgTable("cc_job_postings", {
  id: uuid("id").primaryKey().defaultRandom(),
  jobId: uuid("job_id").notNull().references(() => ccJobs.id, { onDelete: "cascade" }),
  portalId: uuid("portal_id").notNull().references(() => ccPortals.id, { onDelete: "cascade" }),
  isFeatured: boolean("is_featured").default(false),
  isPinned: boolean("is_pinned").default(false),
  isHidden: boolean("is_hidden").default(false),
  pinRank: integer("pin_rank"),
  customTitle: text("custom_title"),
  customDescription: text("custom_description"),
  autoSyndicated: boolean("auto_syndicated").default(false),
  syndicationRuleId: uuid("syndication_rule_id"),
  postedAt: timestamp("posted_at", { withTimezone: true }).notNull().defaultNow(),
  expiresAt: timestamp("expires_at", { withTimezone: true }),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
}, (table) => ({
  uniqueJobPortal: uniqueIndex("idx_cc_job_postings_unique").on(table.jobId, table.portalId),
  portalIdx: index("idx_cc_job_postings_portal").on(table.portalId),
}));

export type JobPosting = typeof ccJobPostings.$inferSelect;

// ============================================================
// JOB APPLICANTS (Bundle 102)
// ============================================================

export const ccJobApplicants = pgTable("cc_job_applicants", {
  id: uuid("id").primaryKey().defaultRandom(),
  jobId: uuid("job_id").notNull().references(() => ccJobs.id, { onDelete: "cascade" }),
  individualId: uuid("individual_id").references(() => ccIndividuals.id),
  name: text("name").notNull(),
  email: text("email"),
  phone: text("phone"),
  coverLetter: text("cover_letter"),
  resumeUrl: text("resume_url"),
  resumeMediaId: uuid("resume_media_id"),
  status: text("status").notNull().default("applied"),
  internalNotes: text("internal_notes"),
  routedToEmail: text("routed_to_email"),
  routedAt: timestamp("routed_at", { withTimezone: true }),
  respondedAt: timestamp("responded_at", { withTimezone: true }),
  responseType: text("response_type"),
  appliedAt: timestamp("applied_at", { withTimezone: true }).notNull().defaultNow(),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
}, (table) => ({
  jobIdx: index("idx_cc_job_applicants_job").on(table.jobId),
  individualIdx: index("idx_cc_job_applicants_individual").on(table.individualId),
  statusIdx: index("idx_cc_job_applicants_status").on(table.status),
}));

export const insertJobApplicantSchema = createInsertSchema(ccJobApplicants)
  .omit({ id: true, createdAt: true, updatedAt: true, appliedAt: true })
  .refine(data => data.email || data.phone, {
    message: "Either email or phone is required"
  });

export type JobApplicant = typeof ccJobApplicants.$inferSelect;
```

---

## API Routes: server/routes/jobs.ts

```typescript
// Basic job routes - implement these endpoints
// GET  /api/jobs - List jobs with filters
// GET  /api/jobs/:id - Get single job
// POST /api/jobs - Create job (auth required)
// PUT  /api/jobs/:id - Update job (owner only)
// POST /api/jobs/:id/apply - Apply to job (public, requires email OR phone)
// GET  /api/jobs/:id/applicants - List applicants (owner only)
```

---

## Acceptance Criteria

1. [ ] Migration 102 runs without errors
2. [ ] cc_communities table created with Bamfield, Tofino, Ucluelet seeded
3. [ ] cc_jobs table created with all columns
4. [ ] cc_job_postings table created for portal syndication
5. [ ] cc_job_applicants table created with contact constraint
6. [ ] All enums created (job_role_category, job_employment_type, etc.)
7. [ ] RLS enabled on all tables
8. [ ] Jobs can be created WITHOUT a tenant_id (nullable FK)
9. [ ] Drizzle schema updated and synced

---

## Test Queries

```sql
-- Verify communities seeded
SELECT name, slug, is_remote FROM cc_communities;

-- Verify jobs table structure
SELECT column_name, data_type, is_nullable
FROM information_schema.columns 
WHERE table_name = 'cc_jobs' 
ORDER BY ordinal_position;

-- Verify tenant_id is nullable
SELECT column_name, is_nullable
FROM information_schema.columns 
WHERE table_name = 'cc_jobs' AND column_name = 'tenant_id';
-- Should show 'YES' for is_nullable

-- Verify enums created
SELECT typname FROM pg_type WHERE typname LIKE 'job_%';
```
