✅ REPLIT PROMPT PACK — P2.9 Authority / Adjuster Read-Only Portals (Authoritative)
P2.9.0 — Non-Negotiables

Build a read-only access system that:

Allows insurers / adjusters / regulators / lawyers to view specific sealed materials without creating accounts

Is time-boxed (expiry), revocable, and audit-logged

Is scope-limited (only specific bundles/claims/dossiers/evidence)

Never allows writes, edits, membership changes, or message sends

Can return download links to evidence blobs (R2) via short-lived signed URLs

Uses FORCE RLS + SECURITY DEFINER functions carefully (same pattern as A2.1 public responses) without opening tenant data

No UI redesign: implement minimal public routes + JSON endpoints; optional minimal read-only HTML page is acceptable but not required.

P2.9.1 — Database Migration (New Tables)
1) cc_authority_access_grants

A grant = a scoped share configuration.

Columns:

id uuid pk default gen_random_uuid()

tenant_id uuid not null

circle_id uuid null

portal_id uuid null

grant_type text not null
values: adjuster | insurer | regulator | legal | contractor_third_party | generic

title text not null

description text null

created_at timestamptz not null default now()

created_by_individual_id uuid null

status text not null default 'active' values: active | revoked | expired

revoked_at timestamptz null

revoked_by_individual_id uuid null

revoke_reason text null

expires_at timestamptz not null (hard stop)

max_views int null (optional)

require_passcode boolean not null default false

passcode_hash text null (argon2/bcrypt hash if enabled)

client_request_id text null

metadata jsonb not null default '{}'::jsonb

Indexes:

(tenant_id, created_at desc)

(tenant_id, status)

unique (tenant_id, client_request_id) where not null

2) cc_authority_access_scopes

Join table to define what the grant can access.

Columns:

id uuid pk default gen_random_uuid()

tenant_id uuid not null

grant_id uuid not null references cc_authority_access_grants(id) on delete cascade

scope_type text not null
values: evidence_bundle | claim | claim_dossier | evidence_object

scope_id uuid not null

added_at timestamptz not null default now()

added_by_individual_id uuid null

label text null

notes text null

Indexes:

unique (tenant_id, grant_id, scope_type, scope_id)

(tenant_id, scope_type, scope_id)

3) cc_authority_access_tokens

Tokens that power public read-only access.

Columns:

id uuid pk default gen_random_uuid()

tenant_id uuid not null

grant_id uuid not null references cc_authority_access_grants(id) on delete cascade

token_hash text not null (sha256 of raw token)

issued_at timestamptz not null default now()

issued_by_individual_id uuid null

last_accessed_at timestamptz null

access_count int not null default 0

status text not null default 'active' values: active | revoked | expired

revoked_at timestamptz null

revoked_by_individual_id uuid null

revoke_reason text null

expires_at timestamptz not null (copied from grant at issuance; can be shorter)

client_request_id text null

metadata jsonb not null default '{}'::jsonb

Indexes:

unique (tenant_id, token_hash)

(tenant_id, grant_id)

unique (tenant_id, client_request_id) where not null

4) cc_authority_access_events

Append-only audit log for all authority access.

Columns:

id uuid pk default gen_random_uuid()

tenant_id uuid not null

grant_id uuid not null

token_id uuid null

event_type text not null
values: token_issued |token_revoked |grant_revoked |access_allowed |access_denied |passcode_failed |rate_limited |download_issued

event_at timestamptz not null default now()

ip text null

user_agent text null

path text null

event_payload jsonb not null default '{}'::jsonb

Indexes:

(tenant_id, grant_id, event_at desc)

(tenant_id, token_id, event_at desc)

P2.9.2 — RLS Policies

Enable RLS on all four tables.

Standard tenant scope using app.tenant_id for authenticated routes

Public access must NOT use direct table reads. Public reads only via SECURITY DEFINER functions that:

validate token

return only scoped records

P2.9.3 — Security Model (Token + Optional Passcode)
Token rules

Generate raw token: 32+ bytes random, URL-safe (base64url)

Store only token_hash = sha256(raw_token)

Never store raw token in DB

Token expires at min(grant.expires_at, token.expires_at)

Optional passcode

If require_passcode=true, require caller-provided passcode:

Store passcode_hash on grant

Verify passcode server-side; on failure log passcode_failed

View caps / expiry

If max_views set: deny after access_count >= max_views

Auto-mark token/grant as expired when past expiry (on access)

P2.9.4 — SECURITY DEFINER Functions (Public Read Surface)

Create schema functions with SECURITY DEFINER and set search_path defensively.

Function: cc_authority_validate_token(p_token text, p_passcode text default null)

Returns:

ok boolean

tenant_id uuid

grant_id uuid

token_id uuid

expires_at timestamptz

scopes jsonb (list of {scope_type, scope_id})

Behavior:

Compute sha256(p_token) and find token row

Validate status, expiry, max_views, grant status

If passcode required, verify hash

If ok:

increment access_count, set last_accessed_at

log access_allowed

If deny:

log access_denied / passcode_failed

return ok=false

IMPORTANT:

This function must not leak existence of other tenants’ tokens; only returns boolean.

Function: cc_authority_get_bundle_manifest(p_tenant_id, p_grant_id, p_bundle_id)

Returns only if bundle_id is present in scopes.

Returns bundle manifest_json + manifest_sha256 + metadata fields

Function: cc_authority_get_dossier(p_tenant_id, p_grant_id, p_dossier_id)

Returns dossier_json + dossier_sha256 + claim_id

Function: cc_authority_get_evidence_object_summary(p_tenant_id, p_grant_id, p_evidence_id)

Returns safe subset:

id, source_type, title, occurred_at, created_at, captured_at

content_mime, content_bytes, content_sha256

r2_key (optional but do NOT expose bucket)

url (if present)

chain_status, sealed_at

Function: cc_authority_list_scope_index(p_tenant_id, p_grant_id)

Returns a normalized index for the portal:

all scoped bundles + dossiers + evidence summaries (safe subsets)

include pointers to allow client to fetch details

P2.9.5 — Public Routes (No UI Redesign)

Add public endpoints under /p/authority/* (or your existing public route tree).

1) POST /p/authority/session

Body:

{ token, passcode? }
Returns:

{ ok, session_token } where session_token is a short-lived JWT-like signed cookie token OR return {ok, grant_index} directly.
Preferred: create short-lived signed session token (15 minutes) so raw token isn’t re-sent every request.

Server:

calls cc_authority_validate_token(token, passcode)

if ok: issues authority_session signed token containing:

tenant_id, grant_id, token_id, exp

logs event already handled by definer; also capture IP/UA/path in access_events (app layer)

2) GET /p/authority/index

Auth: authority_session
Returns: scope index from cc_authority_list_scope_index

3) GET /p/authority/bundles/:bundleId/manifest

Auth: authority_session
Returns: manifest + sha

4) GET /p/authority/dossiers/:dossierId

Auth: authority_session
Returns: dossier json + sha

5) GET /p/authority/evidence/:evidenceId

Auth: authority_session
Returns: evidence summary

6) POST /p/authority/evidence/:evidenceId/download

Auth: authority_session
Returns: { url, expires_at } where url is a short-lived signed R2 URL (e.g., 60 seconds).

Log download_issued with evidence_id

Never return raw R2 keys without signing; never expose bucket names.

P2.9.6 — Authenticated Tenant Admin APIs (Grant Management)

These are normal /api/* authenticated routes using existing auth.

1) POST /api/authority/grants

Body:

{ grant_type, title, description?, circle_id?, portal_id?, expires_at, max_views?, require_passcode?, passcode?, client_request_id? }
Server:

create grant

if passcode, hash and store

log token_issued only when token created, not here

2) POST /api/authority/grants/:id/scopes

Body:

{ scope_type, scope_id, label?, notes? }
Rules:

scope objects must exist and belong to tenant (and circle if provided)

recommended: only allow sealed bundles/dossiers by default

bundles must be sealed

dossiers exist (already immutable)

evidence_object should be sealed unless explicitly allowed via metadata override

3) POST /api/authority/grants/:id/tokens

Body: { expires_at?, client_request_id? }
Server:

generate raw token

store sha256 hash

return raw token ONCE as share_url (server constructs full URL string)

log event token_issued

4) POST /api/authority/tokens/:id/revoke

Body: { reason }
Server:

mark token revoked

log token_revoked

5) POST /api/authority/grants/:id/revoke

Body: { reason }
Server:

mark grant revoked, revoke all tokens

log grant_revoked

6) GET /api/authority/grants

List grants + token counts + last_accessed + status.

P2.9.7 — Rate Limiting & Abuse Controls (Must Implement)

Implement simple server-side rate limiting on public endpoints:

per IP + token_hash:

e.g., 30 requests/minute

on exceed:

log rate_limited

return 429 without extra detail

Also:

Do not allow token brute force: constant-time compare for hashes, no leak of “token exists but passcode wrong” beyond generic deny.

P2.9.8 — Integration Constraints (P2.5 / P2.6 / P2.7)

If a bundle/dossier/evidence is on a legal hold, public read access is still allowed (default). Holds are about preventing destruction, not viewing.

However, if you want “hold restricts sharing” as an option:

Add metadata.restrict_sharing=true on hold/target and deny in authority getters.

Default: do not restrict.

Verification:

Authority surfaces must include:

bundle manifest_sha256

dossier dossier_sha256

evidence content_sha256 + (optionally) tip hash if you expose it safely
This is the “defensible pack” feature.

P2.9.9 — Tests (Must Exist)

Token validation

valid token returns ok

expired token returns ok=false and logs access_denied

Passcode enforcement

require_passcode true:

wrong passcode denies + logs passcode_failed

correct passcode allows

Scope enforcement

token scoped to bundle A:

manifest for A allowed

manifest for B denied

Revocation

revoke token → subsequent access denied

revoke grant → all tokens denied

Rate limiting

exceed threshold → 429 and logs rate_limited

Signed download URL issuance

download endpoint returns URL + short expiry

logs download_issued

ensures URL not issued for unscoped evidence

P2.9.10 — Documentation

Create docs/P2_9_AUTHORITY_READ_ONLY_PORTAL.md:

Threat model

Token storage (hash only)

Expiry + revocation semantics

Scope types and what’s exposed

How verification works (sha fields)

Operational guidance: “share to adjuster” playbook

✅ Definition of Done

P2.9 is done only when:

Grants + scopes + tokens exist with RLS

Public session + read endpoints work with SECURITY DEFINER validation

Scope enforcement is airtight

Signed downloads work

Events are logged

Rate limiting exists

Tests pass

Docs exist