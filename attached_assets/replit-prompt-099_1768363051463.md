# PROMPT 24 - BUNDLE 099: Messages RLS & Conversation Participants

## Context
- Latest migration: 098_operators.sql
- This is migration 099
- Part of Prompt 24A foundation work

## Objective
Enable Row-Level Security on messaging tables and create conversation participants for multi-role messaging.

---

## Migration: server/migrations/099_messages_rls_and_participants.sql

```sql
-- ============================================================
-- MIGRATION 099: MESSAGES RLS & CONVERSATION PARTICIPANTS
-- Part of Prompt 24A - Foundation
-- ============================================================

BEGIN;

-- ============================================================
-- 1) CONVERSATION PARTICIPANTS
-- Tracks who can see/participate in a conversation
-- ============================================================

CREATE TABLE IF NOT EXISTS cc_conversation_participants (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  conversation_id uuid NOT NULL REFERENCES cc_conversations(id) ON DELETE CASCADE,
  
  -- Who is participating (EXACTLY ONE should be set - XOR constraint below)
  party_id uuid REFERENCES cc_parties(id) ON DELETE CASCADE,
  individual_id uuid REFERENCES cc_individuals(id) ON DELETE CASCADE,
  
  -- Role context (what role are they acting as in this conversation)
  actor_role text, -- contractor, owner, pic, worker, coordinator, etc.
  
  -- Permissions
  can_send boolean NOT NULL DEFAULT true,
  can_see_history boolean NOT NULL DEFAULT true,
  
  -- Status
  joined_at timestamptz NOT NULL DEFAULT now(),
  left_at timestamptz,
  is_active boolean NOT NULL DEFAULT true,
  
  -- Metadata
  created_at timestamptz NOT NULL DEFAULT now(),
  
  -- EXACTLY one identity must be set (XOR constraint)
  CONSTRAINT participant_exactly_one_identity CHECK (
    (party_id IS NOT NULL AND individual_id IS NULL) OR
    (party_id IS NULL AND individual_id IS NOT NULL)
  )
);

CREATE INDEX idx_cc_conversation_participants_conv ON cc_conversation_participants(conversation_id);
CREATE INDEX idx_cc_conversation_participants_party ON cc_conversation_participants(party_id);
CREATE INDEX idx_cc_conversation_participants_individual ON cc_conversation_participants(individual_id);
CREATE INDEX idx_cc_conversation_participants_active ON cc_conversation_participants(conversation_id, is_active);

-- ============================================================
-- 2) ADD sender_participant_id TO MESSAGES
-- Links message to participant role context
-- ============================================================

ALTER TABLE cc_messages 
ADD COLUMN IF NOT EXISTS sender_participant_id uuid REFERENCES cc_conversation_participants(id);

CREATE INDEX IF NOT EXISTS idx_cc_messages_sender_participant ON cc_messages(sender_participant_id);

-- ============================================================
-- 3) ENABLE RLS ON CONVERSATIONS
-- Uses existing contractor_party_id/owner_party_id columns
-- (More robust than depending on participants being populated)
-- ============================================================

ALTER TABLE cc_conversations ENABLE ROW LEVEL SECURITY;

-- Service bypass policy (for API operations)
CREATE POLICY cc_conversations_service_bypass ON cc_conversations
  FOR ALL
  USING (current_setting('app.tenant_id', true) = '__SERVICE__')
  WITH CHECK (current_setting('app.tenant_id', true) = '__SERVICE__');

-- Tenant-based visibility via existing party columns
CREATE POLICY cc_conversations_tenant_read ON cc_conversations
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM cc_parties p
      WHERE p.id = cc_conversations.contractor_party_id
        AND p.tenant_id::text = current_setting('app.tenant_id', true)
    )
    OR
    EXISTS (
      SELECT 1 FROM cc_parties p
      WHERE p.id = cc_conversations.owner_party_id
        AND p.tenant_id::text = current_setting('app.tenant_id', true)
    )
  );

-- ============================================================
-- 4) ENABLE RLS ON MESSAGES
-- Uses conversation's party columns (via join)
-- ============================================================

ALTER TABLE cc_messages ENABLE ROW LEVEL SECURITY;

-- Service bypass policy
CREATE POLICY cc_messages_service_bypass ON cc_messages
  FOR ALL
  USING (current_setting('app.tenant_id', true) = '__SERVICE__')
  WITH CHECK (current_setting('app.tenant_id', true) = '__SERVICE__');

-- Tenant-based visibility via conversation's party columns
CREATE POLICY cc_messages_tenant_read ON cc_messages
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM cc_conversations c
      JOIN cc_parties p ON p.id = c.contractor_party_id OR p.id = c.owner_party_id
      WHERE c.id = cc_messages.conversation_id
        AND p.tenant_id::text = current_setting('app.tenant_id', true)
    )
  );

-- ============================================================
-- 5) ENABLE RLS ON CONVERSATION PARTICIPANTS
-- ============================================================

ALTER TABLE cc_conversation_participants ENABLE ROW LEVEL SECURITY;

-- Service bypass
CREATE POLICY cc_conversation_participants_service_bypass ON cc_conversation_participants
  FOR ALL
  USING (current_setting('app.tenant_id', true) = '__SERVICE__')
  WITH CHECK (current_setting('app.tenant_id', true) = '__SERVICE__');

-- Tenant read via party
CREATE POLICY cc_conversation_participants_tenant_read ON cc_conversation_participants
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM cc_parties p
      WHERE cc_conversation_participants.party_id = p.id
        AND p.tenant_id::text = current_setting('app.tenant_id', true)
    )
    OR
    EXISTS (
      SELECT 1 FROM cc_individuals i
      JOIN cc_parties p ON i.party_id = p.id
      WHERE cc_conversation_participants.individual_id = i.id
        AND p.tenant_id::text = current_setting('app.tenant_id', true)
    )
  );

COMMIT;
```

---

## Drizzle Schema: Add to shared/schema.ts

```typescript
// ============================================================
// CONVERSATION PARTICIPANTS (Bundle 099)
// ============================================================

export const ccConversationParticipants = pgTable("cc_conversation_participants", {
  id: uuid("id").primaryKey().defaultRandom(),
  conversationId: uuid("conversation_id").notNull().references(() => ccConversations.id, { onDelete: "cascade" }),
  
  // Identity (exactly one should be set - XOR constraint in DB)
  partyId: uuid("party_id").references(() => ccParties.id, { onDelete: "cascade" }),
  individualId: uuid("individual_id").references(() => ccIndividuals.id, { onDelete: "cascade" }),
  
  // Role context
  actorRole: text("actor_role"),
  
  // Permissions
  canSend: boolean("can_send").notNull().default(true),
  canSeeHistory: boolean("can_see_history").notNull().default(true),
  
  // Status
  joinedAt: timestamp("joined_at", { withTimezone: true }).notNull().defaultNow(),
  leftAt: timestamp("left_at", { withTimezone: true }),
  isActive: boolean("is_active").notNull().default(true),
  
  // Metadata
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
}, (table) => ({
  convIdx: index("idx_cc_conversation_participants_conv").on(table.conversationId),
  partyIdx: index("idx_cc_conversation_participants_party").on(table.partyId),
  individualIdx: index("idx_cc_conversation_participants_individual").on(table.individualId),
  activeIdx: index("idx_cc_conversation_participants_active").on(table.conversationId, table.isActive),
}));

export const insertConversationParticipantSchema = createInsertSchema(ccConversationParticipants).omit({
  id: true,
  createdAt: true,
});

export type ConversationParticipant = typeof ccConversationParticipants.$inferSelect;
export type InsertConversationParticipant = z.infer<typeof insertConversationParticipantSchema>;
```

Also add to ccMessages table:
```typescript
// Add this column to existing ccMessages definition
senderParticipantId: uuid("sender_participant_id").references(() => ccConversationParticipants.id),
```

---

## API Middleware Requirement

Ensure every API request sets the tenant context for RLS:

```typescript
// In server/middleware or wherever you set up request context
// This MUST happen before any database queries

// For authenticated requests with tenant context:
await db.execute(sql`SET app.tenant_id = ${tenantId}`);

// For service/admin operations:
await db.execute(sql`SET app.tenant_id = '__SERVICE__'`);
```

---

## Acceptance Criteria

1. [ ] Migration 099 runs without errors
2. [ ] cc_conversation_participants table created with XOR constraint (party OR individual)
3. [ ] cc_messages.sender_participant_id column added
4. [ ] RLS enabled on cc_conversations, cc_messages, cc_conversation_participants
5. [ ] Service bypass policy works (app.tenant_id = '__SERVICE__')
6. [ ] Tenant-scoped reads work via existing party columns (NOT dependent on participants)
7. [ ] Drizzle schema updated and synced
8. [ ] NO user_id column on cc_conversation_participants

---

## Test Queries

```sql
-- Verify RLS is enabled
SELECT tablename, rowsecurity 
FROM pg_tables 
WHERE schemaname = 'public' 
  AND tablename IN ('cc_conversations', 'cc_messages', 'cc_conversation_participants');

-- Verify new table exists
SELECT column_name, data_type 
FROM information_schema.columns 
WHERE table_name = 'cc_conversation_participants' 
ORDER BY ordinal_position;

-- Verify new column on messages
SELECT column_name, data_type 
FROM information_schema.columns 
WHERE table_name = 'cc_messages' 
  AND column_name = 'sender_participant_id';
```
