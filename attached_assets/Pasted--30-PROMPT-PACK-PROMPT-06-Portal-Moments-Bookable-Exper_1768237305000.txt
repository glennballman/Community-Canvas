**30-PROMPT PACK - PROMPT 06: Portal Moments (Bookable Experiences)**

Create the moments system - curated experiences that portals can offer (kayaking, whale watching, meals, etc.)

## Create Moments Tables

### Migration 075_portal_moments.sql
```sql
BEGIN;

-- ============ PORTAL MOMENTS ============
-- Curated experiences/activities offered through a portal

CREATE TABLE IF NOT EXISTS cc_portal_moments (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Context
  portal_id uuid NOT NULL REFERENCES cc_portals(id) ON DELETE CASCADE,
  tenant_id uuid REFERENCES cc_tenants(id) ON DELETE SET NULL,
  
  -- Identity
  slug varchar NOT NULL,
  title varchar NOT NULL,
  subtitle varchar,
  description text,
  
  -- Type
  moment_type varchar NOT NULL CHECK (moment_type IN (
    'activity', 'charter', 'tour', 'meal', 'experience', 
    'rental', 'lesson', 'workshop', 'event', 'package'
  )),
  
  -- Category for filtering
  category varchar,
  tags text[],
  
  -- Media
  image_url text,
  gallery_urls text[],
  video_url text,
  
  -- Scheduling
  duration_minutes integer,
  available_days integer[], -- 0=Sun, 1=Mon, etc.
  available_start_time time,
  available_end_time time,
  advance_booking_days integer DEFAULT 1,
  max_advance_days integer DEFAULT 90,
  
  -- Capacity
  min_participants integer DEFAULT 1,
  max_participants integer,
  min_age integer,
  
  -- Pricing
  price_cents integer,
  price_per varchar DEFAULT 'person' CHECK (price_per IN (
    'person', 'group', 'hour', 'day', 'item'
  )),
  currency varchar DEFAULT 'CAD',
  deposit_percent integer DEFAULT 25,
  
  -- Fulfillment
  reservation_mode varchar DEFAULT 'internal' CHECK (reservation_mode IN (
    'internal', 'external', 'public'
  )),
  
  -- For internal mode (links to V3.3.1)
  facility_id uuid REFERENCES cc_facilities(id) ON DELETE SET NULL,
  offer_id uuid REFERENCES cc_offers(id) ON DELETE SET NULL,
  
  -- For external mode
  provider_name varchar,
  provider_email varchar,
  provider_phone varchar,
  external_booking_url text,
  
  -- Weather sensitivity
  weather_json jsonb DEFAULT '{}'::jsonb,
  -- {sensitivity: 'critical'|'warning'|'none', 
  --  requires: {wind_max_kph: 20, rain_max_percent: 30},
  --  indoor_alternative: true}
  
  -- Needs/constraints
  constraints_json jsonb DEFAULT '{}'::jsonb,
  -- {wheelchair_accessible: false, physical_level: 'moderate',
  --  swimming_required: true, pets_allowed: false}
  
  -- SEO / Schema.org
  schema_type varchar DEFAULT 'Event',
  seo_title varchar,
  seo_description varchar,
  
  -- Status
  is_active boolean DEFAULT true,
  is_featured boolean DEFAULT false,
  display_order integer DEFAULT 0,
  
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  
  UNIQUE (portal_id, slug)
);

CREATE INDEX IF NOT EXISTS idx_moments_portal ON cc_portal_moments(portal_id, is_active);
CREATE INDEX IF NOT EXISTS idx_moments_type ON cc_portal_moments(portal_id, moment_type) WHERE is_active;
CREATE INDEX IF NOT EXISTS idx_moments_featured ON cc_portal_moments(portal_id, is_featured) WHERE is_active AND is_featured;

ALTER TABLE cc_portal_moments ENABLE ROW LEVEL SECURITY;

-- ============ MOMENT AVAILABILITY ============
-- Specific dates/times when a moment is available

CREATE TABLE IF NOT EXISTS cc_moment_availability (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  moment_id uuid NOT NULL REFERENCES cc_portal_moments(id) ON DELETE CASCADE,
  
  -- When
  available_date date NOT NULL,
  start_time time NOT NULL,
  end_time time,
  
  -- Capacity
  spots_total integer NOT NULL,
  spots_remaining integer NOT NULL,
  
  -- Pricing override
  price_cents_override integer,
  
  -- Status
  status varchar DEFAULT 'available' CHECK (status IN (
    'available', 'limited', 'full', 'cancelled', 'weather_hold'
  )),
  
  -- Notes
  notes text,
  weather_notes text,
  
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_moment_avail_date ON cc_moment_availability(moment_id, available_date);
CREATE INDEX IF NOT EXISTS idx_moment_avail_status ON cc_moment_availability(moment_id, status, available_date) 
  WHERE status IN ('available', 'limited');

ALTER TABLE cc_moment_availability ENABLE ROW LEVEL SECURITY;

-- ============ SEED BAMFIELD MOMENTS ============

-- First get/create Bamfield portal
DO $$
DECLARE
  v_portal_id uuid;
BEGIN
  SELECT id INTO v_portal_id FROM cc_portals WHERE slug = 'bamfield' LIMIT 1;
  
  IF v_portal_id IS NULL THEN
    INSERT INTO cc_portals (slug, name, is_active)
    VALUES ('bamfield', 'Bamfield Community Portal', true)
    RETURNING id INTO v_portal_id;
  END IF;
  
  -- Kayaking Experience
  INSERT INTO cc_portal_moments (
    portal_id, slug, title, subtitle, description, moment_type, category, tags,
    duration_minutes, min_participants, max_participants, min_age,
    price_cents, price_per, reservation_mode,
    provider_name, weather_json, constraints_json, is_featured
  ) VALUES (
    v_portal_id, 'kayak-tour', 'Barkley Sound Kayak Tour', 
    'Explore the pristine waters of Barkley Sound',
    'Paddle through calm waters, spot wildlife, and experience the rugged beauty of Vancouver Island''s west coast. Suitable for beginners with basic instruction included.',
    'activity', 'Water Sports', ARRAY['kayaking', 'wildlife', 'beginner-friendly', 'scenic'],
    180, 2, 8, 12,
    12500, 'person', 'external',
    'Bamfield Kayak Adventures',
    '{"sensitivity": "critical", "requires": {"wind_max_kph": 25, "rain_max_percent": 40}}',
    '{"physical_level": "moderate", "swimming_required": true, "wheelchair_accessible": false}',
    true
  ) ON CONFLICT (portal_id, slug) DO UPDATE SET updated_at = now();
  
  -- Whale Watching
  INSERT INTO cc_portal_moments (
    portal_id, slug, title, subtitle, description, moment_type, category, tags,
    duration_minutes, min_participants, max_participants,
    price_cents, price_per, reservation_mode,
    provider_name, weather_json, is_featured
  ) VALUES (
    v_portal_id, 'whale-watching', 'Pacific Rim Whale Watching',
    'See gray whales, orcas, and marine life',
    'Join our experienced guides on a zodiac tour through the Pacific Rim waters. Peak season March-October for gray whales, year-round for orcas.',
    'charter', 'Wildlife', ARRAY['whales', 'wildlife', 'ocean', 'photography'],
    240, 4, 12,
    18500, 'person', 'external',
    'West Coast Whale Watch',
    '{"sensitivity": "warning", "requires": {"wind_max_kph": 30}}',
    true
  ) ON CONFLICT (portal_id, slug) DO UPDATE SET updated_at = now();
  
  -- Hiking Trail
  INSERT INTO cc_portal_moments (
    portal_id, slug, title, subtitle, description, moment_type, category, tags,
    duration_minutes, min_participants, max_participants,
    price_cents, price_per, reservation_mode,
    weather_json, constraints_json
  ) VALUES (
    v_portal_id, 'west-coast-trail-day', 'West Coast Trail Day Hike',
    'Experience a section of the famous trail',
    'Guided day hike on a scenic section of the West Coast Trail. Learn about local flora, fauna, and First Nations history.',
    'tour', 'Hiking', ARRAY['hiking', 'nature', 'guided', 'forest'],
    360, 2, 10,
    9500, 'person', 'external',
    '{"sensitivity": "warning", "requires": {"rain_max_percent": 60}}',
    '{"physical_level": "challenging", "hiking_boots_required": true}'
  ) ON CONFLICT (portal_id, slug) DO UPDATE SET updated_at = now();
  
  -- Seafood Dinner
  INSERT INTO cc_portal_moments (
    portal_id, slug, title, subtitle, description, moment_type, category, tags,
    duration_minutes, min_participants, max_participants,
    price_cents, price_per, reservation_mode,
    provider_name, constraints_json
  ) VALUES (
    v_portal_id, 'seafood-feast', 'Bamfield Seafood Feast',
    'Fresh-caught local seafood experience',
    'Enjoy the freshest seafood prepared by local chefs. Features salmon, halibut, prawns, and oysters. Dietary accommodations available.',
    'meal', 'Dining', ARRAY['seafood', 'local', 'dinner', 'fresh'],
    120, 2, 20,
    7500, 'person', 'external',
    'Bamfield Lodge Restaurant',
    '{"dietary_accommodations": true}'
  ) ON CONFLICT (portal_id, slug) DO UPDATE SET updated_at = now();
  
  -- Storm Watching (seasonal)
  INSERT INTO cc_portal_moments (
    portal_id, slug, title, subtitle, description, moment_type, category, tags,
    duration_minutes, min_participants, max_participants,
    price_cents, price_per, reservation_mode,
    weather_json
  ) VALUES (
    v_portal_id, 'storm-watching', 'Pacific Storm Watching Experience',
    'Witness the raw power of winter storms',
    'From the safety of our oceanfront viewing area, watch massive Pacific storms crash against the coast. Hot drinks and snacks provided. Available November-February.',
    'experience', 'Nature', ARRAY['storm', 'winter', 'nature', 'photography'],
    180, 1, 20,
    4500, 'person', 'public',
    '{"sensitivity": "none", "best_conditions": {"storm_required": true}}'
  ) ON CONFLICT (portal_id, slug) DO UPDATE SET updated_at = now();
  
END $$;

COMMIT;
```

## Create server/services/momentService.ts
```typescript
// server/services/momentService.ts

import { db } from '../db';
import { eq, and, gte, lte, desc, asc, sql, or, ilike } from 'drizzle-orm';
import { getWeatherContext } from './recommendationService';

// ============ TYPES ============

interface MomentSearchRequest {
  portalSlug?: string;
  portalId?: string;
  momentType?: string;
  category?: string;
  tags?: string[];
  targetDate?: Date;
  partySize?: number;
  includeWeatherFit?: boolean;
  featuredOnly?: boolean;
  limit?: number;
  offset?: number;
}

interface MomentResult {
  moment: any;
  weatherFit?: 'excellent' | 'good' | 'fair' | 'poor';
  weatherWarnings?: string[];
  availability?: {
    date: Date;
    spotsRemaining: number;
    status: string;
  }[];
}

// ============ FUNCTIONS ============

export async function getMoments(req: MomentSearchRequest): Promise<{
  moments: MomentResult[];
  total: number;
  weatherContext?: any;
}> {
  let portalId = req.portalId;
  
  // Resolve portal from slug
  if (req.portalSlug && !portalId) {
    const portal = await db.query.ccPortals.findFirst({
      where: eq(ccPortals.slug, req.portalSlug)
    });
    if (portal) portalId = portal.id;
  }
  
  if (!portalId) {
    return { moments: [], total: 0 };
  }
  
  // Build where conditions
  const conditions = [
    eq(ccPortalMoments.portalId, portalId),
    eq(ccPortalMoments.isActive, true)
  ];
  
  if (req.momentType) {
    conditions.push(eq(ccPortalMoments.momentType, req.momentType));
  }
  
  if (req.category) {
    conditions.push(eq(ccPortalMoments.category, req.category));
  }
  
  if (req.featuredOnly) {
    conditions.push(eq(ccPortalMoments.isFeatured, true));
  }
  
  // Query moments
  const moments = await db.query.ccPortalMoments.findMany({
    where: and(...conditions),
    orderBy: [desc(ccPortalMoments.isFeatured), asc(ccPortalMoments.displayOrder)],
    limit: req.limit || 20,
    offset: req.offset || 0
  });
  
  // Get weather context if date provided
  let weatherContext = null;
  if (req.targetDate && req.includeWeatherFit) {
    weatherContext = await getWeatherContext('BAMFIELD', req.targetDate);
  }
  
  // Process results with weather fit
  const results: MomentResult[] = moments.map(moment => {
    const result: MomentResult = { moment };
    
    // Calculate weather fit if we have context
    if (weatherContext && moment.weatherJson) {
      const weather = moment.weatherJson as any;
      const warnings: string[] = [];
      let fit: 'excellent' | 'good' | 'fair' | 'poor' = 'good';
      
      if (weather.sensitivity === 'critical') {
        // Check weather requirements
        if (weather.requires?.wind_max_kph && weatherContext.windAvgKph > weather.requires.wind_max_kph) {
          fit = 'poor';
          warnings.push(`Wind typically ${weatherContext.windAvgKph} kph (max ${weather.requires.wind_max_kph} kph)`);
        }
        if (weather.requires?.rain_max_percent && weatherContext.rainProbPercent > weather.requires.rain_max_percent) {
          fit = fit === 'poor' ? 'poor' : 'fair';
          warnings.push(`${weatherContext.rainProbPercent}% chance of rain`);
        }
      } else if (weather.sensitivity === 'warning') {
        if (weatherContext.rainProbPercent > 50) {
          fit = 'fair';
          warnings.push('Rain likely - have backup plan');
        }
      }
      
      // Check if this is "best for" this time
      if (weatherContext.bestFor?.some((b: string) => 
        moment.tags?.some(t => t.toLowerCase().includes(b.toLowerCase()))
      )) {
        fit = 'excellent';
      }
      
      result.weatherFit = fit;
      result.weatherWarnings = warnings;
    }
    
    // Filter by party size
    if (req.partySize) {
      if (moment.maxParticipants && req.partySize > moment.maxParticipants) {
        result.weatherWarnings = result.weatherWarnings || [];
        result.weatherWarnings.push(`Max ${moment.maxParticipants} participants`);
      }
      if (moment.minParticipants && req.partySize < moment.minParticipants) {
        result.weatherWarnings = result.weatherWarnings || [];
        result.weatherWarnings.push(`Min ${moment.minParticipants} participants required`);
      }
    }
    
    return result;
  });
  
  // Get total count
  const countResult = await db.select({ count: sql<number>`count(*)` })
    .from(ccPortalMoments)
    .where(and(...conditions));
  
  return {
    moments: results,
    total: Number(countResult[0]?.count || 0),
    weatherContext
  };
}

export async function getMomentBySlug(
  portalSlug: string, 
  momentSlug: string
): Promise<MomentResult | null> {
  const portal = await db.query.ccPortals.findFirst({
    where: eq(ccPortals.slug, portalSlug)
  });
  
  if (!portal) return null;
  
  const moment = await db.query.ccPortalMoments.findFirst({
    where: and(
      eq(ccPortalMoments.portalId, portal.id),
      eq(ccPortalMoments.slug, momentSlug),
      eq(ccPortalMoments.isActive, true)
    )
  });
  
  if (!moment) return null;
  
  return { moment };
}

export async function getMomentAvailability(
  momentId: string,
  startDate: Date,
  endDate: Date
): Promise<any[]> {
  return db.query.ccMomentAvailability.findMany({
    where: and(
      eq(ccMomentAvailability.momentId, momentId),
      gte(ccMomentAvailability.availableDate, startDate),
      lte(ccMomentAvailability.availableDate, endDate),
      or(
        eq(ccMomentAvailability.status, 'available'),
        eq(ccMomentAvailability.status, 'limited')
      )
    ),
    orderBy: [asc(ccMomentAvailability.availableDate), asc(ccMomentAvailability.startTime)]
  });
}

export async function getCategories(portalSlug: string): Promise<string[]> {
  const portal = await db.query.ccPortals.findFirst({
    where: eq(ccPortals.slug, portalSlug)
  });
  
  if (!portal) return [];
  
  const result = await db.selectDistinct({ category: ccPortalMoments.category })
    .from(ccPortalMoments)
    .where(and(
      eq(ccPortalMoments.portalId, portal.id),
      eq(ccPortalMoments.isActive, true),
      sql`${ccPortalMoments.category} IS NOT NULL`
    ));
  
  return result.map(r => r.category).filter(Boolean) as string[];
}

// Add moment to cart
export async function addMomentToCart(
  cartId: string,
  momentId: string,
  options: {
    startAt: Date;
    endAt?: Date;
    partySize?: number;
    specialRequests?: string;
  }
): Promise<any> {
  const moment = await db.query.ccPortalMoments.findFirst({
    where: eq(ccPortalMoments.id, momentId)
  });
  
  if (!moment) {
    throw new Error('Moment not found');
  }
  
  // Calculate end time if not provided
  const endAt = options.endAt || new Date(options.startAt.getTime() + (moment.durationMinutes || 60) * 60 * 1000);
  
  // Calculate price
  const priceCents = moment.priceCents || 0;
  const partySize = options.partySize || 1;
  const subtotalCents = moment.pricePer === 'person' ? priceCents * partySize : priceCents;
  const taxesCents = Math.round(subtotalCents * 0.12); // 12% tax
  const totalCents = subtotalCents + taxesCents;
  
  // Import addItem from cartService
  const { addItem } = await import('./cartService');
  
  return addItem({
    cartId,
    itemType: moment.momentType === 'meal' ? 'meal' : 
              moment.momentType === 'rental' ? 'rental' :
              moment.momentType === 'charter' ? 'charter' : 'activity',
    title: moment.title,
    description: moment.subtitle,
    reservationMode: moment.reservationMode as any,
    facilityId: moment.facilityId || undefined,
    offerId: moment.offerId || undefined,
    providerTenantId: moment.tenantId || undefined,
    providerName: moment.providerName || undefined,
    providerEmail: moment.providerEmail || undefined,
    providerPhone: moment.providerPhone || undefined,
    externalUrl: moment.externalBookingUrl || undefined,
    startAt: options.startAt,
    endAt,
    partySize,
    specialRequests: options.specialRequests,
    needsJson: moment.constraintsJson || {}
  });
}
```

## Add Moment Routes

### In server/routes/public-portal.ts
```typescript
import { 
  getMoments, getMomentBySlug, getMomentAvailability, 
  getCategories, addMomentToCart 
} from '../services/momentService';

// ============ MOMENT ENDPOINTS ============

// GET /api/public/portals/:slug/moments - List moments
router.get('/portals/:slug/moments', async (req, res) => {
  const { slug } = req.params;
  const { type, category, date, partySize, featured, limit, offset } = req.query;
  
  try {
    const result = await getMoments({
      portalSlug: slug,
      momentType: type as string,
      category: category as string,
      targetDate: date ? new Date(date as string) : undefined,
      partySize: partySize ? parseInt(partySize as string) : undefined,
      includeWeatherFit: !!date,
      featuredOnly: featured === 'true',
      limit: limit ? parseInt(limit as string) : 20,
      offset: offset ? parseInt(offset as string) : 0
    });
    
    res.json(result);
  } catch (e: any) {
    console.error('Get moments error:', e);
    res.status(500).json({ error: 'Failed to get moments' });
  }
});

// GET /api/public/portals/:slug/moments/categories - List categories
router.get('/portals/:slug/moments/categories', async (req, res) => {
  const { slug } = req.params;
  
  try {
    const categories = await getCategories(slug);
    res.json({ categories });
  } catch (e: any) {
    console.error('Get categories error:', e);
    res.status(500).json({ error: 'Failed to get categories' });
  }
});

// GET /api/public/portals/:slug/moments/:momentSlug - Get single moment
router.get('/portals/:slug/moments/:momentSlug', async (req, res) => {
  const { slug, momentSlug } = req.params;
  
  try {
    const result = await getMomentBySlug(slug, momentSlug);
    if (!result) {
      return res.status(404).json({ error: 'Moment not found' });
    }
    res.json(result);
  } catch (e: any) {
    console.error('Get moment error:', e);
    res.status(500).json({ error: 'Failed to get moment' });
  }
});

// GET /api/public/portals/:slug/moments/:momentSlug/availability - Get availability
router.get('/portals/:slug/moments/:momentSlug/availability', async (req, res) => {
  const { slug, momentSlug } = req.params;
  const { start, end } = req.query;
  
  try {
    const momentResult = await getMomentBySlug(slug, momentSlug);
    if (!momentResult) {
      return res.status(404).json({ error: 'Moment not found' });
    }
    
    const startDate = start ? new Date(start as string) : new Date();
    const endDate = end ? new Date(end as string) : new Date(startDate.getTime() + 30 * 24 * 60 * 60 * 1000);
    
    const availability = await getMomentAvailability(momentResult.moment.id, startDate, endDate);
    
    res.json({ moment: momentResult.moment, availability });
  } catch (e: any) {
    console.error('Get availability error:', e);
    res.status(500).json({ error: 'Failed to get availability' });
  }
});

// POST /api/public/carts/:cartId/moments - Add moment to cart
router.post('/carts/:cartId/moments', async (req, res) => {
  const { cartId } = req.params;
  const token = req.headers['x-cart-token'] as string;
  const b = req.body || {};
  
  if (!token) {
    return res.status(401).json({ error: 'Cart token required' });
  }
  
  if (!b.momentId || !b.startAt) {
    return res.status(400).json({ error: 'momentId and startAt required' });
  }
  
  try {
    // Verify cart access first
    const { getCart } = await import('../services/cartService');
    const cart = await getCart(cartId, token);
    if (!cart) {
      return res.status(404).json({ error: 'Cart not found or invalid token' });
    }
    
    const result = await addMomentToCart(cartId, b.momentId, {
      startAt: new Date(b.startAt),
      endAt: b.endAt ? new Date(b.endAt) : undefined,
      partySize: b.partySize,
      specialRequests: b.specialRequests
    });
    
    res.json(result);
  } catch (e: any) {
    console.error('Add moment to cart error:', e);
    res.status(400).json({ error: e.message });
  }
});
```

## Drizzle Schema Exports

Add to shared/schema.ts:
- PortalMoment, InsertPortalMoment
- MomentAvailability, InsertMomentAvailability

## Deliverables
- [ ] Migration 075_portal_moments.sql
- [ ] cc_portal_moments table with RLS
- [ ] cc_moment_availability table with RLS
- [ ] 5 Bamfield moments seeded (kayak, whale watching, hiking, seafood, storm watching)
- [ ] server/services/momentService.ts
- [ ] Moment routes:
  - GET /api/public/portals/:slug/moments
  - GET /api/public/portals/:slug/moments/categories
  - GET /api/public/portals/:slug/moments/:momentSlug
  - GET /api/public/portals/:slug/moments/:momentSlug/availability
  - POST /api/public/carts/:cartId/moments
- [ ] Test: GET /api/public/portals/bamfield/moments returns 5 seeded moments
- [ ] Test: POST /carts/:id/moments adds moment to cart with calculated pricing

Report with moment list and add-to-cart test result.