PROMPT 4S: Navigation + My Bookings Page
Part 1: Add Rentals to Sidebar Navigation
Update your sidebar navigation (likely in AdminLayout.tsx or similar) to add a new RENTALS section:
tsx// Add to your sidebar navigation structure

// New section - add near the top, after NAVIGATION
{
  title: 'RENTALS',
  items: [
    { name: 'Rent Equipment', path: '/rentals', icon: 'üö£' },
    { name: 'My Bookings', path: '/rentals/bookings', icon: 'üìã' },
  ]
}
Or if your sidebar uses a different pattern, add these two links:

/rentals ‚Üí "Rent Equipment" üö£
/rentals/bookings ‚Üí "My Bookings" üìã


Part 2: API Endpoints for Bookings
typescript// server/routes/rentals.ts (add these endpoints)

// GET /api/rentals/bookings - Get current user's bookings
router.get('/bookings', authenticateToken, async (req, res) => {
  try {
    const userEmail = (req as any).user?.email;
    
    // Get individual ID
    const indResult = await pool.query(
      'SELECT id FROM cc_individuals WHERE email = $1',
      [userEmail]
    );
    
    if (indResult.rows.length === 0) {
      return res.json({ success: true, bookings: [] });
    }
    
    const individualId = indResult.rows[0].id;
    
    const result = await pool.query(`
      SELECT 
        b.id,
        b.status,
        b.starts_at,
        b.ends_at,
        b.actual_checkout_at,
        b.actual_checkin_at,
        b.pricing_model,
        b.rate_applied,
        b.duration_hours,
        b.subtotal,
        b.tax,
        b.damage_deposit_held,
        b.total,
        b.payment_status,
        b.condition_at_checkout,
        b.condition_at_return,
        b.damage_reported,
        b.damage_notes,
        b.notes,
        b.created_at,
        
        -- Rental item details
        ri.id as item_id,
        ri.name as item_name,
        ri.slug as item_slug,
        ri.description as item_description,
        ri.location_name,
        ri.owner_name,
        ri.photos as item_photos,
        
        -- Category
        rc.name as category_name,
        rc.slug as category_slug,
        rc.icon as category_icon,
        
        -- Community
        c.name as community_name
        
      FROM cc_rental_bookings b
      JOIN cc_rental_items ri ON ri.id = b.rental_item_id
      JOIN cc_rental_categories rc ON rc.id = ri.category_id
      LEFT JOIN sr_communities c ON c.id = ri.home_community_id
      WHERE b.renter_individual_id = $1
      ORDER BY 
        CASE b.status 
          WHEN 'active' THEN 1
          WHEN 'checked_out' THEN 2
          WHEN 'confirmed' THEN 3
          WHEN 'pending' THEN 4
          ELSE 5
        END,
        b.starts_at DESC
    `, [individualId]);
    
    res.json({ 
      success: true, 
      bookings: result.rows.map(row => ({
        id: row.id,
        status: row.status,
        startsAt: row.starts_at,
        endsAt: row.ends_at,
        actualCheckoutAt: row.actual_checkout_at,
        actualCheckinAt: row.actual_checkin_at,
        pricingModel: row.pricing_model,
        rateApplied: row.rate_applied,
        durationHours: row.duration_hours,
        subtotal: row.subtotal,
        tax: row.tax,
        damageDepositHeld: row.damage_deposit_held,
        total: row.total,
        paymentStatus: row.payment_status,
        conditionAtCheckout: row.condition_at_checkout,
        conditionAtReturn: row.condition_at_return,
        damageReported: row.damage_reported,
        damageNotes: row.damage_notes,
        notes: row.notes,
        createdAt: row.created_at,
        item: {
          id: row.item_id,
          name: row.item_name,
          slug: row.item_slug,
          description: row.item_description,
          locationName: row.location_name,
          ownerName: row.owner_name,
          photos: row.item_photos,
          category: row.category_name,
          categorySlug: row.category_slug,
          categoryIcon: row.category_icon,
          communityName: row.community_name
        }
      }))
    });
  } catch (error) {
    console.error('Error fetching bookings:', error);
    res.status(500).json({ success: false, error: 'Failed to fetch bookings' });
  }
});

// POST /api/rentals/bookings/:id/cancel - Cancel a booking
router.post('/bookings/:id/cancel', authenticateToken, async (req, res) => {
  try {
    const userEmail = (req as any).user?.email;
    const bookingId = req.params.id;
    
    // Get individual ID
    const indResult = await pool.query(
      'SELECT id FROM cc_individuals WHERE email = $1',
      [userEmail]
    );
    
    if (indResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'User not found' });
    }
    
    const individualId = indResult.rows[0].id;
    
    // Verify ownership and status
    const bookingResult = await pool.query(`
      SELECT id, status, starts_at 
      FROM cc_rental_bookings 
      WHERE id = $1 AND renter_individual_id = $2
    `, [bookingId, individualId]);
    
    if (bookingResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Booking not found' });
    }
    
    const booking = bookingResult.rows[0];
    
    // Can only cancel pending or confirmed bookings
    if (!['pending', 'confirmed'].includes(booking.status)) {
      return res.status(400).json({ 
        success: false, 
        error: `Cannot cancel booking with status: ${booking.status}` 
      });
    }
    
    // Update status
    await pool.query(`
      UPDATE cc_rental_bookings 
      SET status = 'cancelled', updated_at = NOW()
      WHERE id = $1
    `, [bookingId]);
    
    res.json({ success: true, message: 'Booking cancelled' });
  } catch (error) {
    console.error('Error cancelling booking:', error);
    res.status(500).json({ success: false, error: 'Failed to cancel booking' });
  }
});

// GET /api/rentals/bookings/:id - Get single booking details
router.get('/bookings/:id', authenticateToken, async (req, res) => {
  try {
    const userEmail = (req as any).user?.email;
    const bookingId = req.params.id;
    
    const indResult = await pool.query(
      'SELECT id FROM cc_individuals WHERE email = $1',
      [userEmail]
    );
    
    if (indResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'User not found' });
    }
    
    const individualId = indResult.rows[0].id;
    
    const result = await pool.query(`
      SELECT 
        b.*,
        ri.name as item_name,
        ri.description as item_description,
        ri.location_name,
        ri.owner_name,
        ri.included_items,
        rc.name as category_name,
        rc.icon as category_icon,
        c.name as community_name
      FROM cc_rental_bookings b
      JOIN cc_rental_items ri ON ri.id = b.rental_item_id
      JOIN cc_rental_categories rc ON rc.id = ri.category_id
      LEFT JOIN sr_communities c ON c.id = ri.home_community_id
      WHERE b.id = $1 AND b.renter_individual_id = $2
    `, [bookingId, individualId]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Booking not found' });
    }
    
    res.json({ success: true, booking: result.rows[0] });
  } catch (error) {
    console.error('Error fetching booking:', error);
    res.status(500).json({ success: false, error: 'Failed to fetch booking' });
  }
});

Part 3: My Bookings Page
tsx// client/src/pages/rentals/MyBookings.tsx

import React, { useState, useEffect } from 'react';
import { useAuth } from '../../contexts/AuthContext';
import { Link } from 'react-router-dom';

interface BookingItem {
  id: string;
  name: string;
  slug: string;
  description: string;
  locationName: string;
  ownerName: string;
  photos: string[];
  category: string;
  categorySlug: string;
  categoryIcon: string;
  communityName: string;
}

interface Booking {
  id: string;
  status: 'pending' | 'confirmed' | 'checked_out' | 'active' | 'returned' | 'completed' | 'cancelled' | 'no_show' | 'overdue';
  startsAt: string;
  endsAt: string;
  actualCheckoutAt: string | null;
  actualCheckinAt: string | null;
  pricingModel: string;
  rateApplied: number;
  durationHours: number;
  subtotal: number;
  tax: number;
  damageDepositHeld: number;
  total: number;
  paymentStatus: string;
  conditionAtCheckout: string;
  conditionAtReturn: string;
  damageReported: boolean;
  damageNotes: string;
  notes: string;
  createdAt: string;
  item: BookingItem;
}

export default function MyBookings() {
  const { token } = useAuth();
  const [bookings, setBookings] = useState<Booking[]>([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState<'all' | 'active' | 'upcoming' | 'past'>('all');
  const [cancellingId, setCancellingId] = useState<string | null>(null);

  useEffect(() => {
    loadBookings();
  }, []);

  async function loadBookings() {
    setLoading(true);
    try {
      const res = await fetch('/api/rentals/bookings', {
        headers: { 'Authorization': `Bearer ${token}` }
      });
      const data = await res.json();
      if (data.success) {
        setBookings(data.bookings || []);
      }
    } catch (err) {
      console.error('Failed to load bookings:', err);
    } finally {
      setLoading(false);
    }
  }

  async function cancelBooking(bookingId: string) {
    if (!confirm('Are you sure you want to cancel this booking?')) return;
    
    setCancellingId(bookingId);
    try {
      const res = await fetch(`/api/rentals/bookings/${bookingId}/cancel`, {
        method: 'POST',
        headers: { 'Authorization': `Bearer ${token}` }
      });
      const data = await res.json();
      
      if (data.success) {
        loadBookings();
      } else {
        alert(data.error || 'Failed to cancel booking');
      }
    } catch (err) {
      console.error('Failed to cancel:', err);
      alert('Failed to cancel booking');
    } finally {
      setCancellingId(null);
    }
  }

  const now = new Date();
  
  const filteredBookings = bookings.filter(b => {
    const start = new Date(b.startsAt);
    const end = new Date(b.endsAt);
    
    switch (filter) {
      case 'active':
        return ['active', 'checked_out'].includes(b.status);
      case 'upcoming':
        return ['pending', 'confirmed'].includes(b.status) && start > now;
      case 'past':
        return ['completed', 'returned', 'cancelled', 'no_show'].includes(b.status);
      default:
        return true;
    }
  });

  const getStatusBadge = (status: Booking['status']) => {
    const styles: Record<string, string> = {
      pending: 'bg-yellow-600/20 text-yellow-400',
      confirmed: 'bg-blue-600/20 text-blue-400',
      checked_out: 'bg-purple-600/20 text-purple-400',
      active: 'bg-green-600/20 text-green-400',
      returned: 'bg-teal-600/20 text-teal-400',
      completed: 'bg-gray-600/20 text-gray-400',
      cancelled: 'bg-red-600/20 text-red-400',
      no_show: 'bg-red-600/20 text-red-400',
      overdue: 'bg-orange-600/20 text-orange-400'
    };
    
    const labels: Record<string, string> = {
      pending: '‚è≥ Pending',
      confirmed: '‚úì Confirmed',
      checked_out: 'üîë Checked Out',
      active: 'üü¢ Active',
      returned: '‚Ü©Ô∏è Returned',
      completed: '‚úì Completed',
      cancelled: '‚úï Cancelled',
      no_show: '‚úï No Show',
      overdue: '‚ö†Ô∏è Overdue'
    };
    
    return (
      <span className={`text-xs px-2 py-1 rounded ${styles[status] || 'bg-gray-600/20 text-gray-400'}`}>
        {labels[status] || status}
      </span>
    );
  };

  const formatDateTime = (dateStr: string) => {
    const date = new Date(dateStr);
    return date.toLocaleString('en-US', {
      weekday: 'short',
      month: 'short',
      day: 'numeric',
      hour: 'numeric',
      minute: '2-digit'
    });
  };

  const formatDuration = (hours: number) => {
    if (hours < 24) return `${hours} hour${hours !== 1 ? 's' : ''}`;
    const days = Math.floor(hours / 24);
    const remainingHours = hours % 24;
    if (remainingHours === 0) return `${days} day${days !== 1 ? 's' : ''}`;
    return `${days}d ${remainingHours}h`;
  };

  const activeCount = bookings.filter(b => ['active', 'checked_out'].includes(b.status)).length;
  const upcomingCount = bookings.filter(b => ['pending', 'confirmed'].includes(b.status)).length;

  return (
    <div className="p-6">
      {/* Header */}
      <div className="flex items-center justify-between mb-6">
        <div>
          <h1 className="text-2xl font-bold text-white">My Bookings</h1>
          <p className="text-gray-400">Manage your equipment rentals</p>
        </div>
        <Link
          to="/rentals"
          className="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg"
        >
          + Rent Equipment
        </Link>
      </div>

      {/* Stats */}
      <div className="grid grid-cols-4 gap-4 mb-6">
        <div className="bg-gray-800 rounded-lg p-4">
          <div className="text-2xl font-bold text-white">{bookings.length}</div>
          <div className="text-sm text-gray-400">Total Bookings</div>
        </div>
        <div className="bg-gray-800 rounded-lg p-4">
          <div className="text-2xl font-bold text-green-400">{activeCount}</div>
          <div className="text-sm text-gray-400">Active Now</div>
        </div>
        <div className="bg-gray-800 rounded-lg p-4">
          <div className="text-2xl font-bold text-blue-400">{upcomingCount}</div>
          <div className="text-sm text-gray-400">Upcoming</div>
        </div>
        <div className="bg-gray-800 rounded-lg p-4">
          <div className="text-2xl font-bold text-white">
            ${bookings.reduce((sum, b) => sum + (b.total || 0), 0).toFixed(0)}
          </div>
          <div className="text-sm text-gray-400">Total Spent</div>
        </div>
      </div>

      {/* Filter Tabs */}
      <div className="flex gap-2 mb-6">
        {[
          { key: 'all', label: 'All' },
          { key: 'active', label: `Active (${activeCount})` },
          { key: 'upcoming', label: `Upcoming (${upcomingCount})` },
          { key: 'past', label: 'Past' }
        ].map(tab => (
          <button
            key={tab.key}
            onClick={() => setFilter(tab.key as any)}
            className={`px-4 py-2 rounded-lg ${
              filter === tab.key
                ? 'bg-blue-600 text-white'
                : 'bg-gray-800 text-gray-400 hover:bg-gray-700'
            }`}
          >
            {tab.label}
          </button>
        ))}
      </div>

      {/* Bookings List */}
      {loading ? (
        <div className="text-center text-gray-400 py-12">Loading bookings...</div>
      ) : filteredBookings.length === 0 ? (
        <div className="text-center py-12">
          <div className="text-6xl mb-4">üìã</div>
          <div className="text-gray-400 mb-4">
            {filter === 'all' 
              ? "You don't have any bookings yet"
              : `No ${filter} bookings`}
          </div>
          <Link
            to="/rentals"
            className="inline-block px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg"
          >
            Browse Equipment
          </Link>
        </div>
      ) : (
        <div className="space-y-4">
          {filteredBookings.map(booking => (
            <div
              key={booking.id}
              className={`bg-gray-800 rounded-lg overflow-hidden ${
                ['active', 'checked_out'].includes(booking.status) 
                  ? 'ring-2 ring-green-500/50' 
                  : ''
              }`}
            >
              <div className="p-4">
                <div className="flex items-start gap-4">
                  {/* Icon/Image */}
                  <div className="w-16 h-16 bg-gray-700 rounded-lg flex items-center justify-center text-3xl flex-shrink-0">
                    {booking.item.categoryIcon}
                  </div>
                  
                  {/* Details */}
                  <div className="flex-1 min-w-0">
                    <div className="flex items-start justify-between gap-4">
                      <div>
                        <div className="flex items-center gap-2 mb-1">
                          <h3 className="text-white font-medium truncate">
                            {booking.item.name}
                          </h3>
                          {getStatusBadge(booking.status)}
                        </div>
                        <p className="text-sm text-gray-400">
                          {booking.item.category} ‚Ä¢ {booking.item.locationName}
                        </p>
                      </div>
                      
                      <div className="text-right flex-shrink-0">
                        <div className="text-white font-semibold">${booking.total}</div>
                        <div className="text-xs text-gray-500">
                          {formatDuration(booking.durationHours)}
                        </div>
                      </div>
                    </div>
                    
                    {/* Time */}
                    <div className="mt-3 flex items-center gap-4 text-sm">
                      <div className="text-gray-400">
                        <span className="text-gray-600">Start:</span>{' '}
                        <span className="text-white">{formatDateTime(booking.startsAt)}</span>
                      </div>
                      <div className="text-gray-600">‚Üí</div>
                      <div className="text-gray-400">
                        <span className="text-gray-600">End:</span>{' '}
                        <span className="text-white">{formatDateTime(booking.endsAt)}</span>
                      </div>
                    </div>
                    
                    {/* Actions */}
                    <div className="mt-3 flex items-center gap-3">
                      {['pending', 'confirmed'].includes(booking.status) && (
                        <button
                          onClick={() => cancelBooking(booking.id)}
                          disabled={cancellingId === booking.id}
                          className="text-sm text-red-400 hover:text-red-300"
                        >
                          {cancellingId === booking.id ? 'Cancelling...' : 'Cancel Booking'}
                        </button>
                      )}
                      
                      {booking.status === 'confirmed' && (
                        <button className="text-sm text-blue-400 hover:text-blue-300">
                          Check Out Equipment
                        </button>
                      )}
                      
                      {['active', 'checked_out'].includes(booking.status) && (
                        <button className="text-sm text-green-400 hover:text-green-300">
                          Return Equipment
                        </button>
                      )}
                      
                      <button className="text-sm text-gray-400 hover:text-white">
                        View Details
                      </button>
                    </div>
                  </div>
                </div>
              </div>
              
              {/* Active indicator bar */}
              {['active', 'checked_out'].includes(booking.status) && (
                <div className="h-1 bg-green-500"></div>
              )}
              {booking.status === 'overdue' && (
                <div className="h-1 bg-orange-500"></div>
              )}
            </div>
          ))}
        </div>
      )}
    </div>
  );
}

Part 4: Add Route
tsx// In App.tsx or your router config, add:

import MyBookings from './pages/rentals/MyBookings';

// Add route
<Route path="/rentals/bookings" element={<MyBookings />} />

Part 5: Update Sidebar (Example Structure)
tsx// If your sidebar uses a config array, add this section:

const sidebarSections = [
  // ... existing sections ...
  
  {
    title: 'RENTALS',
    icon: 'üéØ',
    items: [
      { name: 'Rent Equipment', path: '/rentals', icon: 'üö£' },
      { name: 'My Bookings', path: '/rentals/bookings', icon: 'üìã' },
    ]
  },
  
  // ... rest of sections ...
];
```

---

## Summary

This prompt adds:

| Component | What It Does |
|-----------|--------------|
| **Sidebar Nav** | RENTALS section with Rent Equipment + My Bookings |
| **My Bookings Page** | Full booking management with stats, filters, actions |
| **Cancel API** | Endpoint to cancel pending/confirmed bookings |
| **Booking Details API** | Endpoint to fetch single booking |
| **Status Badges** | Color-coded status indicators |
| **Action Buttons** | Cancel, Check Out, Return based on status |

The flow is now complete:
```
Browse Equipment ‚Üí Book ‚Üí My Bookings ‚Üí Manage ‚Üí Return