## B1 SPATIAL PATCH — Add Plan View + Availability Support

Create migration 0162 to add spatial/plan rendering columns to cc_units and time-window columns to cc_reservation_allocations.

### CONTEXT
- Schema location: shared/schema.ts
- cc_units has 35 columns, needs layout_* columns for plan views
- cc_reservation_allocations has 10 columns, needs starts_at/ends_at for availability
- This is ADDITIVE ONLY — do not modify existing columns
- Includes backfill for existing allocations (critical for availability)

### NON-NEGOTIABLE RULES
- Use "reservation" not "booking"
- All new columns nullable or have safe defaults
- Use IF NOT EXISTS for all creates

---

### SQL MIGRATION (create as server/db/migrations/0162_b1_spatial_patch.sql)
```sql
BEGIN;

-- ===========================================================================
-- B1.1: Add spatial/plan fields to cc_units
-- ===========================================================================

ALTER TABLE cc_units
  ADD COLUMN IF NOT EXISTS layout_ref text,
  ADD COLUMN IF NOT EXISTS layout_x numeric,
  ADD COLUMN IF NOT EXISTS layout_y numeric,
  ADD COLUMN IF NOT EXISTS layout_rotation numeric,
  ADD COLUMN IF NOT EXISTS layout_shape jsonb,
  ADD COLUMN IF NOT EXISTS layout_bounds jsonb,
  ADD COLUMN IF NOT EXISTS is_public_searchable boolean NOT NULL DEFAULT false,
  ADD COLUMN IF NOT EXISTS metadata jsonb NOT NULL DEFAULT '{}'::jsonb;

CREATE INDEX IF NOT EXISTS ix_cc_units_property_type
  ON cc_units (property_id, unit_type);

CREATE INDEX IF NOT EXISTS ix_cc_units_property_layout_ref
  ON cc_units (property_id, layout_ref);

CREATE INDEX IF NOT EXISTS ix_cc_units_property_type_sort
  ON cc_units (property_id, unit_type, sort_order);

CREATE INDEX IF NOT EXISTS ix_cc_units_public_searchable
  ON cc_units (is_public_searchable)
  WHERE is_public_searchable = true;

CREATE UNIQUE INDEX IF NOT EXISTS ux_cc_units_property_type_code
  ON cc_units (property_id, unit_type, code)
  WHERE code IS NOT NULL AND length(trim(code)) > 0;

-- ===========================================================================
-- B1.2: Add time windows to cc_reservation_allocations
-- ===========================================================================

ALTER TABLE cc_reservation_allocations
  ADD COLUMN IF NOT EXISTS starts_at timestamptz,
  ADD COLUMN IF NOT EXISTS ends_at timestamptz,
  ADD COLUMN IF NOT EXISTS unit_id uuid;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints
    WHERE constraint_name = 'fk_cc_reservation_allocations_unit'
    AND table_name = 'cc_reservation_allocations'
  ) THEN
    ALTER TABLE cc_reservation_allocations
      ADD CONSTRAINT fk_cc_reservation_allocations_unit
      FOREIGN KEY (unit_id) REFERENCES cc_units(id)
      ON DELETE SET NULL;
  END IF;
END $$;

-- Backfill time window for existing allocations (critical for correct availability)
UPDATE cc_reservation_allocations a
SET
  starts_at = ci.start_at,
  ends_at   = ci.end_at
FROM cc_reservation_cart_items ci
WHERE a.reservation_item_id = ci.id
  AND (a.starts_at IS NULL OR a.ends_at IS NULL)
  AND ci.start_at IS NOT NULL
  AND ci.end_at IS NOT NULL;

-- Time-window sanity constraint (prevents bad data)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints
    WHERE constraint_name = 'ck_cc_reservation_allocations_time_window'
      AND table_name = 'cc_reservation_allocations'
  ) THEN
    ALTER TABLE cc_reservation_allocations
      ADD CONSTRAINT ck_cc_reservation_allocations_time_window
      CHECK (starts_at IS NULL OR ends_at IS NULL OR starts_at < ends_at);
  END IF;
END $$;

CREATE INDEX IF NOT EXISTS ix_cc_res_alloc_inventory_time
  ON cc_reservation_allocations (inventory_unit_id, starts_at, ends_at);

CREATE INDEX IF NOT EXISTS ix_cc_res_alloc_unit_time
  ON cc_reservation_allocations (unit_id, starts_at, ends_at);

CREATE INDEX IF NOT EXISTS ix_cc_res_alloc_reservation_item
  ON cc_reservation_allocations (reservation_item_id);

-- ===========================================================================
-- B1.3: Detail tables
-- ===========================================================================

CREATE TABLE IF NOT EXISTS cc_parking_unit_details (
  unit_id uuid PRIMARY KEY REFERENCES cc_units(id) ON DELETE CASCADE,
  zone_code text,
  size_class text,
  power_available boolean NOT NULL DEFAULT false,
  covered boolean NOT NULL DEFAULT false,
  accessible boolean NOT NULL DEFAULT false,
  ev_charging boolean NOT NULL DEFAULT false,
  notes text,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS cc_marina_unit_details (
  unit_id uuid PRIMARY KEY REFERENCES cc_units(id) ON DELETE CASCADE,
  dock_code text,
  dock_side text,
  min_length_ft numeric,
  max_length_ft numeric,
  max_beam_ft numeric,
  max_draft_ft numeric,
  power_service text,
  has_water boolean NOT NULL DEFAULT true,
  has_pump_out boolean NOT NULL DEFAULT false,
  notes text,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS cc_bed_unit_details (
  unit_id uuid PRIMARY KEY REFERENCES cc_units(id) ON DELETE CASCADE,
  bed_type text,
  privacy_level text,
  linens_provided boolean NOT NULL DEFAULT true,
  accessible boolean NOT NULL DEFAULT false,
  notes text,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

COMMIT;
```

---

### DRIZZLE SCHEMA UPDATES (add to shared/schema.ts)

**IMPORTANT: Use sql template for jsonb defaults**

**1. Add import at top of file (if not already present):**
```typescript
import { sql } from "drizzle-orm";
```

**2. Add these columns to existing ccUnits definition:**
```typescript
// B1.1: Spatial/plan rendering fields
layoutRef: text("layout_ref"),
layoutX: numeric("layout_x"),
layoutY: numeric("layout_y"),
layoutRotation: numeric("layout_rotation"),
layoutShape: jsonb("layout_shape"),
layoutBounds: jsonb("layout_bounds"),
isPublicSearchable: boolean("is_public_searchable").notNull().default(false),
metadata: jsonb("metadata").notNull().default(sql`'{}'::jsonb`),
```

**3. Add these columns to existing ccReservationAllocations definition:**
```typescript
// B1.2: Time window for availability
startsAt: timestamp("starts_at", { withTimezone: true }),
endsAt: timestamp("ends_at", { withTimezone: true }),
unitId: uuid("unit_id"),
```

**4. Add these NEW table definitions:**
```typescript
export const ccParkingUnitDetails = pgTable("cc_parking_unit_details", {
  unitId: uuid("unit_id").primaryKey(),
  zoneCode: text("zone_code"),
  sizeClass: text("size_class"),
  powerAvailable: boolean("power_available").notNull().default(false),
  covered: boolean("covered").notNull().default(false),
  accessible: boolean("accessible").notNull().default(false),
  evCharging: boolean("ev_charging").notNull().default(false),
  notes: text("notes"),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
});

export const ccMarinaUnitDetails = pgTable("cc_marina_unit_details", {
  unitId: uuid("unit_id").primaryKey(),
  dockCode: text("dock_code"),
  dockSide: text("dock_side"),
  minLengthFt: numeric("min_length_ft"),
  maxLengthFt: numeric("max_length_ft"),
  maxBeamFt: numeric("max_beam_ft"),
  maxDraftFt: numeric("max_draft_ft"),
  powerService: text("power_service"),
  hasWater: boolean("has_water").notNull().default(true),
  hasPumpOut: boolean("has_pump_out").notNull().default(false),
  notes: text("notes"),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
});

export const ccBedUnitDetails = pgTable("cc_bed_unit_details", {
  unitId: uuid("unit_id").primaryKey(),
  bedType: text("bed_type"),
  privacyLevel: text("privacy_level"),
  linensProvided: boolean("linens_provided").notNull().default(true),
  accessible: boolean("accessible").notNull().default(false),
  notes: text("notes"),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
});
```

---

### POST-MIGRATION VERIFICATION

Run these queries after migration completes:
```sql
-- 1. Confirm new columns on cc_units
SELECT column_name FROM information_schema.columns 
WHERE table_name = 'cc_units' 
AND column_name IN ('layout_x', 'layout_y', 'layout_shape', 'is_public_searchable', 'metadata')
ORDER BY column_name;

-- 2. Confirm new columns on cc_reservation_allocations
SELECT column_name FROM information_schema.columns 
WHERE table_name = 'cc_reservation_allocations' 
AND column_name IN ('starts_at', 'ends_at', 'unit_id')
ORDER BY column_name;

-- 3. Confirm detail tables exist
SELECT table_name FROM information_schema.tables 
WHERE table_name IN ('cc_parking_unit_details', 'cc_marina_unit_details', 'cc_bed_unit_details')
ORDER BY table_name;

-- 4. Confirm backfill worked (should return 0 if all allocations are populated)
SELECT COUNT(*) as orphaned_allocations
FROM cc_reservation_allocations a
WHERE a.starts_at IS NULL 
  AND EXISTS (
    SELECT 1 FROM cc_reservation_cart_items ci 
    WHERE ci.id = a.reservation_item_id 
    AND ci.start_at IS NOT NULL
  );

-- 5. Confirm constraint exists
SELECT constraint_name FROM information_schema.table_constraints
WHERE table_name = 'cc_reservation_allocations'
AND constraint_name = 'ck_cc_reservation_allocations_time_window';
```

---

### EXPECTED OUTCOME

After this migration:
- cc_units: 43 columns (was 35)
- cc_reservation_allocations: 13 columns (was 10)
- 3 new detail tables created
- Existing allocations backfilled with time windows
- Sanity constraint prevents bad time data