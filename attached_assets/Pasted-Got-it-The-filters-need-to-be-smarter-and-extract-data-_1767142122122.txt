Got it! The filters need to be smarter and extract data from the webcam names/descriptions. Let me create an enhanced version with intelligent categorization:

PROMPT 28.2: Enhanced Webcams Tab with Smart Filters
Enhance the Webcams tab with intelligent filtering that categorizes webcams by source and extracts highways from names.

Update file: client/src/components/Dashboard/WebcamsTab.tsx

import React, { useEffect, useState, useMemo } from 'react';

interface Webcam {
  id: number;
  slug: string;
  name: string;
  latitude: number;
  longitude: number;
  region_id: string;
  region_name?: string;
  metadata: {
    direct_feed_url: string;
    view_description: string;
    source_provider: string;
    highway?: string;
  };
}

interface WebcamsTabProps {
  regionId?: string;
}

// Smart categorization based on webcam names and URLs
function categorizeWebcam(webcam: Webcam): { 
  source: string; 
  subCategory: string; 
  highway: string | null;
} {
  const name = webcam.name.toLowerCase();
  const desc = (webcam.metadata?.view_description || '').toLowerCase();
  const url = (webcam.metadata?.direct_feed_url || '').toLowerCase();
  
  // Extract highway number
  let highway: string | null = null;
  const hwMatch = name.match(/(?:highway|hwy|hw)\s*(\d+[a-z]?)/i) || 
                  desc.match(/(?:highway|hwy|hw)\s*(\d+[a-z]?)/i);
  if (hwMatch) {
    highway = `Highway ${hwMatch[1].toUpperCase()}`;
  }
  
  // Categorize by source
  // BC Ferries terminals
  const ferryTerminals = [
    'tsawwassen', 'swartz bay', 'horseshoe bay', 'nanaimo', 'duke point',
    'langdale', 'departure bay', 'comox', 'powell river', 'texada',
    'quadra', 'cortes', 'denman', 'hornby', 'gabriola', 'salt spring',
    'pender', 'mayne', 'galiano', 'saturna', 'thetis', 'penelakut',
    'vesuvius', 'crofton', 'mill bay', 'brentwood', 'fulford harbour',
    'long harbour', 'otter bay', 'village bay', 'sturdies bay',
    'adams lake', 'ferry landing', 'ferry lineup', 'ferry terminal'
  ];
  
  for (const terminal of ferryTerminals) {
    if (name.includes(terminal) || desc.includes(terminal)) {
      // Determine which terminal
      let subCat = 'Other Terminal';
      if (name.includes('tsawwassen')) subCat = 'Tsawwassen';
      else if (name.includes('swartz')) subCat = 'Swartz Bay';
      else if (name.includes('horseshoe')) subCat = 'Horseshoe Bay';
      else if (name.includes('nanaimo') || name.includes('departure')) subCat = 'Nanaimo';
      else if (name.includes('duke point')) subCat = 'Duke Point';
      else if (name.includes('langdale')) subCat = 'Langdale';
      else if (name.includes('adams lake')) subCat = 'Adams Lake Ferry';
      else if (name.includes('kootenay')) subCat = 'Kootenay Lake Ferry';
      else subCat = terminal.charAt(0).toUpperCase() + terminal.slice(1);
      
      return { source: 'BC Ferries', subCategory: subCat, highway };
    }
  }
  
  // Ski Resorts
  const skiResorts: Record<string, string[]> = {
    'Whistler Blackcomb': ['whistler', 'blackcomb'],
    'Big White': ['big white'],
    'Silver Star': ['silver star'],
    'Sun Peaks': ['sun peaks'],
    'Revelstoke': ['revelstoke mountain', 'revelstoke resort'],
    'Kicking Horse': ['kicking horse'],
    'Fernie': ['fernie alpine'],
    'Panorama': ['panorama'],
    'Red Mountain': ['red mountain', 'rossland'],
    'Apex': ['apex'],
    'Mt Washington': ['mt washington', 'mount washington'],
    'Cypress': ['cypress mountain', 'cypress bowl'],
    'Grouse': ['grouse mountain'],
    'Seymour': ['mt seymour', 'mount seymour'],
  };
  
  for (const [resort, keywords] of Object.entries(skiResorts)) {
    for (const kw of keywords) {
      if (name.includes(kw) || desc.includes(kw)) {
        return { source: 'Ski Resorts', subCategory: resort, highway };
      }
    }
  }
  
  // Mountain Passes (special highway sections)
  const passes = [
    { name: 'Coquihalla Summit', keywords: ['coquihalla', 'coq'] },
    { name: 'Rogers Pass', keywords: ['rogers pass'] },
    { name: 'Kicking Horse Pass', keywords: ['kicking horse pass'] },
    { name: 'Crowsnest Pass', keywords: ['crowsnest'] },
    { name: 'Allison Pass', keywords: ['allison pass'] },
    { name: 'Paulson Summit', keywords: ['paulson'] },
    { name: 'Kootenay Pass', keywords: ['kootenay pass'] },
    { name: 'Malahat', keywords: ['malahat'] },
  ];
  
  for (const pass of passes) {
    for (const kw of pass.keywords) {
      if (name.includes(kw) || desc.includes(kw)) {
        return { source: 'Mountain Passes', subCategory: pass.name, highway };
      }
    }
  }
  
  // Border Crossings
  if (name.includes('border') || name.includes('peace arch') || 
      name.includes('pacific highway') || name.includes('aldergrove') ||
      name.includes('huntingdon') || name.includes('sumas')) {
    let crossing = 'Other';
    if (name.includes('peace arch')) crossing = 'Peace Arch';
    else if (name.includes('pacific highway')) crossing = 'Pacific Highway';
    else if (name.includes('aldergrove')) crossing = 'Aldergrove';
    else if (name.includes('huntingdon') || name.includes('sumas')) crossing = 'Huntingdon-Sumas';
    return { source: 'Border Crossings', subCategory: crossing, highway };
  }
  
  // Major Bridges & Tunnels
  const bridges = [
    'lions gate', 'ironworkers', 'second narrows', 'alex fraser',
    'port mann', 'pattullo', 'oak street', 'knight street', 'arthur laing',
    'massey tunnel', 'george massey', 'golden ears', 'pitt river'
  ];
  
  for (const bridge of bridges) {
    if (name.includes(bridge) || desc.includes(bridge)) {
      const bridgeName = bridge.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
      return { source: 'Bridges & Tunnels', subCategory: bridgeName, highway };
    }
  }
  
  // Default: DriveBC Highway Camera
  if (highway) {
    return { source: 'DriveBC Highways', subCategory: highway, highway };
  }
  
  return { source: 'Other', subCategory: 'General', highway };
}

export function WebcamsTab({ regionId }: WebcamsTabProps) {
  const [webcams, setWebcams] = useState<Webcam[]>([]);
  const [loading, setLoading] = useState(true);
  const [selectedWebcam, setSelectedWebcam] = useState<Webcam | null>(null);
  const [refreshKey, setRefreshKey] = useState(0);
  
  // Filters
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedSource, setSelectedSource] = useState<string>('all');
  const [selectedSubCategory, setSelectedSubCategory] = useState<string>('all');
  const [selectedHighway, setSelectedHighway] = useState<string>('all');
  
  // Pagination
  const [page, setPage] = useState(1);
  const [pageSize, setPageSize] = useState(24);
  
  // Grid columns
  const [columns, setColumns] = useState<3 | 4 | 6>(4);

  useEffect(() => {
    fetchWebcams();
  }, [regionId]);

  // Auto-refresh every 60 seconds
  useEffect(() => {
    const interval = setInterval(() => {
      setRefreshKey(k => k + 1);
    }, 60000);
    return () => clearInterval(interval);
  }, []);

  async function fetchWebcams() {
    setLoading(true);
    try {
      const url = `/api/v1/entities?type=webcam&limit=1500`;
      const response = await fetch(url);
      const data = await response.json();
      const webcamList = data.entities || data || [];
      setWebcams(webcamList);
    } catch (error) {
      console.error('Failed to fetch webcams:', error);
    } finally {
      setLoading(false);
    }
  }

  // Categorize all webcams
  const categorizedWebcams = useMemo(() => {
    return webcams.map(w => ({
      ...w,
      _category: categorizeWebcam(w)
    }));
  }, [webcams]);

  // Get available sources and their subcategories
  const { sources, subCategories, highways } = useMemo(() => {
    const sourceMap = new Map<string, Set<string>>();
    const hwSet = new Set<string>();
    
    categorizedWebcams.forEach(w => {
      const { source, subCategory, highway } = w._category;
      
      if (!sourceMap.has(source)) {
        sourceMap.set(source, new Set());
      }
      sourceMap.get(source)!.add(subCategory);
      
      if (highway) hwSet.add(highway);
    });
    
    // Sort sources by count
    const sourceEntries = Array.from(sourceMap.entries())
      .map(([source, subs]) => ({
        source,
        subCategories: Array.from(subs).sort(),
        count: categorizedWebcams.filter(w => w._category.source === source).length
      }))
      .sort((a, b) => b.count - a.count);
    
    return {
      sources: sourceEntries,
      subCategories: selectedSource !== 'all' 
        ? sourceEntries.find(s => s.source === selectedSource)?.subCategories || []
        : [],
      highways: Array.from(hwSet).sort((a, b) => {
        const numA = parseInt(a.replace(/\D/g, '')) || 0;
        const numB = parseInt(b.replace(/\D/g, '')) || 0;
        return numA - numB;
      })
    };
  }, [categorizedWebcams, selectedSource]);

  // Filter webcams
  const filteredWebcams = useMemo(() => {
    let filtered = categorizedWebcams;

    // Search filter
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      filtered = filtered.filter(w =>
        w.name.toLowerCase().includes(query) ||
        w.metadata?.view_description?.toLowerCase().includes(query)
      );
    }

    // Source filter
    if (selectedSource !== 'all') {
      filtered = filtered.filter(w => w._category.source === selectedSource);
    }

    // Sub-category filter
    if (selectedSubCategory !== 'all') {
      filtered = filtered.filter(w => w._category.subCategory === selectedSubCategory);
    }

    // Highway filter
    if (selectedHighway !== 'all') {
      filtered = filtered.filter(w => w._category.highway === selectedHighway);
    }

    return filtered;
  }, [searchQuery, selectedSource, selectedSubCategory, selectedHighway, categorizedWebcams]);

  // Reset sub-category when source changes
  useEffect(() => {
    setSelectedSubCategory('all');
  }, [selectedSource]);

  // Reset page on filter change
  useEffect(() => {
    setPage(1);
  }, [searchQuery, selectedSource, selectedSubCategory, selectedHighway]);

  // Pagination
  const totalPages = Math.ceil(filteredWebcams.length / pageSize);
  const paginatedWebcams = filteredWebcams.slice((page - 1) * pageSize, page * pageSize);

  const gridCols = {
    3: 'grid-cols-1 sm:grid-cols-2 lg:grid-cols-3',
    4: 'grid-cols-2 sm:grid-cols-3 lg:grid-cols-4',
    6: 'grid-cols-2 sm:grid-cols-3 lg:grid-cols-6',
  };

  // Source icons
  const sourceIcons: Record<string, string> = {
    'BC Ferries': '‚õ¥Ô∏è',
    'Ski Resorts': '‚õ∑Ô∏è',
    'Mountain Passes': 'üèîÔ∏è',
    'Border Crossings': 'üõÇ',
    'Bridges & Tunnels': 'üåâ',
    'DriveBC Highways': 'üõ£Ô∏è',
    'Other': 'üì∑',
  };

  if (loading) {
    return (
      <div className="space-y-4">
        <div className="bg-gray-800 rounded-xl p-4 animate-pulse">
          <div className="h-10 bg-gray-700 rounded w-64 mb-4"></div>
          <div className="grid grid-cols-4 gap-4">
            {Array(12).fill(0).map((_, i) => (
              <div key={i} className="aspect-video bg-gray-700 rounded-lg"></div>
            ))}
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      {/* Header & Filters */}
      <div className="bg-gray-800 rounded-xl p-4">
        <div className="flex flex-col lg:flex-row lg:items-center justify-between gap-4">
          <div>
            <h2 className="text-xl font-bold text-white flex items-center gap-2">
              üì∑ Live Webcams
              <span className="text-sm font-normal text-gray-400">
                ({filteredWebcams.length} of {webcams.length})
              </span>
            </h2>
            <p className="text-gray-400 text-sm mt-1">
              Real-time cameras across British Columbia
            </p>
          </div>

          <div className="flex items-center gap-2">
            <button
              onClick={() => setRefreshKey(k => k + 1)}
              className="px-3 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg text-sm flex items-center gap-1"
            >
              üîÑ Refresh All
            </button>
            
            {/* Grid size toggle */}
            <div className="flex bg-gray-700 rounded-lg p-1">
              {[3, 4, 6].map(cols => (
                <button
                  key={cols}
                  onClick={() => setColumns(cols as 3 | 4 | 6)}
                  className={`px-3 py-1 rounded text-sm ${
                    columns === cols 
                      ? 'bg-blue-600 text-white' 
                      : 'text-gray-400 hover:text-white'
                  }`}
                >
                  {cols}
                </button>
              ))}
            </div>
          </div>
        </div>

        {/* Search */}
        <div className="mt-4">
          <input
            type="text"
            placeholder="Search cameras by name or location..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="w-full bg-gray-700 text-white rounded-lg px-4 py-2 text-sm border border-gray-600 focus:border-blue-500 focus:outline-none"
          />
        </div>

        {/* Source Filter Chips */}
        <div className="mt-4">
          <p className="text-gray-400 text-xs uppercase mb-2">Filter by Source</p>
          <div className="flex flex-wrap gap-2">
            <button
              onClick={() => setSelectedSource('all')}
              className={`px-3 py-1.5 rounded-full text-sm font-medium transition-colors ${
                selectedSource === 'all'
                  ? 'bg-blue-600 text-white'
                  : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
              }`}
            >
              üì∑ All ({webcams.length})
            </button>
            {sources.map(({ source, count }) => (
              <button
                key={source}
                onClick={() => setSelectedSource(source)}
                className={`px-3 py-1.5 rounded-full text-sm font-medium transition-colors ${
                  selectedSource === source
                    ? 'bg-blue-600 text-white'
                    : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                }`}
              >
                {sourceIcons[source] || 'üì∑'} {source} ({count})
              </button>
            ))}
          </div>
        </div>

        {/* Sub-category Filter (shown when source selected) */}
        {selectedSource !== 'all' && subCategories.length > 1 && (
          <div className="mt-3">
            <p className="text-gray-400 text-xs uppercase mb-2">
              {selectedSource === 'BC Ferries' && '‚õ¥Ô∏è Select Terminal'}
              {selectedSource === 'Ski Resorts' && '‚õ∑Ô∏è Select Resort'}
              {selectedSource === 'Mountain Passes' && 'üèîÔ∏è Select Pass'}
              {selectedSource === 'Border Crossings' && 'üõÇ Select Crossing'}
              {selectedSource === 'Bridges & Tunnels' && 'üåâ Select Bridge/Tunnel'}
              {selectedSource === 'DriveBC Highways' && 'üõ£Ô∏è Select Highway'}
            </p>
            <div className="flex flex-wrap gap-2">
              <button
                onClick={() => setSelectedSubCategory('all')}
                className={`px-3 py-1 rounded-full text-xs font-medium transition-colors ${
                  selectedSubCategory === 'all'
                    ? 'bg-green-600 text-white'
                    : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                }`}
              >
                All
              </button>
              {subCategories.map(sub => {
                const count = categorizedWebcams.filter(
                  w => w._category.source === selectedSource && w._category.subCategory === sub
                ).length;
                return (
                  <button
                    key={sub}
                    onClick={() => setSelectedSubCategory(sub)}
                    className={`px-3 py-1 rounded-full text-xs font-medium transition-colors ${
                      selectedSubCategory === sub
                        ? 'bg-green-600 text-white'
                        : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                    }`}
                  >
                    {sub} ({count})
                  </button>
                );
              })}
            </div>
          </div>
        )}

        {/* Highway Quick Filter (for DriveBC) */}
        {(selectedSource === 'all' || selectedSource === 'DriveBC Highways') && highways.length > 0 && (
          <div className="mt-3">
            <p className="text-gray-400 text-xs uppercase mb-2">üõ£Ô∏è Filter by Highway</p>
            <div className="flex flex-wrap gap-1">
              <button
                onClick={() => setSelectedHighway('all')}
                className={`px-2 py-1 rounded text-xs font-medium transition-colors ${
                  selectedHighway === 'all'
                    ? 'bg-orange-600 text-white'
                    : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                }`}
              >
                All
              </button>
              {highways.slice(0, 20).map(hw => (
                <button
                  key={hw}
                  onClick={() => setSelectedHighway(hw)}
                  className={`px-2 py-1 rounded text-xs font-medium transition-colors ${
                    selectedHighway === hw
                      ? 'bg-orange-600 text-white'
                      : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                  }`}
                >
                  {hw.replace('Highway ', 'Hwy ')}
                </button>
              ))}
              {highways.length > 20 && (
                <span className="px-2 py-1 text-xs text-gray-500">
                  +{highways.length - 20} more
                </span>
              )}
            </div>
          </div>
        )}

        {/* Page Size (bottom right) */}
        <div className="mt-4 flex justify-between items-center">
          <div className="text-gray-400 text-sm">
            Showing {((page - 1) * pageSize) + 1}-{Math.min(page * pageSize, filteredWebcams.length)} of {filteredWebcams.length}
          </div>
          <select
            value={pageSize}
            onChange={(e) => setPageSize(Number(e.target.value))}
            className="bg-gray-700 text-white rounded-lg px-3 py-1 text-sm border border-gray-600"
          >
            <option value={12}>12 per page</option>
            <option value={24}>24 per page</option>
            <option value={48}>48 per page</option>
            <option value={96}>96 per page</option>
          </select>
        </div>
      </div>

      {/* Webcam Grid */}
      <div className={`grid ${gridCols[columns]} gap-4`}>
        {paginatedWebcams.map(webcam => (
          <WebcamCard
            key={webcam.id}
            webcam={webcam}
            refreshKey={refreshKey}
            category={webcam._category}
            onClick={() => setSelectedWebcam(webcam)}
          />
        ))}
      </div>

      {/* Empty State */}
      {filteredWebcams.length === 0 && (
        <div className="bg-gray-800 rounded-xl p-12 text-center">
          <span className="text-4xl">üì∑</span>
          <p className="text-gray-300 mt-2">No webcams match your filters</p>
          <button
            onClick={() => {
              setSearchQuery('');
              setSelectedSource('all');
              setSelectedSubCategory('all');
              setSelectedHighway('all');
            }}
            className="mt-4 text-blue-400 hover:text-blue-300"
          >
            Clear all filters
          </button>
        </div>
      )}

      {/* Pagination */}
      {totalPages > 1 && (
        <div className="flex items-center justify-center gap-2 py-4">
          <button
            onClick={() => setPage(1)}
            disabled={page === 1}
            className="px-3 py-2 bg-gray-700 text-white rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-600"
          >
            ¬´¬´
          </button>
          <button
            onClick={() => setPage(p => Math.max(1, p - 1))}
            disabled={page === 1}
            className="px-3 py-2 bg-gray-700 text-white rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-600"
          >
            ‚Äπ
          </button>
          
          <span className="px-4 py-2 text-gray-300">
            Page {page} of {totalPages}
          </span>
          
          <button
            onClick={() => setPage(p => Math.min(totalPages, p + 1))}
            disabled={page === totalPages}
            className="px-3 py-2 bg-gray-700 text-white rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-600"
          >
            ‚Ä∫
          </button>
          <button
            onClick={() => setPage(totalPages)}
            disabled={page === totalPages}
            className="px-3 py-2 bg-gray-700 text-white rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-600"
          >
            ¬ª¬ª
          </button>
        </div>
      )}

      {/* Fullscreen Modal */}
      {selectedWebcam && (
        <WebcamModal
          webcam={selectedWebcam}
          refreshKey={refreshKey}
          onClose={() => setSelectedWebcam(null)}
          onNext={() => {
            const idx = filteredWebcams.findIndex(w => w.id === selectedWebcam.id);
            if (idx < filteredWebcams.length - 1) {
              setSelectedWebcam(filteredWebcams[idx + 1]);
            }
          }}
          onPrev={() => {
            const idx = filteredWebcams.findIndex(w => w.id === selectedWebcam.id);
            if (idx > 0) {
              setSelectedWebcam(filteredWebcams[idx - 1]);
            }
          }}
        />
      )}
    </div>
  );
}

interface WebcamCardProps {
  webcam: Webcam & { _category?: { source: string; subCategory: string; highway: string | null } };
  refreshKey: number;
  category?: { source: string; subCategory: string; highway: string | null };
  onClick: () => void;
}

function WebcamCard({ webcam, refreshKey, category, onClick }: WebcamCardProps) {
  const [imageError, setImageError] = useState(false);
  const [imageLoading, setImageLoading] = useState(true);

  useEffect(() => {
    setImageLoading(true);
    setImageError(false);
  }, [refreshKey]);

  const imageUrl = webcam.metadata?.direct_feed_url
    ? `${webcam.metadata.direct_feed_url}?t=${refreshKey}`
    : null;

  const sourceIcons: Record<string, string> = {
    'BC Ferries': '‚õ¥Ô∏è',
    'Ski Resorts': '‚õ∑Ô∏è',
    'Mountain Passes': 'üèîÔ∏è',
    'Border Crossings': 'üõÇ',
    'Bridges & Tunnels': 'üåâ',
    'DriveBC Highways': 'üõ£Ô∏è',
    'Other': 'üì∑',
  };

  return (
    <div
      className="group relative bg-gray-800 rounded-lg overflow-hidden cursor-pointer hover:ring-2 hover:ring-blue-400 transition-all"
      onClick={onClick}
    >
      <div className="aspect-video relative">
        {imageLoading && !imageError && (
          <div className="absolute inset-0 bg-gray-700 animate-pulse flex items-center justify-center">
            <span className="text-gray-500 text-sm">Loading...</span>
          </div>
        )}

        {imageError || !imageUrl ? (
          <div className="absolute inset-0 bg-gray-700 flex items-center justify-center">
            <div className="text-center">
              <span className="text-3xl">üì∑</span>
              <p className="text-gray-400 text-xs mt-1">Unavailable</p>
            </div>
          </div>
        ) : (
          <img
            src={imageUrl}
            alt={webcam.name}
            className={`w-full h-full object-cover transition-opacity ${imageLoading ? 'opacity-0' : 'opacity-100'}`}
            onLoad={() => setImageLoading(false)}
            onError={() => { setImageError(true); setImageLoading(false); }}
          />
        )}

        {/* Live indicator */}
        <div className="absolute top-2 left-2 flex items-center gap-1 bg-black/60 rounded px-2 py-0.5">
          <span className="w-2 h-2 bg-red-500 rounded-full animate-pulse"></span>
          <span className="text-white text-xs font-medium">LIVE</span>
        </div>

        {/* Source badge */}
        {category && (
          <div className="absolute top-2 right-2 bg-black/60 rounded px-2 py-0.5">
            <span className="text-xs">{sourceIcons[category.source] || 'üì∑'}</span>
          </div>
        )}

        {/* Expand icon on hover */}
        <div className="absolute inset-0 bg-black/0 group-hover:bg-black/30 transition-colors flex items-center justify-center">
          <span className="text-white text-2xl opacity-0 group-hover:opacity-100 transition-opacity">
            üîç
          </span>
        </div>
      </div>

      {/* Info */}
      <div className="p-3">
        <h4 className="text-white text-sm font-medium truncate">
          {webcam.name}
        </h4>
        {webcam.metadata?.view_description && (
          <p className="text-gray-400 text-xs truncate mt-0.5">
            {webcam.metadata.view_description}
          </p>
        )}
        {category && (
          <p className="text-gray-500 text-xs mt-1">
            {sourceIcons[category.source]} {category.subCategory}
          </p>
        )}
      </div>
    </div>
  );
}

// Keep the WebcamModal component from before (with keyboard navigation)
interface WebcamModalProps {
  webcam: Webcam;
  refreshKey: number;
  onClose: () => void;
  onNext: () => void;
  onPrev: () => void;
}

function WebcamModal({ webcam, refreshKey, onClose, onNext, onPrev }: WebcamModalProps) {
  const [localRefresh, setLocalRefresh] = useState(refreshKey);

  useEffect(() => {
    const interval = setInterval(() => {
      setLocalRefresh(r => r + 1);
    }, 10000);
    return () => clearInterval(interval);
  }, []);

  useEffect(() => {
    function handleKeyDown(e: KeyboardEvent) {
      if (e.key === 'Escape') onClose();
      if (e.key === 'ArrowRight') onNext();
      if (e.key === 'ArrowLeft') onPrev();
    }
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [onClose, onNext, onPrev]);

  const imageUrl = webcam.metadata?.direct_feed_url
    ? `${webcam.metadata.direct_feed_url}?t=${localRefresh}`
    : null;

  return (
    <div className="fixed inset-0 bg-black/95 z-50 flex items-center justify-center" onClick={onClose}>
      <button
        onClick={(e) => { e.stopPropagation(); onPrev(); }}
        className="absolute left-4 top-1/2 -translate-y-1/2 p-4 text-white/50 hover:text-white text-4xl z-10"
      >‚Äπ</button>
      <button
        onClick={(e) => { e.stopPropagation(); onNext(); }}
        className="absolute right-4 top-1/2 -translate-y-1/2 p-4 text-white/50 hover:text-white text-4xl z-10"
      >‚Ä∫</button>

      <div className="max-w-6xl w-full mx-4 bg-gray-900 rounded-xl overflow-hidden" onClick={e => e.stopPropagation()}>
        <div className="flex items-center justify-between px-4 py-3 border-b border-gray-700">
          <div>
            <h3 className="text-white font-semibold">{webcam.name}</h3>
            <p className="text-gray-400 text-sm">{webcam.metadata?.view_description}</p>
          </div>
          <div className="flex items-center gap-3">
            <button onClick={() => setLocalRefresh(r => r + 1)} className="px-3 py-1 bg-gray-700 hover:bg-gray-600 text-white rounded text-sm">
              üîÑ Refresh
            </button>
            <button onClick={onClose} className="text-gray-400 hover:text-white text-2xl px-2">‚úï</button>
          </div>
        </div>

        <div className="relative bg-black">
          {imageUrl ? (
            <img src={imageUrl} alt={webcam.name} className="w-full max-h-[70vh] object-contain" />
          ) : (
            <div className="aspect-video flex items-center justify-center">
              <span className="text-gray-500">Image unavailable</span>
            </div>
          )}
          <div className="absolute top-4 left-4 flex items-center gap-2 bg-black/60 rounded-lg px-3 py-1">
            <span className="w-2 h-2 bg-red-500 rounded-full animate-pulse"></span>
            <span className="text-white text-sm font-medium">LIVE</span>
            <span className="text-gray-300 text-xs">‚Ä¢ Auto-refresh 10s</span>
          </div>
        </div>

        <div className="px-4 py-3 border-t border-gray-700 flex items-center justify-between text-sm text-gray-400">
          <span>Source: {webcam.metadata?.source_provider || 'DriveBC'}</span>
          <span>üìç {webcam.latitude?.toFixed(4)}, {webcam.longitude?.toFixed(4)}</span>
          <span className="text-xs">‚Üê ‚Üí to navigate ‚Ä¢ ESC to close</span>
        </div>
      </div>
    </div>
  );
}

export default WebcamsTab;
This enhanced version features:
Smart Categorization:

Parses webcam names to auto-detect source type
Extracts highway numbers from names (Highway 1, Hwy 17, etc.)
Identifies ferry terminals, ski resorts, mountain passes, border crossings, bridges

Hierarchical Filters:

Source chips: BC Ferries, Ski Resorts, Mountain Passes, Border Crossings, Bridges & Tunnels, DriveBC Highways
Sub-category filters appear when a source is selected (e.g., select BC Ferries ‚Üí see Tsawwassen, Swartz Bay, etc.)
Highway filter for highway cameras

Visual Indicators:

Source icons on each card (‚õ¥Ô∏è üèîÔ∏è ‚õ∑Ô∏è etc.)
Category labels below each camera name

Copy this into Replit and let me know how the smart categorization works!

---

Copy this into Replit. The filters will now intelligently parse your webcam names to create meaningful categories! Let me know how it looks. üì∑