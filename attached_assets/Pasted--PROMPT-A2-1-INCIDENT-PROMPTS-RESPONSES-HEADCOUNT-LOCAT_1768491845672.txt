# PROMPT A2.1 — INCIDENT PROMPTS & RESPONSES (HEADCOUNT + LOCATION + ACK)
# “5,000 users in 15 minutes” onboarding vector + incident command telemetry
# BUILD IT RIGHT. BUILD IT NOW. NO REFACTOR LATER.

You are working in the Community Canvas V3.3.x codebase on Replit.
Runtime: Replit Postgres (Neon-backed), Drizzle, RLS via GUCs:
- app.tenant_id, app.portal_id, app.individual_id, app.circle_id
Service mode sentinel: '__SERVICE__' (already used in repo helpers).

We already have:
- cc_incidents (from A2)
- cc_record_bundles + cc_contemporaneous_notes (A2.X)
- circle-aware messaging (A1/A1.1)
- activity ledger with portal_id/circle_id columns

This prompt adds ONLY:
1) Schema + RLS for incident prompts/responses
2) API routes to create prompts, answer prompts, and view response summaries
3) Minimal “respond” endpoint designed for public/guest onboarding (link-first)
4) QA docs

Do NOT build full emergency templates here (that’s A2.2).
Do NOT build emergency circle escalation here (that’s A2.3).

---

# GOAL

During an incident, authorized operators can send structured prompts:
- “Where are you right now?” (preset locations or GPS pin)
- “How many adults/children in your party?”
- “Are you safe?” / “Do you need help?”
- “Confirm you received this alert”

Recipients (guests/staff/public) can respond quickly via a link.
Responses are:
- machine-readable
- attributable (when known)
- usable for situational awareness dashboards
- includable in defensive bundles later (Prompt 2)

---

# DELIVERABLES (NO EXCEPTIONS)

## 1) MIGRATION
Create:
`server/migrations/129_incident_prompts_and_responses.sql`

Follow repo patterns:
- idempotent enum creation
- CREATE TABLE IF NOT EXISTS
- updated_at trigger where relevant
- RLS enabled, FORCE where sensitive
- GRANT as per other migrations
- helper functions only if absolutely necessary

### 1.1 ENUMS (IDEMPOTENT)

Create enums:

- `cc_incident_prompt_type_enum`:
  - 'headcount'
  - 'location'
  - 'status'
  - 'acknowledge'
  - 'freeform'
  - 'medical_dependency'   -- e.g., CPAP, oxygen, insulin refrigeration
  - 'resource_need'        -- water, flashlight, fuel, generator, tow, etc.

- `cc_incident_prompt_target_enum`:
  - 'individual'
  - 'party'
  - 'tenant'
  - 'circle'
  - 'portal'
  - 'public_link'          -- anonymous/guest responders via token link

- `cc_incident_response_channel_enum`:
  - 'web'
  - 'sms'
  - 'in_app'
  - 'operator_entry'       -- staff enters response on behalf of guest
  - 'api'

- `cc_incident_response_state_enum`:
  - 'submitted'
  - 'updated'
  - 'voided'               -- for spam/abuse moderation; keep record

---

### 1.2 TABLE: cc_incident_prompts

Purpose: prompt definition + distribution contract (one prompt → many responses).

Columns:
- `id uuid pk default gen_random_uuid()`
- `tenant_id uuid not null references cc_tenants(id) on delete cascade`
- `community_id uuid null references cc_communities(id) on delete set null`
- `portal_id uuid null references cc_portals(id) on delete set null`
- `circle_id uuid null references cc_coordination_circles(id) on delete set null`
- `incident_id uuid not null references cc_incidents(id) on delete cascade`

Prompt:
- `prompt_type cc_incident_prompt_type_enum not null`
- `title text null`
- `prompt_text text not null`
- `is_required boolean not null default false`
- `expires_at timestamptz null`

Response schema (for UI + validation):
- `options jsonb null`               -- multiple choice / preset locations, etc.
- `validation jsonb null`            -- e.g. { minAdults:0, maxAdults:20 }

Targeting:
- `target_type cc_incident_prompt_target_enum not null default 'public_link'`
- `target_individual_id uuid null references cc_individuals(id) on delete set null`
- `target_party_id uuid null references cc_parties(id) on delete set null`
- `target_tenant_id uuid null references cc_tenants(id) on delete set null`
- `target_circle_id uuid null references cc_coordination_circles(id) on delete set null`
- `target_portal_id uuid null references cc_portals(id) on delete set null`

Public link token (for onboarding):
- `public_token_hash text null`          -- store hash only (NEVER raw token)
- `public_token_alg text not null default 'sha256'`
- `public_token_expires_at timestamptz null`
- `max_responses integer null`           -- optional throttle

Audit:
- `created_by_individual_id uuid null references cc_individuals(id) on delete set null`
- `created_at timestamptz not null default now()`
- `updated_at timestamptz not null default now()`
- `is_active boolean not null default true`

Constraints (CHECKs):
A) Target pointer must match target_type, OR target_type='public_link' requires public_token_hash NOT NULL.
   - If target_type='individual' → target_individual_id NOT NULL
   - 'party' → target_party_id NOT NULL
   - 'tenant' → target_tenant_id NOT NULL
   - 'circle' → target_circle_id NOT NULL
   - 'portal' → target_portal_id NOT NULL
   - 'public_link' → public_token_hash NOT NULL
B) If public_token_hash is not null, public_token_expires_at may be null (meaning never), but expires is preferred.

Indexes:
- (incident_id, created_at desc)
- (tenant_id, created_at desc)
- (public_token_hash) where public_token_hash is not null
- (expires_at) where expires_at is not null

Trigger:
- updated_at via cc_set_updated_at()

RLS:
- SELECT: incident operators (tenant/circle context) + service mode
- INSERT/UPDATE/DEACTIVATE: service mode OR incident operators only
- DELETE: service mode only
(Use your existing operator model. If uncertain, lock writes to service mode + tenant admins only.)

FORCE ROW LEVEL SECURITY (recommended)

---

### 1.3 TABLE: cc_incident_responses

Purpose: store structured responses (including location + headcount + ack) with dedupe.

Columns:
- `id uuid pk default gen_random_uuid()`
- `tenant_id uuid not null references cc_tenants(id) on delete cascade`
- `community_id uuid null references cc_communities(id) on delete set null`
- `portal_id uuid null references cc_portals(id) on delete set null`
- `circle_id uuid null references cc_coordination_circles(id) on delete set null`
- `incident_id uuid not null references cc_incidents(id) on delete cascade`
- `prompt_id uuid not null references cc_incident_prompts(id) on delete cascade`

Responder identity (nullable for guests):
- `respondent_individual_id uuid null references cc_individuals(id) on delete set null`
- `respondent_party_id uuid null references cc_parties(id) on delete set null`
- `respondent_tenant_id uuid null references cc_tenants(id) on delete set null`

Public responder fingerprinting:
- `public_responder_key text null`       -- derived client-side or server-issued (NOT PII)
- `public_token_hash text null`          -- echoes prompt public token hash for linkage

Response:
- `response_data jsonb not null`         -- canonical payload
- `response_channel cc_incident_response_channel_enum not null default 'web'`
- `state cc_incident_response_state_enum not null default 'submitted'`

Location fields (optional but first-class):
- `location_label text null`             -- “Brady’s Beach”, “Cottage 3”
- `location_lat numeric null`
- `location_lng numeric null`
- `location_accuracy_m numeric null`

Headcount helpers (optional):
- `adults_count integer null`
- `children_count integer null`
- `pets_count integer null`

Timing:
- `occurred_at timestamptz not null default now()`   -- time responder reports situation
- `responded_at timestamptz not null default now()`  -- time received
- `updated_at timestamptz not null default now()`

Attribution:
- `entered_by_individual_id uuid null references cc_individuals(id) on delete set null`  -- if operator_entry

Anti-spam:
- `ip_hash text null`
- `user_agent_hash text null`

Constraints:
A) prompt_id must belong to incident_id (enforce via FK? use trigger or accept app-level check in route).
B) One-response-per (prompt_id + respondent_individual_id) when individual known.
C) For public responders: one-response-per (prompt_id + public_responder_key) if present.

Implement uniqueness via partial unique indexes:
- UNIQUE(prompt_id, respondent_individual_id) WHERE respondent_individual_id IS NOT NULL
- UNIQUE(prompt_id, public_responder_key) WHERE public_responder_key IS NOT NULL

Indexes:
- (incident_id, responded_at desc)
- (prompt_id, responded_at desc)
- (tenant_id, responded_at desc)

Trigger:
- updated_at via cc_set_updated_at()

RLS:
- INSERT: allow (a) service mode OR (b) public link responses via SECURITY DEFINER function (see below) OR (c) authenticated individuals in tenant/circle context
- SELECT: incident operators + service mode
- UPDATE: service mode OR incident operators for moderation (state voided), but never delete

FORCE ROW LEVEL SECURITY (recommended)

---

### 1.4 SECURITY DEFINER FUNCTION: submit_incident_response_public(...)
We need a safe way to accept public responses without giving broad INSERT privileges under RLS.

Create a SECURITY DEFINER function that:
- Accepts: prompt_public_token (raw), response_data jsonb, optional location fields, optional headcount fields, optional public_responder_key
- Hashes the token and finds active prompt where public_token_hash matches and not expired
- Inserts into cc_incident_responses with:
  - tenant/community/portal/circle/incident/prompt derived from prompt
  - respondent fields null
  - response_channel='web'
  - public_token_hash set
  - public_responder_key set
- Returns: response id + incident id + prompt id

Hardening:
- SET search_path = public, pg_temp
- Rate limiting is application layer later; here rely on max_responses + dedupe indexes
- If prompt is expired or inactive → error
- If max_responses reached → error
- Ensure it does NOT allow selecting other data

GRANT EXECUTE to your app role (same pattern as other SECURITY DEFINER functions).

NOTE: This is the key to “click link → respond → become user later”.

---

### 1.5 ACTIVITY LEDGER LOGGING
We already have cc_activity_ledger. Add logging in routes, not in migration:
- 'incident_prompt.create'
- 'incident_response.submit'
- 'incident_response.void'

Ensure portal_id/circle_id captured via columns already added.

---

## 2) API ROUTES

Create:
`server/routes/incident-prompts.ts`
Register routes under:
- `/api/incidents/:incidentId/prompts`
- `/api/incidents/:incidentId/responses`
- `/api/public/incident-prompts/:token/respond`  (public responder endpoint)

Use repo conventions:
- authenticateToken where needed
- tenantQuery for RLS testing on authenticated endpoints
- serviceQuery only for privileged operator actions if necessary

### 2.1 Authenticated operator endpoints

#### POST /api/incidents/:incidentId/prompts
Creates a prompt.
Body:
{
  promptType,
  title?,
  promptText,
  isRequired?,
  expiresAt?,
  options?,
  validation?,
  targetType,                    // 'public_link' default
  targetIndividualId?,
  targetPartyId?,
  targetTenantId?,
  targetCircleId?,
  targetPortalId?,
  publicTokenTtlMinutes?,        // if public_link
  maxResponses?
}

Behavior:
- Validate incident exists and caller has operator permission for that incident context
- If targetType='public_link':
  - generate random token (32+ bytes)
  - store ONLY hash in DB
  - return raw token ONCE in response (never store raw)
  - return responseLink: `/api/public/incident-prompts/{token}/respond` or front-end link if you have one
- Insert prompt with tenant/community/portal/circle derived from current context and/or incident record
- Ledger log: incident_prompt.create

Return:
{ success:true, data:{ prompt, publicToken?, responseLink? } }

#### GET /api/incidents/:incidentId/prompts
Lists active prompts for incident (for operator).
Return prompts WITHOUT token hash (never expose), but include:
- target_type
- expires_at
- response counts (optional query)

#### GET /api/incidents/:incidentId/responses
Operator view:
- filters: promptId, state
- returns responses with structured fields
- include rollups:
  - total responders
  - total adults/children
  - responders by location_label (top N)
  - responders needing help (if status prompt)

Ledger log NOT needed on read.

#### POST /api/incidents/:incidentId/responses/:responseId/void
Moderation:
Body: { reason? }
Sets state='voided'
Ledger log: incident_response.void

---

### 2.2 Public responder endpoint (guest onboarding)

#### POST /api/public/incident-prompts/:token/respond
NO AUTH REQUIRED.

Body:
{
  responseData,                  // json object
  occurredAt?,                   // optional client timestamp
  publicResponderKey?,           // optional stable random key stored client-side (not PII)
  locationLabel?,
  locationLat?,
  locationLng?,
  locationAccuracyM?,
  adultsCount?,
  childrenCount?,
  petsCount?
}

Behavior:
- Call SECURITY DEFINER function submit_incident_response_public(...)
- Return minimal success payload:
  { success:true, incidentId, promptId, responseId }
- If you want to drive onboarding, include:
  { next: { type:'invite', message:'Thanks — you can create an account to receive updates' } }
but keep it minimal for now.

IMPORTANT:
- Do NOT leak incident details publicly from this endpoint beyond ids.
- Do NOT return lists.

---

## 3) SERVER UTILITIES

Add:
`server/lib/tokenHash.ts`
- sha256 hashing helper (hex)
- constant-time comparison not needed since we only hash + lookup

If repo already has hashing helpers, reuse them.

---

## 4) QA DOC

Create:
`docs/qa/PHASE_A2_1_INCIDENT_PROMPTS_RESPONSES_QA.md`

Include:

### Migration verification SQL
- enums exist
- tables exist
- RLS enabled
- policies present
- public function exists

### API checks
1) Create public_link prompt
2) Respond via token link twice with same publicResponderKey → second should conflict (unique)
3) Operator lists responses → sees aggregated totals
4) Expire prompt → public responses rejected
5) Void response → no delete, state changes

---

# ACCEPTANCE CRITERIA
- Migration 129 runs cleanly on Replit
- Public link prompt creation returns token once
- Public responder endpoint inserts response without auth
- Operator endpoints are protected and RLS-tested
- Deduping works via partial unique indexes
- No token hashes ever returned in operator GETs
- Activity ledger logs create/submit/void with portal_id/circle_id attribution

Proceed now. Keep diffs minimal. Align to repo conventions.
