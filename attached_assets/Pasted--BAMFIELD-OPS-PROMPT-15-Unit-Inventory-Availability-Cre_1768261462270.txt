**BAMFIELD OPS - PROMPT 15: Unit Inventory & Availability**

Create the calendar-based availability system with blocking, seasonal rates, and iCal sync support.

## Migration 091_unit_availability.sql
```sql
BEGIN;

-- ============ UNIT AVAILABILITY CALENDAR ============
-- Day-by-day availability and pricing overrides

CREATE TABLE IF NOT EXISTS cc_unit_calendar (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  unit_id uuid NOT NULL REFERENCES cc_units(id) ON DELETE CASCADE,
  
  -- Date
  calendar_date date NOT NULL,
  
  -- Availability
  availability varchar DEFAULT 'available' CHECK (availability IN (
    'available',      -- Open for booking
    'booked',         -- Has a reservation
    'blocked',        -- Manually blocked
    'owner_use',      -- Owner using
    'maintenance',    -- Under maintenance
    'seasonal_close'  -- Seasonally closed
  )),
  
  -- Pricing override (if different from unit default)
  rate_cad numeric(10,2),
  min_stay_nights integer,
  
  -- Source
  source varchar DEFAULT 'manual' CHECK (source IN (
    'manual',         -- Manually set
    'reservation',    -- From PMS reservation
    'ical_import',    -- From iCal sync
    'seasonal_rule',  -- From seasonal rule
    'dynamic'         -- Dynamic pricing
  )),
  source_id uuid,     -- Reference to reservation, ical event, etc.
  source_ref text,    -- External reference (iCal UID, etc.)
  
  -- Block info
  block_reason text,
  blocked_by text,
  blocked_at timestamptz,
  
  -- Notes
  notes text,
  
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  
  UNIQUE(unit_id, calendar_date)
);

CREATE INDEX idx_unit_calendar_unit_date ON cc_unit_calendar(unit_id, calendar_date);
CREATE INDEX idx_unit_calendar_availability ON cc_unit_calendar(calendar_date, availability);
CREATE INDEX idx_unit_calendar_source ON cc_unit_calendar(source_id) WHERE source_id IS NOT NULL;

ALTER TABLE cc_unit_calendar ENABLE ROW LEVEL SECURITY;

-- ============ SEASONAL PRICING RULES ============
-- Reusable pricing rules for date ranges

CREATE TABLE IF NOT EXISTS cc_seasonal_rules (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Links (can apply to property or specific unit)
  portal_id uuid REFERENCES cc_portals(id) ON DELETE SET NULL,
  property_id uuid REFERENCES cc_properties(id) ON DELETE CASCADE,
  unit_id uuid REFERENCES cc_units(id) ON DELETE CASCADE,
  
  -- Identity
  name text NOT NULL,
  code varchar(20),
  
  -- Date range (can be annual pattern or specific dates)
  start_date date,      -- Specific date or NULL for annual
  end_date date,
  start_month integer,  -- 1-12 for annual pattern
  start_day integer,    -- 1-31
  end_month integer,
  end_day integer,
  
  -- Pricing
  rate_type varchar DEFAULT 'fixed' CHECK (rate_type IN (
    'fixed',          -- Fixed rate
    'multiplier',     -- Multiply base rate
    'adjustment'      -- Add/subtract from base
  )),
  rate_value numeric(10,2),  -- The rate, multiplier, or adjustment amount
  
  -- Stay rules
  min_stay_nights integer,
  max_stay_nights integer,
  
  -- Booking rules
  booking_window_days integer,  -- How far in advance can book
  no_check_in_days integer[],   -- Days of week no check-in (0=Sun, 6=Sat)
  no_check_out_days integer[],
  
  -- Priority (higher = takes precedence)
  priority integer DEFAULT 0,
  
  -- Status
  status varchar DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'draft')),
  
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

CREATE INDEX idx_seasonal_rules_property ON cc_seasonal_rules(property_id) WHERE property_id IS NOT NULL;
CREATE INDEX idx_seasonal_rules_unit ON cc_seasonal_rules(unit_id) WHERE unit_id IS NOT NULL;
CREATE INDEX idx_seasonal_rules_dates ON cc_seasonal_rules(start_month, end_month) WHERE start_month IS NOT NULL;

ALTER TABLE cc_seasonal_rules ENABLE ROW LEVEL SECURITY;

-- ============ ICAL SYNC LOG ============
-- Track iCal imports/exports

CREATE TABLE IF NOT EXISTS cc_ical_sync_log (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  unit_id uuid NOT NULL REFERENCES cc_units(id) ON DELETE CASCADE,
  
  -- Sync details
  sync_direction varchar NOT NULL CHECK (sync_direction IN ('import', 'export')),
  sync_url text,
  
  -- Results
  status varchar DEFAULT 'pending' CHECK (status IN (
    'pending', 'in_progress', 'completed', 'failed'
  )),
  
  events_found integer DEFAULT 0,
  events_created integer DEFAULT 0,
  events_updated integer DEFAULT 0,
  events_removed integer DEFAULT 0,
  
  -- Error tracking
  error_message text,
  error_details jsonb,
  
  started_at timestamptz DEFAULT now(),
  completed_at timestamptz
);

CREATE INDEX idx_ical_sync_unit ON cc_ical_sync_log(unit_id, started_at DESC);

ALTER TABLE cc_ical_sync_log ENABLE ROW LEVEL SECURITY;

-- ============ SEED SEASONAL RULES FOR BAMFIELD ============

DO $$
DECLARE
  v_portal_id uuid;
  v_lodge_id uuid;
  v_camp_id uuid;
BEGIN
  SELECT id INTO v_portal_id FROM cc_portals WHERE slug = 'bamfield' LIMIT 1;
  SELECT id INTO v_lodge_id FROM cc_properties WHERE code = 'BFLD-LODGE' LIMIT 1;
  SELECT id INTO v_camp_id FROM cc_properties WHERE code = 'PACH-CAMP' LIMIT 1;
  
  -- Peak Summer for Lodge (July-August)
  IF v_lodge_id IS NOT NULL THEN
    INSERT INTO cc_seasonal_rules (
      portal_id, property_id, name, code,
      start_month, start_day, end_month, end_day,
      rate_type, rate_value, min_stay_nights, priority, status
    ) VALUES (
      v_portal_id, v_lodge_id, 'Peak Summer', 'PEAK-SUM',
      7, 1, 8, 31,
      'multiplier', 1.5, 2, 10, 'active'
    ) ON CONFLICT DO NOTHING;
    
    -- Shoulder Season (May-June, September)
    INSERT INTO cc_seasonal_rules (
      portal_id, property_id, name, code,
      start_month, start_day, end_month, end_day,
      rate_type, rate_value, min_stay_nights, priority, status
    ) VALUES (
      v_portal_id, v_lodge_id, 'Shoulder Season', 'SHOULDER',
      5, 1, 6, 30,
      'multiplier', 1.2, 1, 5, 'active'
    ) ON CONFLICT DO NOTHING;
    
    -- Winter Low Season (November-March)
    INSERT INTO cc_seasonal_rules (
      portal_id, property_id, name, code,
      start_month, start_day, end_month, end_day,
      rate_type, rate_value, min_stay_nights, priority, status
    ) VALUES (
      v_portal_id, v_lodge_id, 'Winter Value', 'WINTER',
      11, 1, 3, 31,
      'multiplier', 0.8, 1, 5, 'active'
    ) ON CONFLICT DO NOTHING;
  END IF;
  
  -- Holiday Premium
  IF v_portal_id IS NOT NULL THEN
    INSERT INTO cc_seasonal_rules (
      portal_id, name, code,
      start_date, end_date,
      rate_type, rate_value, min_stay_nights, priority, status
    ) VALUES (
      v_portal_id, 'BC Day Weekend', 'BCDAY',
      '2026-08-01', '2026-08-03',
      'multiplier', 1.75, 3, 20, 'active'
    ) ON CONFLICT DO NOTHING;
    
    INSERT INTO cc_seasonal_rules (
      portal_id, name, code,
      start_date, end_date,
      rate_type, rate_value, min_stay_nights, priority, status
    ) VALUES (
      v_portal_id, 'Labour Day Weekend', 'LABOUR',
      '2026-09-05', '2026-09-07',
      'multiplier', 1.5, 2, 20, 'active'
    ) ON CONFLICT DO NOTHING;
  END IF;
END $$;

COMMIT;
```

## Create server/services/availabilityService.ts
```typescript
// server/services/availabilityService.ts

import { db } from '../db';
import { eq, and, gte, lte, asc, desc, sql, or, inArray } from 'drizzle-orm';
import { logActivity } from './activityService';

// ============ TYPES ============

interface CalendarDay {
  date: string;
  availability: string;
  rateCad: number;
  minStayNights: number;
  source: string;
  notes?: string;
  reservationId?: string;
}

interface BlockDatesRequest {
  portalSlug: string;
  unitId: string;
  startDate: Date;
  endDate: Date;
  availability: string;
  reason?: string;
  blockedBy?: string;
}

// ============ CALENDAR FUNCTIONS ============

export async function getUnitCalendar(
  portalSlug: string,
  unitId: string,
  startDate: Date,
  endDate: Date
): Promise<CalendarDay[]> {
  // Validate unit belongs to portal
  const unit = await db.query.ccUnits.findFirst({
    where: eq(ccUnits.id, unitId)
  });
  
  if (!unit) return [];
  
  const property = await db.query.ccProperties.findFirst({
    where: eq(ccProperties.id, unit.propertyId)
  });
  
  if (!property) return [];
  
  const portal = await db.query.ccPortals.findFirst({
    where: eq(ccPortals.slug, portalSlug)
  });
  
  if (!portal || property.portalId !== portal.id) return [];
  
  // Get base rate
  const baseRate = Number(unit.baseRateCad) || Number(property.baseRateCad) || 0;
  
  // Get calendar entries
  const calendarEntries = await db.query.ccUnitCalendar.findMany({
    where: and(
      eq(ccUnitCalendar.unitId, unitId),
      gte(ccUnitCalendar.calendarDate, startDate),
      lte(ccUnitCalendar.calendarDate, endDate)
    ),
    orderBy: [asc(ccUnitCalendar.calendarDate)]
  });
  
  // Get seasonal rules that might apply
  const rules = await getApplicableRules(portalSlug, property.id, unitId, startDate, endDate);
  
  // Build calendar days
  const calendar: CalendarDay[] = [];
  const current = new Date(startDate);
  const end = new Date(endDate);
  
  while (current <= end) {
    const dateStr = current.toISOString().split('T')[0];
    const entry = calendarEntries.find(e => 
      e.calendarDate.toISOString().split('T')[0] === dateStr
    );
    
    // Calculate rate for this day
    const { rate, minStay } = calculateDayRate(current, baseRate, rules);
    
    calendar.push({
      date: dateStr,
      availability: entry?.availability || 'available',
      rateCad: entry?.rateCad || rate,
      minStayNights: entry?.minStayNights || minStay || 1,
      source: entry?.source || 'default',
      notes: entry?.notes,
      reservationId: entry?.sourceId
    });
    
    current.setDate(current.getDate() + 1);
  }
  
  return calendar;
}

async function getApplicableRules(
  portalSlug: string,
  propertyId: string,
  unitId: string,
  startDate: Date,
  endDate: Date
): Promise<any[]> {
  const portal = await db.query.ccPortals.findFirst({
    where: eq(ccPortals.slug, portalSlug)
  });
  
  if (!portal) return [];
  
  // Get rules that could apply (portal-wide, property, or unit specific)
  const rules = await db.query.ccSeasonalRules.findMany({
    where: and(
      eq(ccSeasonalRules.status, 'active'),
      or(
        eq(ccSeasonalRules.portalId, portal.id),
        eq(ccSeasonalRules.propertyId, propertyId),
        eq(ccSeasonalRules.unitId, unitId)
      )
    ),
    orderBy: [desc(ccSeasonalRules.priority)]
  });
  
  return rules;
}

function calculateDayRate(
  date: Date,
  baseRate: number,
  rules: any[]
): { rate: number; minStay: number | null } {
  const month = date.getMonth() + 1;
  const day = date.getDate();
  const dateStr = date.toISOString().split('T')[0];
  
  let rate = baseRate;
  let minStay: number | null = null;
  
  // Apply rules in priority order (highest priority wins)
  for (const rule of rules) {
    let applies = false;
    
    // Check specific date range
    if (rule.startDate && rule.endDate) {
      const ruleStart = rule.startDate.toISOString().split('T')[0];
      const ruleEnd = rule.endDate.toISOString().split('T')[0];
      applies = dateStr >= ruleStart && dateStr <= ruleEnd;
    }
    // Check annual pattern
    else if (rule.startMonth && rule.endMonth) {
      if (rule.startMonth <= rule.endMonth) {
        // Simple range (e.g., May-August)
        applies = month >= rule.startMonth && month <= rule.endMonth;
        if (applies && rule.startDay && month === rule.startMonth) {
          applies = day >= rule.startDay;
        }
        if (applies && rule.endDay && month === rule.endMonth) {
          applies = day <= rule.endDay;
        }
      } else {
        // Wrapping range (e.g., November-March)
        applies = month >= rule.startMonth || month <= rule.endMonth;
      }
    }
    
    if (applies) {
      // Apply rate
      if (rule.rateType === 'fixed') {
        rate = Number(rule.rateValue);
      } else if (rule.rateType === 'multiplier') {
        rate = baseRate * Number(rule.rateValue);
      } else if (rule.rateType === 'adjustment') {
        rate = baseRate + Number(rule.rateValue);
      }
      
      // Apply min stay
      if (rule.minStayNights) {
        minStay = rule.minStayNights;
      }
      
      // First matching rule wins (highest priority)
      break;
    }
  }
  
  return { rate: Math.round(rate * 100) / 100, minStay };
}

// ============ BLOCKING FUNCTIONS ============

export async function blockDates(req: BlockDatesRequest): Promise<any[]> {
  const portal = await db.query.ccPortals.findFirst({
    where: eq(ccPortals.slug, req.portalSlug)
  });
  
  if (!portal) throw new Error('Portal not found');
  
  // Validate unit belongs to portal
  const unit = await db.query.ccUnits.findFirst({
    where: eq(ccUnits.id, req.unitId)
  });
  
  if (!unit) throw new Error('Unit not found');
  
  const property = await db.query.ccProperties.findFirst({
    where: eq(ccProperties.id, unit.propertyId)
  });
  
  if (!property || property.portalId !== portal.id) {
    throw new Error('Unit does not belong to this portal');
  }
  
  const blocked: any[] = [];
  const current = new Date(req.startDate);
  const end = new Date(req.endDate);
  
  while (current <= end) {
    const dateStr = current.toISOString().split('T')[0];
    
    // Upsert calendar entry
    const [entry] = await db.insert(ccUnitCalendar)
      .values({
        unitId: req.unitId,
        calendarDate: new Date(dateStr),
        availability: req.availability,
        source: 'manual',
        blockReason: req.reason,
        blockedBy: req.blockedBy,
        blockedAt: new Date()
      })
      .onConflictDoUpdate({
        target: [ccUnitCalendar.unitId, ccUnitCalendar.calendarDate],
        set: {
          availability: req.availability,
          source: 'manual',
          blockReason: req.reason,
          blockedBy: req.blockedBy,
          blockedAt: new Date(),
          updatedAt: new Date()
        }
      })
      .returning();
    
    blocked.push(entry);
    current.setDate(current.getDate() + 1);
  }
  
  await logActivity({
    tenantId: 'system',
    actorId: req.blockedBy || 'system',
    action: 'unit.dates_blocked',
    resourceType: 'unit',
    resourceId: req.unitId,
    metadata: {
      startDate: req.startDate,
      endDate: req.endDate,
      availability: req.availability,
      daysBlocked: blocked.length
    }
  });
  
  return blocked;
}

export async function unblockDates(
  portalSlug: string,
  unitId: string,
  startDate: Date,
  endDate: Date
): Promise<number> {
  const portal = await db.query.ccPortals.findFirst({
    where: eq(ccPortals.slug, portalSlug)
  });
  
  if (!portal) throw new Error('Portal not found');
  
  // Validate unit belongs to portal
  const unit = await db.query.ccUnits.findFirst({
    where: eq(ccUnits.id, unitId)
  });
  
  if (!unit) throw new Error('Unit not found');
  
  const property = await db.query.ccProperties.findFirst({
    where: eq(ccProperties.id, unit.propertyId)
  });
  
  if (!property || property.portalId !== portal.id) {
    throw new Error('Unit does not belong to this portal');
  }
  
  // Delete manual blocks (not reservation-based)
  const result = await db.delete(ccUnitCalendar)
    .where(and(
      eq(ccUnitCalendar.unitId, unitId),
      gte(ccUnitCalendar.calendarDate, startDate),
      lte(ccUnitCalendar.calendarDate, endDate),
      eq(ccUnitCalendar.source, 'manual')
    ))
    .returning();
  
  return result.length;
}

// ============ SYNC CALENDAR FROM RESERVATION ============

export async function syncReservationToCalendar(
  reservationId: string
): Promise<void> {
  const reservation = await db.query.ccPmsReservations.findFirst({
    where: eq(ccPmsReservations.id, reservationId)
  });
  
  if (!reservation) return;
  
  const availability = ['cancelled', 'no_show'].includes(reservation.status) 
    ? 'available' 
    : 'booked';
  
  const current = new Date(reservation.checkInDate);
  const end = new Date(reservation.checkOutDate);
  end.setDate(end.getDate() - 1); // Don't block checkout day
  
  while (current <= end) {
    await db.insert(ccUnitCalendar)
      .values({
        unitId: reservation.unitId,
        calendarDate: new Date(current),
        availability,
        source: 'reservation',
        sourceId: reservation.id,
        sourceRef: reservation.confirmationNumber
      })
      .onConflictDoUpdate({
        target: [ccUnitCalendar.unitId, ccUnitCalendar.calendarDate],
        set: {
          availability,
          source: 'reservation',
          sourceId: reservation.id,
          sourceRef: reservation.confirmationNumber,
          updatedAt: new Date()
        }
      });
    
    current.setDate(current.getDate() + 1);
  }
}

// ============ MULTI-UNIT AVAILABILITY ============

export async function getPropertyAvailability(
  portalSlug: string,
  propertyId: string,
  startDate: Date,
  endDate: Date
): Promise<{
  property: any;
  unitAvailability: {
    unit: any;
    availableDates: string[];
    blockedDates: string[];
    bookedDates: string[];
  }[];
  summary: {
    totalUnits: number;
    fullyAvailable: number;
    partiallyAvailable: number;
    fullyBooked: number;
  };
}> {
  const portal = await db.query.ccPortals.findFirst({
    where: eq(ccPortals.slug, portalSlug)
  });
  
  if (!portal) {
    return {
      property: null,
      unitAvailability: [],
      summary: { totalUnits: 0, fullyAvailable: 0, partiallyAvailable: 0, fullyBooked: 0 }
    };
  }
  
  const property = await db.query.ccProperties.findFirst({
    where: and(
      eq(ccProperties.id, propertyId),
      eq(ccProperties.portalId, portal.id)
    )
  });
  
  if (!property) {
    return {
      property: null,
      unitAvailability: [],
      summary: { totalUnits: 0, fullyAvailable: 0, partiallyAvailable: 0, fullyBooked: 0 }
    };
  }
  
  const units = await db.query.ccUnits.findMany({
    where: eq(ccUnits.propertyId, propertyId),
    orderBy: [asc(ccUnits.sortOrder), asc(ccUnits.name)]
  });
  
  const unitAvailability: any[] = [];
  let fullyAvailable = 0;
  let partiallyAvailable = 0;
  let fullyBooked = 0;
  
  const totalDays = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)) + 1;
  
  for (const unit of units) {
    const calendar = await getUnitCalendar(portalSlug, unit.id, startDate, endDate);
    
    const availableDates = calendar.filter(d => d.availability === 'available').map(d => d.date);
    const blockedDates = calendar.filter(d => ['blocked', 'owner_use', 'maintenance', 'seasonal_close'].includes(d.availability)).map(d => d.date);
    const bookedDates = calendar.filter(d => d.availability === 'booked').map(d => d.date);
    
    unitAvailability.push({
      unit,
      availableDates,
      blockedDates,
      bookedDates
    });
    
    if (availableDates.length === totalDays) {
      fullyAvailable++;
    } else if (bookedDates.length + blockedDates.length === totalDays) {
      fullyBooked++;
    } else {
      partiallyAvailable++;
    }
  }
  
  return {
    property,
    unitAvailability,
    summary: {
      totalUnits: units.length,
      fullyAvailable,
      partiallyAvailable,
      fullyBooked
    }
  };
}

// ============ SEASONAL RULES MANAGEMENT ============

export async function getSeasonalRules(
  portalSlug: string,
  propertyId?: string
): Promise<any[]> {
  const portal = await db.query.ccPortals.findFirst({
    where: eq(ccPortals.slug, portalSlug)
  });
  
  if (!portal) return [];
  
  const conditions: any[] = [eq(ccSeasonalRules.portalId, portal.id)];
  
  if (propertyId) {
    conditions.push(
      or(
        eq(ccSeasonalRules.propertyId, propertyId),
        sql`${ccSeasonalRules.propertyId} IS NULL`
      )
    );
  }
  
  return db.query.ccSeasonalRules.findMany({
    where: and(...conditions),
    orderBy: [desc(ccSeasonalRules.priority), asc(ccSeasonalRules.name)]
  });
}

export async function createSeasonalRule(
  portalSlug: string,
  data: {
    propertyId?: string;
    unitId?: string;
    name: string;
    code?: string;
    startDate?: Date;
    endDate?: Date;
    startMonth?: number;
    startDay?: number;
    endMonth?: number;
    endDay?: number;
    rateType: string;
    rateValue: number;
    minStayNights?: number;
    priority?: number;
  }
): Promise<any> {
  const portal = await db.query.ccPortals.findFirst({
    where: eq(ccPortals.slug, portalSlug)
  });
  
  if (!portal) throw new Error('Portal not found');
  
  const [rule] = await db.insert(ccSeasonalRules).values({
    portalId: portal.id,
    propertyId: data.propertyId,
    unitId: data.unitId,
    name: data.name,
    code: data.code,
    startDate: data.startDate,
    endDate: data.endDate,
    startMonth: data.startMonth,
    startDay: data.startDay,
    endMonth: data.endMonth,
    endDay: data.endDay,
    rateType: data.rateType,
    rateValue: data.rateValue,
    minStayNights: data.minStayNights,
    priority: data.priority || 0,
    status: 'active'
  }).returning();
  
  return rule;
}
```

## Add Availability Routes to pms.ts
```typescript
// Add to server/routes/pms.ts

import {
  getUnitCalendar, blockDates, unblockDates, syncReservationToCalendar,
  getPropertyAvailability, getSeasonalRules, createSeasonalRule
} from '../services/availabilityService';

// ============ CALENDAR ENDPOINTS ============

// GET /api/pms/portals/:slug/units/:unitId/calendar - Get unit calendar
router.get('/portals/:slug/units/:unitId/calendar', async (req, res) => {
  const { slug, unitId } = req.params;
  const { start, end } = req.query;
  
  if (!start || !end) {
    return res.status(400).json({ error: 'start and end dates required' });
  }
  
  try {
    const calendar = await getUnitCalendar(
      slug, 
      unitId, 
      new Date(start as string), 
      new Date(end as string)
    );
    
    res.json({ calendar, count: calendar.length });
  } catch (e: any) {
    console.error('Get calendar error:', e);
    res.status(500).json({ error: 'Failed to get calendar' });
  }
});

// POST /api/pms/portals/:slug/units/:unitId/block - Block dates
router.post('/portals/:slug/units/:unitId/block', async (req, res) => {
  const { slug, unitId } = req.params;
  const { startDate, endDate, availability, reason, blockedBy } = req.body || {};
  
  if (!startDate || !endDate) {
    return res.status(400).json({ error: 'startDate and endDate required' });
  }
  
  try {
    const blocked = await blockDates({
      portalSlug: slug,
      unitId,
      startDate: new Date(startDate),
      endDate: new Date(endDate),
      availability: availability || 'blocked',
      reason,
      blockedBy
    });
    
    res.json({ blocked, count: blocked.length });
  } catch (e: any) {
    console.error('Block dates error:', e);
    res.status(400).json({ error: e.message });
  }
});

// POST /api/pms/portals/:slug/units/:unitId/unblock - Unblock dates
router.post('/portals/:slug/units/:unitId/unblock', async (req, res) => {
  const { slug, unitId } = req.params;
  const { startDate, endDate } = req.body || {};
  
  if (!startDate || !endDate) {
    return res.status(400).json({ error: 'startDate and endDate required' });
  }
  
  try {
    const count = await unblockDates(
      slug,
      unitId,
      new Date(startDate),
      new Date(endDate)
    );
    
    res.json({ unblocked: count });
  } catch (e: any) {
    console.error('Unblock dates error:', e);
    res.status(400).json({ error: e.message });
  }
});

// GET /api/pms/portals/:slug/properties/:propertyId/availability - Property availability
router.get('/portals/:slug/properties/:propertyId/availability', async (req, res) => {
  const { slug, propertyId } = req.params;
  const { start, end } = req.query;
  
  if (!start || !end) {
    return res.status(400).json({ error: 'start and end dates required' });
  }
  
  try {
    const result = await getPropertyAvailability(
      slug,
      propertyId,
      new Date(start as string),
      new Date(end as string)
    );
    
    res.json(result);
  } catch (e: any) {
    console.error('Get property availability error:', e);
    res.status(500).json({ error: 'Failed to get availability' });
  }
});

// ============ SEASONAL RULES ENDPOINTS ============

// GET /api/pms/portals/:slug/seasonal-rules - Get rules
router.get('/portals/:slug/seasonal-rules', async (req, res) => {
  const { slug } = req.params;
  const { property } = req.query;
  
  try {
    const rules = await getSeasonalRules(slug, property as string);
    res.json({ rules, count: rules.length });
  } catch (e: any) {
    console.error('Get rules error:', e);
    res.status(500).json({ error: 'Failed to get rules' });
  }
});

// POST /api/pms/portals/:slug/seasonal-rules - Create rule
router.post('/portals/:slug/seasonal-rules', async (req, res) => {
  const { slug } = req.params;
  const b = req.body || {};
  
  if (!b.name || !b.rateType || b.rateValue === undefined) {
    return res.status(400).json({ error: 'name, rateType, rateValue required' });
  }
  
  try {
    const rule = await createSeasonalRule(slug, {
      propertyId: b.propertyId,
      unitId: b.unitId,
      name: b.name,
      code: b.code,
      startDate: b.startDate ? new Date(b.startDate) : undefined,
      endDate: b.endDate ? new Date(b.endDate) : undefined,
      startMonth: b.startMonth,
      startDay: b.startDay,
      endMonth: b.endMonth,
      endDay: b.endDay,
      rateType: b.rateType,
      rateValue: b.rateValue,
      minStayNights: b.minStayNights,
      priority: b.priority
    });
    
    res.json({ rule });
  } catch (e: any) {
    console.error('Create rule error:', e);
    res.status(400).json({ error: e.message });
  }
});
```

## Update pmsService.ts - Add calendar sync to reservation creation

Add this at the end of createReservation():
```typescript
// Sync to calendar
await syncReservationToCalendar(reservation.id);
```

And import:
```typescript
import { syncReservationToCalendar } from './availabilityService';
```

## Drizzle Schema Exports

Add to shared/schema.ts:
- UnitCalendar, InsertUnitCalendar
- SeasonalRule, InsertSeasonalRule
- IcalSyncLog, InsertIcalSyncLog

## Deliverables
- [ ] Migration 091_unit_availability.sql
- [ ] cc_unit_calendar table with RLS
- [ ] cc_seasonal_rules table with RLS
- [ ] cc_ical_sync_log table with RLS
- [ ] Seasonal rules seeded:
  - Peak Summer (July-Aug): 1.5x multiplier, 2-night min
  - Shoulder (May-June): 1.2x multiplier
  - Winter (Nov-Mar): 0.8x multiplier
  - BC Day Weekend: 1.75x, 3-night min
  - Labour Day Weekend: 1.5x, 2-night min
- [ ] server/services/availabilityService.ts
- [ ] Routes added to server/routes/pms.ts:
  - GET /portals/:slug/units/:unitId/calendar
  - POST /portals/:slug/units/:unitId/block
  - POST /portals/:slug/units/:unitId/unblock
  - GET /portals/:slug/properties/:propertyId/availability
  - GET /portals/:slug/seasonal-rules
  - POST /portals/:slug/seasonal-rules
- [ ] Calendar applies seasonal rules to calculate day rates
- [ ] Blocking creates calendar entries with reason
- [ ] Reservation creation syncs to calendar
- [ ] Property availability shows summary (fully available, partial, booked)
- [ ] Test: Get calendar for July → rates show 1.5x multiplier
- [ ] Test: Block dates → calendar shows blocked
- [ ] Test: Property availability summary returns correct counts

Report with calendar showing seasonal rates and property availability summary.