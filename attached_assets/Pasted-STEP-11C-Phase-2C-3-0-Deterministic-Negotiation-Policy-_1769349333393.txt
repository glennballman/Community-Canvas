STEP 11C — Phase 2C-3.0
Deterministic Negotiation Policy Tables
Purpose (Why this exists)

Create a single source of truth for:

how many negotiation turns are allowed

who can initiate which negotiation type

what closes a negotiation

what is allowed to reference proposal shells later

how this differs per tenant (and later per plan)

This prevents:

infinite back-and-forth

silent behavior drift

hard-coded magic numbers

future refactors when monetization arrives

What this phase MUST do

✅ Add policy tables only
✅ Enforce policies server-side
❌ No UI changes
❌ No workflow changes
❌ No schema touching of existing negotiation tables

New Tables (Minimal, Explicit)
1️⃣ Platform Defaults
CREATE TABLE cc_platform_negotiation_policy (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Scope
  negotiation_type text NOT NULL
    CHECK (negotiation_type IN (
      'schedule',
      'scope',
      'pricing'
    )),

  -- Turn control
  max_turns integer NOT NULL,
  allow_counter boolean NOT NULL DEFAULT true,

  -- Closure rules
  close_on_accept boolean NOT NULL DEFAULT true,
  close_on_decline boolean NOT NULL DEFAULT true,

  -- Who can initiate
  provider_can_initiate boolean NOT NULL DEFAULT true,
  stakeholder_can_initiate boolean NOT NULL DEFAULT true,

  -- Proposal shell integration (future-safe)
  allow_proposal_context boolean NOT NULL DEFAULT false,

  -- Audit
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),

  UNIQUE (negotiation_type)
);


Seed defaults (important):

INSERT INTO cc_platform_negotiation_policy
(negotiation_type, max_turns, allow_counter, allow_proposal_context)
VALUES
('schedule', 3, true, false),
('scope', 5, true, true),
('pricing', 5, true, true);

2️⃣ Tenant Overrides
CREATE TABLE cc_tenant_negotiation_policy (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),

  tenant_id uuid NOT NULL REFERENCES cc_tenants(id),

  negotiation_type text NOT NULL
    CHECK (negotiation_type IN (
      'schedule',
      'scope',
      'pricing'
    )),

  -- Overrides (NULL = inherit platform)
  max_turns integer,
  allow_counter boolean,
  close_on_accept boolean,
  close_on_decline boolean,
  provider_can_initiate boolean,
  stakeholder_can_initiate boolean,
  allow_proposal_context boolean,

  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),

  UNIQUE (tenant_id, negotiation_type)
);

Policy Resolution Function (Server-Side)

Add a helper (no refactor, additive only):

async function loadNegotiationPolicy(
  tenantId: string,
  negotiationType: 'schedule' | 'scope' | 'pricing'
) {
  const platform = await pool.query(
    `SELECT * FROM cc_platform_negotiation_policy
     WHERE negotiation_type = $1`,
    [negotiationType]
  );

  const tenant = await pool.query(
    `SELECT * FROM cc_tenant_negotiation_policy
     WHERE tenant_id = $1 AND negotiation_type = $2`,
    [tenantId, negotiationType]
  );

  return {
    ...platform.rows[0],
    ...Object.fromEntries(
      Object.entries(tenant.rows[0] ?? {})
        .filter(([_, v]) => v !== null)
    )
  };
}

Enforcement Changes (Surgical)
Apply policy to existing 2C-3 schedule negotiation

Replace hard-coded logic:

// OLD
if (turnsUsed >= 3) throw error;


With:

const policy = await loadNegotiationPolicy(tenantId, 'schedule');

if (turnsUsed >= policy.max_turns) {
  return res.status(400).json({
    ok: false,
    error: 'error.negotiation.turn_limit_reached'
  });
}


Also enforce:

provider_can_initiate

stakeholder_can_initiate

allow_counter

close_on_accept / decline

RLS (Required)
ALTER TABLE cc_platform_negotiation_policy ENABLE ROW LEVEL SECURITY;
ALTER TABLE cc_tenant_negotiation_policy ENABLE ROW LEVEL SECURITY;

-- Platform policies: service mode only
CREATE POLICY platform_policy_service_only
ON cc_platform_negotiation_policy
USING (is_service_mode());

-- Tenant policies
CREATE POLICY tenant_policy_select
ON cc_tenant_negotiation_policy
FOR SELECT
USING (tenant_id = current_tenant_id());

CREATE POLICY tenant_policy_modify
ON cc_tenant_negotiation_policy
FOR INSERT, UPDATE
USING (tenant_id = current_tenant_id());

Why this matters (Strategically)

This does three critical things:

Decouples behavior from code
You can change negotiation limits without redeploys.

Prepares monetization cleanly
Paid tiers = higher max_turns, proposal_context enabled.

Allows proposal shell to snap in later
The moment allow_proposal_context=true, your DIY / hybrid / outsource shell becomes attachable — without refactoring 2C-3.

Proof Artifact Required

Create:

proof/v3.5/step11c-phase2c30-negotiation-policy-proof.md


Include:

Table schemas

Seed data

Policy resolution example

Enforcement diff (before / after)

RLS verification