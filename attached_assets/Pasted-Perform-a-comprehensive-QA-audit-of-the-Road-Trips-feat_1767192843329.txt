Perform a comprehensive QA audit of the Road Trips feature. There are several issues that need to be diagnosed and fixed:

KNOWN ISSUES:
1. "No webcams available for this route" - webcams not loading
2. Pricing source unclear - where is $189 for skiing coming from?
3. Weather hardcoded to -5¬∞C Light Snow for ALL trips (wrong for Tofino)
4. Ferry Status shows N/A even for trips that require ferries
5. Route conditions appear to be static/fake data
6. Budget breakdown may not match segment costs from database

=== PART 1: DATABASE AUDIT ===

First, run these SQL queries to verify the data is correct in the database. Create a diagnostic script:

Create file: server/scripts/qa-road-trips.ts
```typescript
import { Pool } from 'pg';

async function runQA() {
  const pool = new Pool({ connectionString: process.env.DATABASE_URL });
  
  console.log('\n========================================');
  console.log('üîç ROAD TRIPS QA AUDIT');
  console.log('========================================\n');

  try {
    // 1. Check road_trips table exists and has data
    console.log('1Ô∏è‚É£ CHECKING ROAD_TRIPS TABLE...');
    const tripsResult = await pool.query(`
      SELECT id, title, cost_budget, cost_moderate, cost_comfort, rating, rating_count 
      FROM road_trips ORDER BY id
    `);
    console.log(`   Found ${tripsResult.rows.length} trips:`);
    tripsResult.rows.forEach(t => {
      console.log(`   - ${t.id}: $${t.cost_budget}/$${t.cost_moderate}/$${t.cost_comfort}`);
    });

    // 2. Check trip_segments table
    console.log('\n2Ô∏è‚É£ CHECKING TRIP_SEGMENTS TABLE...');
    const segmentsResult = await pool.query(`
      SELECT trip_id, COUNT(*) as segment_count, 
             SUM(cost_budget) as total_budget,
             SUM(cost_moderate) as total_moderate,
             SUM(cost_comfort) as total_comfort
      FROM trip_segments 
      GROUP BY trip_id ORDER BY trip_id
    `);
    console.log(`   Segments by trip:`);
    segmentsResult.rows.forEach(s => {
      console.log(`   - ${s.trip_id}: ${s.segment_count} segments, costs: $${s.total_budget}/$${s.total_moderate}/$${s.total_comfort}`);
    });

    // 3. Check webcam_ids in segments
    console.log('\n3Ô∏è‚É£ CHECKING WEBCAM_IDS IN SEGMENTS...');
    const webcamResult = await pool.query(`
      SELECT trip_id, segment_order, title, webcam_ids, array_length(webcam_ids, 1) as webcam_count
      FROM trip_segments 
      WHERE webcam_ids IS NOT NULL AND array_length(webcam_ids, 1) > 0
      ORDER BY trip_id, segment_order
    `);
    if (webcamResult.rows.length === 0) {
      console.log('   ‚ö†Ô∏è NO SEGMENTS HAVE WEBCAM_IDS SET!');
    } else {
      console.log(`   Found ${webcamResult.rows.length} segments with webcams:`);
      webcamResult.rows.forEach(s => {
        console.log(`   - ${s.trip_id} #${s.segment_order}: ${s.webcam_count} webcams [${s.webcam_ids?.join(', ')}]`);
      });
    }

    // 4. Check if webcam IDs actually exist in entities table
    console.log('\n4Ô∏è‚É£ CHECKING IF WEBCAM ENTITIES EXIST...');
    const entityWebcamsResult = await pool.query(`
      SELECT COUNT(*) as count FROM entities WHERE entity_type_id = 'webcam'
    `);
    console.log(`   Total webcam entities in database: ${entityWebcamsResult.rows[0].count}`);
    
    // Get sample webcam IDs
    const sampleWebcams = await pool.query(`
      SELECT id, name, slug FROM entities WHERE entity_type_id = 'webcam' LIMIT 10
    `);
    console.log(`   Sample webcams:`);
    sampleWebcams.rows.forEach(w => {
      console.log(`   - ID ${w.id}: ${w.name} (${w.slug})`);
    });

    // 5. Check segment details JSON structure
    console.log('\n5Ô∏è‚É£ CHECKING SEGMENT DETAILS JSON...');
    const detailsResult = await pool.query(`
      SELECT trip_id, segment_order, title, segment_type, details
      FROM trip_segments 
      WHERE trip_id = 'whistler-ski-day'
      ORDER BY segment_order
    `);
    console.log(`   Whistler segments details:`);
    detailsResult.rows.forEach(s => {
      const details = s.details || {};
      console.log(`   - #${s.segment_order} ${s.title} (${s.segment_type}):`);
      console.log(`     ${JSON.stringify(details).substring(0, 100)}...`);
    });

    // 6. Check for ferry-related trips
    console.log('\n6Ô∏è‚É£ CHECKING FERRY SEGMENTS...');
    const ferryResult = await pool.query(`
      SELECT trip_id, title, details->>'mode' as mode, details->>'operator' as operator
      FROM trip_segments 
      WHERE details->>'mode' = 'ferry'
      ORDER BY trip_id
    `);
    if (ferryResult.rows.length === 0) {
      console.log('   ‚ö†Ô∏è NO FERRY SEGMENTS FOUND!');
    } else {
      console.log(`   Found ${ferryResult.rows.length} ferry segments:`);
      ferryResult.rows.forEach(f => {
        console.log(`   - ${f.trip_id}: ${f.title} (${f.operator})`);
      });
    }

    // 7. Verify cost calculations match
    console.log('\n7Ô∏è‚É£ VERIFYING COST CALCULATIONS...');
    const costCheckResult = await pool.query(`
      SELECT 
        t.id,
        t.cost_moderate as trip_cost,
        COALESCE(SUM(s.cost_moderate), 0) as segment_total,
        t.cost_moderate - COALESCE(SUM(s.cost_moderate), 0) as difference
      FROM road_trips t
      LEFT JOIN trip_segments s ON t.id = s.trip_id
      GROUP BY t.id, t.cost_moderate
      ORDER BY t.id
    `);
    console.log(`   Cost verification (moderate budget):`);
    costCheckResult.rows.forEach(c => {
      const status = c.difference == 0 ? '‚úÖ' : '‚ö†Ô∏è';
      console.log(`   ${status} ${c.id}: Trip=$${c.trip_cost}, Segments=$${c.segment_total}, Diff=$${c.difference}`);
    });

    // 8. Check road_segments field
    console.log('\n8Ô∏è‚É£ CHECKING ROAD_SEGMENTS FOR ALERTS...');
    const roadSegResult = await pool.query(`
      SELECT trip_id, title, road_segments
      FROM trip_segments 
      WHERE road_segments IS NOT NULL AND array_length(road_segments, 1) > 0
    `);
    if (roadSegResult.rows.length === 0) {
      console.log('   ‚ö†Ô∏è NO ROAD_SEGMENTS SET (needed for alerts)');
    } else {
      roadSegResult.rows.forEach(r => {
        console.log(`   - ${r.trip_id}: ${r.title} -> ${r.road_segments?.join(', ')}`);
      });
    }

    console.log('\n========================================');
    console.log('üèÅ QA AUDIT COMPLETE');
    console.log('========================================\n');

  } catch (error) {
    console.error('QA Error:', error);
  } finally {
    await pool.end();
  }
}

runQA();
```

Run this script with: `npx ts-node server/scripts/qa-road-trips.ts`

=== PART 2: API ENDPOINT AUDIT ===

Create file: server/scripts/qa-api-endpoints.ts
```typescript
async function testAPIs() {
  const BASE_URL = 'http://localhost:5000';
  
  console.log('\n========================================');
  console.log('üîç API ENDPOINT AUDIT');
  console.log('========================================\n');

  // Test 1: List trips
  console.log('1Ô∏è‚É£ GET /api/v1/trips');
  try {
    const res = await fetch(`${BASE_URL}/api/v1/trips`);
    const data = await res.json();
    console.log(`   Status: ${res.status}`);
    console.log(`   Trips returned: ${data.trips?.length || 0}`);
    if (data.trips?.[0]) {
      console.log(`   First trip: ${data.trips[0].title}`);
      console.log(`   Has seasons array: ${Array.isArray(data.trips[0].seasons)}`);
    }
  } catch (e) {
    console.log(`   ‚ùå ERROR: ${e}`);
  }

  // Test 2: Get single trip with segments
  console.log('\n2Ô∏è‚É£ GET /api/v1/trips/whistler-ski-day');
  try {
    const res = await fetch(`${BASE_URL}/api/v1/trips/whistler-ski-day`);
    const data = await res.json();
    console.log(`   Status: ${res.status}`);
    console.log(`   Title: ${data.title}`);
    console.log(`   Segments: ${data.segments?.length || 0}`);
    if (data.segments) {
      data.segments.forEach((s: any, i: number) => {
        console.log(`   - Segment ${i+1}: ${s.title}, cost_moderate: $${s.cost_moderate}, webcam_ids: [${s.webcam_ids?.join(',') || 'NONE'}]`);
      });
    }
  } catch (e) {
    console.log(`   ‚ùå ERROR: ${e}`);
  }

  // Test 3: Get trip conditions
  console.log('\n3Ô∏è‚É£ GET /api/v1/trips/whistler-ski-day/conditions');
  try {
    const res = await fetch(`${BASE_URL}/api/v1/trips/whistler-ski-day/conditions`);
    const data = await res.json();
    console.log(`   Status: ${res.status}`);
    console.log(`   Weather: ${JSON.stringify(data.weather)}`);
    console.log(`   Road Status: ${data.road_status}`);
    console.log(`   Ferry Status: ${data.ferry_status}`);
    console.log(`   Alerts: ${data.alerts?.length || 0}`);
    console.log(`   ‚ö†Ô∏è Is weather hardcoded? ${data.weather?.temperature === -5 ? 'YES - NEEDS FIX' : 'No'}`);
  } catch (e) {
    console.log(`   ‚ùå ERROR: ${e}`);
  }

  // Test 4: Get trip webcams
  console.log('\n4Ô∏è‚É£ GET /api/v1/trips/whistler-ski-day/webcams');
  try {
    const res = await fetch(`${BASE_URL}/api/v1/trips/whistler-ski-day/webcams`);
    const data = await res.json();
    console.log(`   Status: ${res.status}`);
    console.log(`   Webcams returned: ${data.webcams?.length || 0}`);
    console.log(`   Segments with webcams: ${data.segments?.length || 0}`);
    if (data.webcams?.length === 0) {
      console.log(`   ‚ö†Ô∏è NO WEBCAMS RETURNED - CHECK webcam_ids IN DATABASE`);
    }
  } catch (e) {
    console.log(`   ‚ùå ERROR: ${e}`);
  }

  // Test 5: Tofino trip (should have ferry info)
  console.log('\n5Ô∏è‚É£ GET /api/v1/trips/tofino-storm-watching/conditions');
  try {
    const res = await fetch(`${BASE_URL}/api/v1/trips/tofino-storm-watching/conditions`);
    const data = await res.json();
    console.log(`   Status: ${res.status}`);
    console.log(`   Weather: ${JSON.stringify(data.weather)}`);
    console.log(`   Ferry Status: ${data.ferry_status}`);
    console.log(`   ‚ö†Ô∏è Shows -5¬∞C for Tofino? ${data.weather?.temperature === -5 ? 'YES - WRONG!' : 'No'}`);
    console.log(`   ‚ö†Ô∏è Ferry N/A for island trip? ${data.ferry_status === null ? 'YES - NEEDS FIX' : 'No'}`);
  } catch (e) {
    console.log(`   ‚ùå ERROR: ${e}`);
  }

  // Test 6: Sunshine Coast (has ferries)
  console.log('\n6Ô∏è‚É£ GET /api/v1/trips/sunshine-coast-loop');
  try {
    const res = await fetch(`${BASE_URL}/api/v1/trips/sunshine-coast-loop`);
    const data = await res.json();
    console.log(`   Status: ${res.status}`);
    const ferrySegments = data.segments?.filter((s: any) => s.details?.mode === 'ferry') || [];
    console.log(`   Ferry segments: ${ferrySegments.length}`);
    ferrySegments.forEach((f: any) => {
      console.log(`   - ${f.title}: $${f.cost_moderate}`);
    });
  } catch (e) {
    console.log(`   ‚ùå ERROR: ${e}`);
  }

  console.log('\n========================================');
  console.log('üèÅ API AUDIT COMPLETE');
  console.log('========================================\n');
}

testAPIs();
```

Run with: `npx ts-node server/scripts/qa-api-endpoints.ts`

=== PART 3: FIX WEBCAM INTEGRATION ===

The webcam_ids in the seed data are placeholder IDs (1, 2, 3...) that don't match actual entity IDs. We need to:
1. Find actual webcam entity IDs for Sea to Sky Highway
2. Update the segments with real IDs

Update file: server/routes/trips.ts

Replace the `/webcams` endpoint with this improved version:
```typescript
// GET /api/v1/trips/:id/webcams - Get webcams for trip route
router.get('/:id/webcams', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    
    // Get trip with region info
    const tripResult = await pool.query(
      `SELECT * FROM road_trips WHERE id = $1 OR slug = $1`,
      [id]
    );
    
    if (tripResult.rows.length === 0) {
      return res.status(404).json({ error: 'Trip not found' });
    }
    
    const trip = tripResult.rows[0];
    
    // Get segments
    const segmentsResult = await pool.query(
      `SELECT * FROM trip_segments WHERE trip_id = $1 ORDER BY segment_order`,
      [id]
    );
    
    // Strategy: Find webcams near segment locations or along route
    // For now, get webcams based on the trip's region
    let webcams: any[] = [];
    
    // Map trip regions to webcam search terms
    const regionWebcamMap: Record<string, string[]> = {
      'Sea to Sky': ['sea to sky', 'highway 99', 'whistler', 'squamish', 'lions gate', 'horseshoe bay'],
      'Vancouver Island': ['vancouver island', 'highway 1', 'highway 4', 'nanaimo', 'tofino', 'victoria'],
      'Okanagan': ['okanagan', 'kelowna', 'highway 97', 'penticton'],
      'Sunshine Coast': ['sunshine coast', 'highway 101', 'gibsons', 'sechelt', 'powell river', 'langdale', 'horseshoe bay'],
      'Fraser Valley': ['fraser valley', 'highway 1', 'highway 7', 'chilliwack', 'abbotsford', 'harrison']
    };
    
    const searchTerms = regionWebcamMap[trip.region] || [trip.region.toLowerCase()];
    
    // Search for webcams matching these terms
    const webcamQuery = `
      SELECT e.*, 
             e.metadata->>'direct_feed_url' as feed_url,
             e.metadata->>'source_url' as source_url
      FROM entities e
      WHERE e.entity_type_id = 'webcam'
      AND (
        ${searchTerms.map((_, i) => `LOWER(e.name) LIKE $${i + 1}`).join(' OR ')}
        OR ${searchTerms.map((_, i) => `LOWER(e.description) LIKE $${searchTerms.length + i + 1}`).join(' OR ')}
      )
      ORDER BY e.name
      LIMIT 20
    `;
    
    const searchParams = [
      ...searchTerms.map(t => `%${t}%`),
      ...searchTerms.map(t => `%${t}%`)
    ];
    
    try {
      const webcamResult = await pool.query(webcamQuery, searchParams);
      webcams = webcamResult.rows;
    } catch (err) {
      console.error('Webcam query error:', err);
      // Fallback: get any webcams with coordinates near the route
      const fallbackResult = await pool.query(`
        SELECT e.*, 
               e.metadata->>'direct_feed_url' as feed_url
        FROM entities e
        WHERE e.entity_type_id = 'webcam'
        AND e.latitude IS NOT NULL
        ORDER BY 
          CASE 
            WHEN LOWER(e.name) LIKE '%highway%' THEN 1
            WHEN LOWER(e.name) LIKE '%hwy%' THEN 1
            ELSE 2
          END,
          e.name
        LIMIT 15
      `);
      webcams = fallbackResult.rows;
    }
    
    // Group webcams by segment (approximate based on location)
    const segmentsWithWebcams = segmentsResult.rows.map((seg: any) => ({
      ...seg,
      webcams: webcams.filter(w => {
        // Simple matching: if segment title or location contains webcam keywords
        const segText = `${seg.title} ${seg.location_name}`.toLowerCase();
        const webcamText = w.name.toLowerCase();
        return searchTerms.some(term => 
          segText.includes(term.split(' ')[0]) && webcamText.includes(term.split(' ')[0])
        );
      }).slice(0, 5) // Max 5 per segment
    }));
    
    res.json({ 
      webcams,
      segments: segmentsWithWebcams,
      region: trip.region,
      search_terms: searchTerms
    });
  } catch (error) {
    console.error('Error fetching webcams:', error);
    res.status(500).json({ error: 'Failed to fetch webcams' });
  }
});
```

=== PART 4: FIX ROUTE CONDITIONS (REAL DATA) ===

Replace the `/conditions` endpoint with this version that pulls real data:
```typescript
// GET /api/v1/trips/:id/conditions - Live route conditions
router.get('/:id/conditions', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    
    // Get trip details
    const tripResult = await pool.query(
      `SELECT * FROM road_trips WHERE id = $1 OR slug = $1`,
      [id]
    );
    
    if (tripResult.rows.length === 0) {
      return res.status(404).json({ error: 'Trip not found' });
    }
    
    const trip = tripResult.rows[0];
    
    // Get segments to check for ferry routes
    const segmentsResult = await pool.query(
      `SELECT * FROM trip_segments WHERE trip_id = $1 ORDER BY segment_order`,
      [id]
    );
    
    // Check if trip has ferry segments
    const ferrySegments = segmentsResult.rows.filter(
      (s: any) => s.details?.mode === 'ferry'
    );
    const hasFerry = ferrySegments.length > 0;
    
    // Get alerts relevant to this trip's region
    let alerts: any[] = [];
    try {
      // Map regions to alert search
      const regionAlertMap: Record<string, string[]> = {
        'Sea to Sky': ['squamish', 'whistler', 'west vancouver', 'highway 99'],
        'Vancouver Island': ['nanaimo', 'victoria', 'tofino', 'duncan', 'highway 1', 'highway 4'],
        'Okanagan': ['kelowna', 'penticton', 'vernon', 'highway 97'],
        'Sunshine Coast': ['gibsons', 'sechelt', 'powell river', 'highway 101'],
        'Fraser Valley': ['chilliwack', 'abbotsford', 'harrison', 'highway 1', 'highway 7']
      };
      
      const searchTerms = regionAlertMap[trip.region] || [trip.region.toLowerCase()];
      
      const alertsResult = await pool.query(`
        SELECT * FROM alerts 
        WHERE status = 'active'
        AND (
          ${searchTerms.map((_, i) => `LOWER(headline) LIKE $${i + 1} OR LOWER(description) LIKE $${i + 1}`).join(' OR ')}
        )
        ORDER BY 
          CASE severity 
            WHEN 'critical' THEN 1 
            WHEN 'major' THEN 2 
            WHEN 'moderate' THEN 3 
            ELSE 4 
          END,
          created_at DESC
        LIMIT 10
      `, searchTerms.map(t => `%${t}%`));
      
      alerts = alertsResult.rows;
    } catch (err) {
      // If alerts query fails, try simpler query
      const fallbackAlerts = await pool.query(`
        SELECT * FROM alerts WHERE status = 'active' ORDER BY created_at DESC LIMIT 5
      `).catch(() => ({ rows: [] }));
      alerts = fallbackAlerts.rows;
    }
    
    // Get weather based on destination region
    // This would ideally call a weather API, but for now use region-appropriate defaults
    const regionWeather: Record<string, { temperature: number; condition: string; wind_speed: number }> = {
      'Sea to Sky': { temperature: -5, condition: 'Light Snow', wind_speed: 15 },
      'Vancouver Island': { temperature: 8, condition: 'Rain', wind_speed: 25 },
      'Okanagan': { temperature: -2, condition: 'Partly Cloudy', wind_speed: 10 },
      'Sunshine Coast': { temperature: 6, condition: 'Cloudy', wind_speed: 20 },
      'Fraser Valley': { temperature: 4, condition: 'Fog', wind_speed: 5 }
    };
    
    const weather = regionWeather[trip.region] || { temperature: 5, condition: 'Unknown', wind_speed: 10 };
    
    // Determine ferry status if applicable
    let ferryStatus = null;
    if (hasFerry) {
      // In production, this would call BC Ferries API
      // For now, indicate ferry is required and provide info from segments
      ferryStatus = {
        required: true,
        routes: ferrySegments.map((f: any) => ({
          name: f.title,
          operator: f.details?.operator || 'BC Ferries',
          status: 'On Schedule', // Would come from API
          fare: f.cost_moderate
        }))
      };
    }
    
    // Determine road status based on alerts
    let roadStatus = 'Clear';
    const roadAlerts = alerts.filter(a => 
      a.alert_type?.includes('road') || 
      a.alert_type?.includes('closure') ||
      a.alert_type?.includes('construction')
    );
    if (roadAlerts.length > 0) {
      const hasCritical = roadAlerts.some(a => a.severity === 'critical');
      const hasMajor = roadAlerts.some(a => a.severity === 'major');
      roadStatus = hasCritical ? 'Major Delays' : hasMajor ? 'Minor Delays' : 'Caution';
    }
    
    // Determine overall status
    let overallStatus = 'good';
    if (alerts.some(a => a.severity === 'critical')) {
      overallStatus = 'severe';
    } else if (alerts.some(a => a.severity === 'major')) {
      overallStatus = 'warning';
    } else if (alerts.length > 0) {
      overallStatus = 'caution';
    }
    
    res.json({
      trip_id: id,
      region: trip.region,
      alerts,
      alert_count: alerts.length,
      weather,
      road_status: roadStatus,
      ferry_status: ferryStatus,
      overall_status: overallStatus,
      checked_at: new Date().toISOString()
    });
  } catch (error) {
    console.error('Error fetching conditions:', error);
    res.status(500).json({ error: 'Failed to fetch conditions' });
  }
});
```

=== PART 5: UPDATE FRONTEND TO USE REAL DATA ===

Update client/src/components/Dashboard/JourneyView.tsx to properly display conditions:

Find the "Current Route Conditions" section and update it:
```tsx
// Add state for conditions
const [conditions, setConditions] = useState<any>(null);
const [conditionsLoading, setConditionsLoading] = useState(true);

// Fetch conditions
useEffect(() => {
  fetchConditions();
}, [trip.id]);

async function fetchConditions() {
  setConditionsLoading(true);
  try {
    const response = await fetch(`/api/v1/trips/${trip.id}/conditions`);
    const data = await response.json();
    setConditions(data);
  } catch (error) {
    console.error('Failed to fetch conditions:', error);
  } finally {
    setConditionsLoading(false);
  }
}

// Update the conditions display section:
{/* Route Conditions */}
<div className="bg-gray-800 rounded-xl p-4">
  <h3 className="text-white font-semibold mb-3 flex items-center gap-2">
    üì° Current Route Conditions
    {conditionsLoading && <span className="text-gray-500 text-sm">(loading...)</span>}
  </h3>

  <div className="grid grid-cols-4 gap-4">
    <div className="bg-gray-700/50 rounded-lg p-3 text-center">
      <div className="text-2xl mb-1">üå§Ô∏è</div>
      <div className="text-white font-medium">
        {conditions?.weather?.temperature ?? '--'}¬∞C
      </div>
      <div className="text-gray-400 text-xs">
        {conditions?.weather?.condition ?? 'Loading...'}
      </div>
    </div>
    <div className="bg-gray-700/50 rounded-lg p-3 text-center">
      <div className="text-2xl mb-1">üõ£Ô∏è</div>
      <div className={`font-medium ${
        conditions?.road_status === 'Clear' ? 'text-green-400' :
        conditions?.road_status === 'Caution' ? 'text-yellow-400' :
        'text-red-400'
      }`}>
        {conditions?.road_status ?? 'Loading...'}
      </div>
      <div className="text-gray-400 text-xs">Road Status</div>
    </div>
    <div className="bg-gray-700/50 rounded-lg p-3 text-center">
      <div className="text-2xl mb-1">‚ö†Ô∏è</div>
      <div className={`font-medium ${
        (conditions?.alert_count || 0) > 0 ? 'text-orange-400' : 'text-green-400'
      }`}>
        {conditions?.alert_count ?? 0}
      </div>
      <div className="text-gray-400 text-xs">Active Alerts</div>
    </div>
    <div className="bg-gray-700/50 rounded-lg p-3 text-center">
      <div className="text-2xl mb-1">‚õ¥Ô∏è</div>
      {conditions?.ferry_status ? (
        <>
          <div className="text-green-400 font-medium">
            {conditions.ferry_status.routes?.[0]?.status || 'Required'}
          </div>
          <div className="text-gray-400 text-xs">
            {conditions.ferry_status.routes?.length} ferry route(s)
          </div>
        </>
      ) : (
        <>
          <div className="text-gray-500 font-medium">N/A</div>
          <div className="text-gray-400 text-xs">No Ferry</div>
        </>
      )}
    </div>
  </div>
  
  {/* Show ferry details if applicable */}
  {conditions?.ferry_status?.routes && conditions.ferry_status.routes.length > 0 && (
    <div className="mt-4 p-3 bg-blue-500/10 rounded-lg border border-blue-500/20">
      <p className="text-blue-400 text-sm font-medium mb-2">‚õ¥Ô∏è Ferry Routes Required</p>
      <div className="space-y-2">
        {conditions.ferry_status.routes.map((route: any, idx: number) => (
          <div key={idx} className="flex items-center justify-between text-sm">
            <span className="text-gray-300">{route.name}</span>
            <span className="text-green-400">{route.status}</span>
          </div>
        ))}
      </div>
    </div>
  )}
  
  {/* Show alerts if any */}
  {conditions?.alerts && conditions.alerts.length > 0 && (
    <div className="mt-4">
      <p className="text-orange-400 text-sm font-medium mb-2">‚ö†Ô∏è Active Alerts on Route</p>
      <div className="space-y-2 max-h-40 overflow-y-auto">
        {conditions.alerts.slice(0, 3).map((alert: any) => (
          <div key={alert.id} className="p-2 bg-orange-500/10 rounded border border-orange-500/20">
            <p className="text-gray-300 text-sm">{alert.headline}</p>
            <p className="text-gray-500 text-xs mt-1">{alert.region_name}</p>
          </div>
        ))}
      </div>
    </div>
  )}
</div>
```

=== PART 6: UPDATE FRONTEND WEBCAM DISPLAY ===

Update the webcam fetching in JourneyView.tsx:
```tsx
// Update fetchWebcams function
async function fetchWebcams() {
  try {
    const response = await fetch(`/api/v1/trips/${trip.id}/webcams`);
    const data = await response.json();
    console.log('Webcams response:', data); // Debug logging
    setWebcams(data.webcams || []);
    
    // If we got segments with webcams, update those too
    if (data.segments) {
      // Could update segment display with webcam info
    }
  } catch (error) {
    console.error('Failed to fetch webcams:', error);
    setWebcams([]);
  }
}

// Update the webcam strip to handle empty state better
{/* Live Webcams Strip */}
<div className="bg-gray-800 rounded-xl p-4">
  <h3 className="text-white font-semibold mb-4 flex items-center gap-2">
    üì∑ Live Cameras Along Your Route
    <span className="text-gray-400 text-sm font-normal">
      ({webcams.length} cameras)
    </span>
  </h3>

  {webcams.length > 0 ? (
    <div className="flex gap-3 overflow-x-auto pb-2">
      {webcams.map((webcam, idx) => (
        <WebcamThumbnail key={webcam.id || idx} webcam={webcam} />
      ))}
    </div>
  ) : (
    <div className="text-center py-6">
      <span className="text-4xl">üì∑</span>
      <p className="text-gray-400 mt-2">Loading webcams for {trip.region}...</p>
      <p className="text-gray-500 text-sm">Searching for cameras along your route</p>
    </div>
  )}
</div>
```

=== PART 7: VERIFY DATA FLOW ===

After making these changes, verify:

1. Open browser DevTools ‚Üí Network tab
2. Click on a road trip
3. Watch for these API calls:
   - GET /api/v1/trips/[trip-id] ‚Üí Should return trip + segments
   - GET /api/v1/trips/[trip-id]/conditions ‚Üí Should return weather, alerts, ferry status
   - GET /api/v1/trips/[trip-id]/webcams ‚Üí Should return webcams array

4. Check Console for any errors

5. Verify:
   - Whistler trip shows: -5¬∞C, Snow (correct for ski trip)
   - Tofino trip shows: 8¬∞C, Rain (correct for coastal)
   - Tofino shows ferry required: Yes
   - Sunshine Coast shows: 2 ferry routes
   - Webcams load for Sea to Sky region

Run the QA scripts first to diagnose, then apply the fixes. Report back what the QA scripts output so we can identify exactly what needs to be fixed.