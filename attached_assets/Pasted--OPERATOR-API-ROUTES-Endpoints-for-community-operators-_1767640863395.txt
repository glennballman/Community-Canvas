/**
 * OPERATOR API ROUTES
 * 
 * Endpoints for community operators to search availability,
 * request holds, and log calls.
 */

import { Router, Request, Response } from 'express';
import { pool } from '../db';

const router = Router();

// GET /api/operator/availability - Search availability across opted-in tenants
router.get('/availability', async (req: Request, res: Response) => {
  try {
    const session = req.session as any;
    
    if (!session?.user) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    // Get current tenant context
    const tenantId = session.current_tenant_id;
    if (!tenantId) {
      return res.status(400).json({ error: 'No tenant context' });
    }
    
    const { item_type, search, date_start, date_end, capacity } = req.query;
    
    const result = await pool.query(
      `SELECT * FROM search_operator_availability($1, $2, $3::date, $4::date, $5::int, $6, 50)`,
      [
        tenantId,
        item_type || null,
        date_start || null,
        date_end || null,
        capacity ? parseInt(capacity as string) : null,
        search || null
      ]
    );
    
    res.json({ results: result.rows });
    
  } catch (error) {
    console.error('Availability search error:', error);
    res.status(500).json({ error: 'Search failed' });
  }
});

// POST /api/operator/hold-request - Request a hold on an item
router.post('/hold-request', async (req: Request, res: Response) => {
  try {
    const session = req.session as any;
    
    if (!session?.user) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    const {
      catalog_item_id,
      date_start,
      date_end,
      party_size,
      caller_name,
      caller_phone,
      caller_email,
      caller_notes
    } = req.body;
    
    if (!catalog_item_id || !date_start) {
      return res.status(400).json({ error: 'catalog_item_id and date_start required' });
    }
    
    // Get item info
    const itemResult = await pool.query(
      `SELECT ci.id, ci.tenant_id, tss.allow_hold_requests
       FROM catalog_items ci
       LEFT JOIN tenant_sharing_settings tss ON ci.tenant_id = tss.tenant_id
       WHERE ci.id = $1`,
      [catalog_item_id]
    );
    
    if (itemResult.rows.length === 0) {
      return res.status(404).json({ error: 'Item not found' });
    }
    
    const item = itemResult.rows[0];
    
    if (!item.allow_hold_requests) {
      return res.status(403).json({ error: 'This business does not accept hold requests' });
    }
    
    // Create hold request
    const holdResult = await pool.query(
      `INSERT INTO hold_requests (
        catalog_item_id, business_tenant_id, requesting_tenant_id, requesting_user_id,
        date_start, date_end, party_size,
        caller_name, caller_phone, caller_email, caller_notes,
        expires_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, now() + interval '4 hours')
      RETURNING *`,
      [
        catalog_item_id,
        item.tenant_id,
        session.current_tenant_id,
        session.user.id,
        date_start,
        date_end || null,
        party_size || null,
        caller_name || null,
        caller_phone || null,
        caller_email || null,
        caller_notes || null
      ]
    );
    
    // TODO: Send notification to business tenant
    
    res.json({
      success: true,
      hold_request: holdResult.rows[0]
    });
    
  } catch (error) {
    console.error('Hold request error:', error);
    res.status(500).json({ error: 'Failed to create hold request' });
  }
});

// POST /api/operator/call-log - Log a call
router.post('/call-log', async (req: Request, res: Response) => {
  try {
    const session = req.session as any;
    
    if (!session?.user) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    const {
      caller_name,
      caller_phone,
      caller_email,
      need_type,
      need_summary,
      date_start,
      date_end,
      party_size,
      special_requirements,
      outcome,
      outcome_notes
    } = req.body;
    
    const result = await pool.query(
      `INSERT INTO operator_call_logs (
        operator_tenant_id, operator_user_id,
        caller_name, caller_phone, caller_email,
        need_type, need_summary, date_start, date_end, party_size, special_requirements,
        outcome, outcome_notes
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
      RETURNING *`,
      [
        session.current_tenant_id,
        session.user.id,
        caller_name || null,
        caller_phone || null,
        caller_email || null,
        need_type || null,
        need_summary || null,
        date_start || null,
        date_end || null,
        party_size || null,
        special_requirements || null,
        outcome || null,
        outcome_notes || null
      ]
    );
    
    res.json({
      success: true,
      call_log: result.rows[0]
    });
    
  } catch (error) {
    console.error('Call log error:', error);
    res.status(500).json({ error: 'Failed to log call' });
  }
});

export default router;