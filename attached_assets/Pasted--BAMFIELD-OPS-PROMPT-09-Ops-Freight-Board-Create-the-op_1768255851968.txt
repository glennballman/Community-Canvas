**BAMFIELD OPS - PROMPT 09: Ops Freight Board**

Create the operational dashboard API for freight managers showing manifests, items, exceptions, and daily summaries.

## Create server/services/freightBoardService.ts
```typescript
// server/services/freightBoardService.ts

import { db } from '../db';
import { eq, and, gte, lte, or, sql, desc, asc } from 'drizzle-orm';

// ============ TYPES ============

interface FreightBoardSummary {
  date: string;
  manifests: {
    total: number;
    byStatus: Record<string, number>;
    draft: number;
    inTransit: number;
    delivered: number;
    exceptions: number;
  };
  items: {
    total: number;
    pending: number;
    loaded: number;
    inTransit: number;
    delivered: number;
    held: number;
  };
  weight: {
    totalLbs: number;
    loadedLbs: number;
    deliveredLbs: number;
  };
  revenue: {
    totalCad: number;
    pendingCad: number;
    collectedCad: number;
  };
  exceptions: {
    open: number;
    critical: number;
    pendingResolution: number;
  };
}

interface ManifestBoardEntry {
  manifestId: string;
  manifestNumber: string;
  status: string;
  manifestDate: string;
  
  shipper: {
    name: string;
    business?: string;
  };
  consignee: {
    name: string;
    business?: string;
  };
  
  route: {
    origin?: string;
    destination?: string;
  };
  
  items: {
    total: number;
    pending: number;
    loaded: number;
    delivered: number;
    held: number;
  };
  
  weight: {
    totalLbs: number;
  };
  
  charges: {
    totalCad: number;
    paymentStatus: string;
  };
  
  exceptions: {
    open: number;
    critical: number;
  };
  
  sailingNumber?: string;
  operatorCode?: string;
  
  lastActivity?: {
    type: string;
    at: Date;
    by: string;
  };
}

// ============ BOARD FUNCTIONS ============

export async function getFreightBoardSummary(
  portalSlug: string,
  date?: Date
): Promise<FreightBoardSummary> {
  const portal = await db.query.ccPortals.findFirst({
    where: eq(ccPortals.slug, portalSlug)
  });
  
  if (!portal) {
    return emptyBoardSummary(date || new Date());
  }
  
  const targetDate = date || new Date();
  const dateStr = targetDate.toISOString().split('T')[0];
  
  // Get manifests for date
  const manifests = await db.query.ccFreightManifests.findMany({
    where: and(
      eq(ccFreightManifests.portalId, portal.id),
      eq(ccFreightManifests.manifestDate, dateStr)
    )
  });
  
  // Calculate manifest stats
  const byStatus: Record<string, number> = {};
  let totalWeight = 0;
  let loadedWeight = 0;
  let deliveredWeight = 0;
  let totalRevenue = 0;
  let pendingRevenue = 0;
  let collectedRevenue = 0;
  
  for (const m of manifests) {
    byStatus[m.status] = (byStatus[m.status] || 0) + 1;
    totalWeight += Number(m.totalWeightLbs) || 0;
    totalRevenue += Number(m.freightChargesCad) || 0;
    
    if (['loaded', 'in_transit', 'arrived', 'delivered', 'partial'].includes(m.status)) {
      loadedWeight += Number(m.totalWeightLbs) || 0;
    }
    if (['delivered'].includes(m.status)) {
      deliveredWeight += Number(m.totalWeightLbs) || 0;
    }
    if (m.paymentStatus === 'paid') {
      collectedRevenue += Number(m.freightChargesCad) || 0;
    } else {
      pendingRevenue += Number(m.freightChargesCad) || 0;
    }
  }
  
  // Get items for all manifests
  const manifestIds = manifests.map(m => m.id);
  let items: any[] = [];
  if (manifestIds.length > 0) {
    items = await db.query.ccFreightItems.findMany({
      where: sql`${ccFreightItems.manifestId} IN (${sql.join(manifestIds.map(id => sql`${id}`), sql`, `)})`
    });
  }
  
  // Calculate item stats
  const itemsByStatus: Record<string, number> = {};
  for (const item of items) {
    itemsByStatus[item.status] = (itemsByStatus[item.status] || 0) + 1;
  }
  
  // Get exceptions
  const exceptions = await db.query.ccHandlingExceptions.findMany({
    where: and(
      eq(ccHandlingExceptions.portalId, portal.id),
      eq(ccHandlingExceptions.status, 'open')
    )
  });
  
  const criticalExceptions = exceptions.filter(e => e.severity === 'critical').length;
  
  return {
    date: dateStr,
    manifests: {
      total: manifests.length,
      byStatus,
      draft: byStatus['draft'] || 0,
      inTransit: byStatus['in_transit'] || 0,
      delivered: byStatus['delivered'] || 0,
      exceptions: manifests.filter(m => m.status === 'held').length
    },
    items: {
      total: items.length,
      pending: itemsByStatus['pending'] || 0,
      loaded: itemsByStatus['loaded'] || 0,
      inTransit: itemsByStatus['in_transit'] || 0,
      delivered: itemsByStatus['delivered'] || 0,
      held: itemsByStatus['held'] || 0
    },
    weight: {
      totalLbs: totalWeight,
      loadedLbs: loadedWeight,
      deliveredLbs: deliveredWeight
    },
    revenue: {
      totalCad: totalRevenue,
      pendingCad: pendingRevenue,
      collectedCad: collectedRevenue
    },
    exceptions: {
      open: exceptions.length,
      critical: criticalExceptions,
      pendingResolution: exceptions.filter(e => e.status === 'pending_action').length
    }
  };
}

function emptyBoardSummary(date: Date): FreightBoardSummary {
  return {
    date: date.toISOString().split('T')[0],
    manifests: { total: 0, byStatus: {}, draft: 0, inTransit: 0, delivered: 0, exceptions: 0 },
    items: { total: 0, pending: 0, loaded: 0, inTransit: 0, delivered: 0, held: 0 },
    weight: { totalLbs: 0, loadedLbs: 0, deliveredLbs: 0 },
    revenue: { totalCad: 0, pendingCad: 0, collectedCad: 0 },
    exceptions: { open: 0, critical: 0, pendingResolution: 0 }
  };
}

export async function getFreightBoard(
  portalSlug: string,
  options?: {
    date?: Date;
    status?: string;
    operatorId?: string;
    sailingId?: string;
    limit?: number;
  }
): Promise<{
  entries: ManifestBoardEntry[];
  summary: FreightBoardSummary;
}> {
  const portal = await db.query.ccPortals.findFirst({
    where: eq(ccPortals.slug, portalSlug)
  });
  
  if (!portal) {
    return { entries: [], summary: emptyBoardSummary(options?.date || new Date()) };
  }
  
  const conditions: any[] = [eq(ccFreightManifests.portalId, portal.id)];
  
  if (options?.date) {
    const dateStr = options.date.toISOString().split('T')[0];
    conditions.push(eq(ccFreightManifests.manifestDate, dateStr));
  }
  
  if (options?.status) {
    conditions.push(eq(ccFreightManifests.status, options.status));
  }
  
  if (options?.operatorId) {
    conditions.push(eq(ccFreightManifests.operatorId, options.operatorId));
  }
  
  if (options?.sailingId) {
    conditions.push(eq(ccFreightManifests.sailingId, options.sailingId));
  }
  
  const manifests = await db.query.ccFreightManifests.findMany({
    where: and(...conditions),
    orderBy: [desc(ccFreightManifests.manifestDate), asc(ccFreightManifests.createdAt)],
    limit: options?.limit || 50
  });
  
  // Build board entries
  const entries: ManifestBoardEntry[] = [];
  
  for (const manifest of manifests) {
    // Get items
    const items = await db.query.ccFreightItems.findMany({
      where: eq(ccFreightItems.manifestId, manifest.id)
    });
    
    const itemsByStatus: Record<string, number> = {};
    for (const item of items) {
      itemsByStatus[item.status] = (itemsByStatus[item.status] || 0) + 1;
    }
    
    // Get exceptions
    const exceptions = await db.query.ccHandlingExceptions.findMany({
      where: and(
        eq(ccHandlingExceptions.manifestId, manifest.id),
        eq(ccHandlingExceptions.status, 'open')
      )
    });
    
    // Get last handling activity
    const lastHandling = await db.query.ccProofOfHandling.findFirst({
      where: eq(ccProofOfHandling.manifestId, manifest.id),
      orderBy: [desc(ccProofOfHandling.handledAt)]
    });
    
    // Get location names
    let originName: string | undefined;
    let destName: string | undefined;
    
    if (manifest.originLocationId) {
      const loc = await db.query.ccLocations.findFirst({
        where: eq(ccLocations.id, manifest.originLocationId)
      });
      originName = loc?.name;
    }
    
    if (manifest.destinationLocationId) {
      const loc = await db.query.ccLocations.findFirst({
        where: eq(ccLocations.id, manifest.destinationLocationId)
      });
      destName = loc?.name;
    }
    
    // Get sailing number if linked
    let sailingNumber: string | undefined;
    if (manifest.sailingId) {
      const sailing = await db.query.ccSailings.findFirst({
        where: eq(ccSailings.id, manifest.sailingId)
      });
      sailingNumber = sailing?.sailingNumber;
    }
    
    // Get operator code
    let operatorCode: string | undefined;
    if (manifest.operatorId) {
      const operator = await db.query.ccTransportOperators.findFirst({
        where: eq(ccTransportOperators.id, manifest.operatorId)
      });
      operatorCode = operator?.code;
    }
    
    entries.push({
      manifestId: manifest.id,
      manifestNumber: manifest.manifestNumber,
      status: manifest.status,
      manifestDate: manifest.manifestDate?.toISOString().split('T')[0] || '',
      shipper: {
        name: manifest.shipperName || 'Unknown',
        business: manifest.shipperBusiness
      },
      consignee: {
        name: manifest.consigneeName || 'Unknown',
        business: manifest.consigneeBusiness
      },
      route: {
        origin: originName,
        destination: destName
      },
      items: {
        total: items.length,
        pending: itemsByStatus['pending'] || 0,
        loaded: itemsByStatus['loaded'] || 0,
        delivered: itemsByStatus['delivered'] || 0,
        held: itemsByStatus['held'] || 0
      },
      weight: {
        totalLbs: Number(manifest.totalWeightLbs) || 0
      },
      charges: {
        totalCad: Number(manifest.freightChargesCad) || 0,
        paymentStatus: manifest.paymentStatus || 'pending'
      },
      exceptions: {
        open: exceptions.length,
        critical: exceptions.filter(e => e.severity === 'critical').length
      },
      sailingNumber,
      operatorCode,
      lastActivity: lastHandling ? {
        type: lastHandling.handlingType,
        at: lastHandling.handledAt,
        by: lastHandling.handlerName
      } : undefined
    });
  }
  
  // Get summary
  const summary = await getFreightBoardSummary(portalSlug, options?.date);
  
  return { entries, summary };
}

// ============ ACTION QUEUES ============

export async function getPendingPickups(portalSlug: string): Promise<any[]> {
  const portal = await db.query.ccPortals.findFirst({
    where: eq(ccPortals.slug, portalSlug)
  });
  
  if (!portal) return [];
  
  // Manifests in draft/submitted status with no pickup recorded
  const manifests = await db.query.ccFreightManifests.findMany({
    where: and(
      eq(ccFreightManifests.portalId, portal.id),
      or(
        eq(ccFreightManifests.status, 'draft'),
        eq(ccFreightManifests.status, 'submitted'),
        eq(ccFreightManifests.status, 'accepted')
      )
    ),
    orderBy: [asc(ccFreightManifests.manifestDate)]
  });
  
  return manifests;
}

export async function getPendingDeliveries(portalSlug: string): Promise<any[]> {
  const portal = await db.query.ccPortals.findFirst({
    where: eq(ccPortals.slug, portalSlug)
  });
  
  if (!portal) return [];
  
  // Items that are offloaded but not delivered
  const items = await db.query.ccFreightItems.findMany({
    where: eq(ccFreightItems.status, 'offloaded')
  });
  
  // Filter to portal's manifests
  const result: any[] = [];
  for (const item of items) {
    const manifest = await db.query.ccFreightManifests.findFirst({
      where: and(
        eq(ccFreightManifests.id, item.manifestId),
        eq(ccFreightManifests.portalId, portal.id)
      )
    });
    
    if (manifest) {
      result.push({ item, manifest });
    }
  }
  
  return result;
}

export async function getOpenExceptionsBoard(portalSlug: string): Promise<any[]> {
  const portal = await db.query.ccPortals.findFirst({
    where: eq(ccPortals.slug, portalSlug)
  });
  
  if (!portal) return [];
  
  const exceptions = await db.query.ccHandlingExceptions.findMany({
    where: and(
      eq(ccHandlingExceptions.portalId, portal.id),
      or(
        eq(ccHandlingExceptions.status, 'open'),
        eq(ccHandlingExceptions.status, 'investigating'),
        eq(ccHandlingExceptions.status, 'pending_action')
      )
    ),
    orderBy: [
      desc(sql`CASE severity WHEN 'critical' THEN 4 WHEN 'high' THEN 3 WHEN 'medium' THEN 2 ELSE 1 END`),
      asc(ccHandlingExceptions.createdAt)
    ]
  });
  
  // Enrich with manifest info
  const result: any[] = [];
  for (const exc of exceptions) {
    const manifest = await db.query.ccFreightManifests.findFirst({
      where: eq(ccFreightManifests.id, exc.manifestId)
    });
    
    let item = null;
    if (exc.itemId) {
      item = await db.query.ccFreightItems.findFirst({
        where: eq(ccFreightItems.id, exc.itemId)
      });
    }
    
    result.push({
      exception: exc,
      manifest,
      item
    });
  }
  
  return result;
}

// ============ SAILING FREIGHT SUMMARY ============

export async function getSailingFreightSummary(
  portalSlug: string,
  sailingId: string
): Promise<{
  sailing: any;
  manifests: any[];
  totals: {
    manifestCount: number;
    itemCount: number;
    totalWeightLbs: number;
    totalValueCad: number;
    freightChargesCad: number;
  };
  byStatus: Record<string, number>;
}> {
  const portal = await db.query.ccPortals.findFirst({
    where: eq(ccPortals.slug, portalSlug)
  });
  
  if (!portal) {
    return {
      sailing: null,
      manifests: [],
      totals: { manifestCount: 0, itemCount: 0, totalWeightLbs: 0, totalValueCad: 0, freightChargesCad: 0 },
      byStatus: {}
    };
  }
  
  const sailing = await db.query.ccSailings.findFirst({
    where: eq(ccSailings.id, sailingId)
  });
  
  const manifests = await db.query.ccFreightManifests.findMany({
    where: and(
      eq(ccFreightManifests.portalId, portal.id),
      eq(ccFreightManifests.sailingId, sailingId)
    )
  });
  
  let itemCount = 0;
  let totalWeightLbs = 0;
  let totalValueCad = 0;
  let freightChargesCad = 0;
  const byStatus: Record<string, number> = {};
  
  for (const m of manifests) {
    byStatus[m.status] = (byStatus[m.status] || 0) + 1;
    itemCount += m.totalItems || 0;
    totalWeightLbs += Number(m.totalWeightLbs) || 0;
    totalValueCad += Number(m.totalValueCad) || 0;
    freightChargesCad += Number(m.freightChargesCad) || 0;
  }
  
  return {
    sailing,
    manifests,
    totals: {
      manifestCount: manifests.length,
      itemCount,
      totalWeightLbs,
      totalValueCad,
      freightChargesCad
    },
    byStatus
  };
}
```

## Add Freight Board Routes to transport.ts
```typescript
// Add to server/routes/transport.ts

import {
  getFreightBoardSummary, getFreightBoard,
  getPendingPickups, getPendingDeliveries, getOpenExceptionsBoard,
  getSailingFreightSummary
} from '../services/freightBoardService';

// ============ FREIGHT BOARD ENDPOINTS ============

// GET /api/transport/portals/:slug/freight/board - Main freight board
router.get('/portals/:slug/freight/board', async (req, res) => {
  const { slug } = req.params;
  const { date, status, operator, sailing, limit } = req.query;
  
  try {
    const result = await getFreightBoard(slug, {
      date: date ? new Date(date as string) : undefined,
      status: status as string,
      operatorId: operator as string,
      sailingId: sailing as string,
      limit: limit ? parseInt(limit as string) : undefined
    });
    
    res.json(result);
  } catch (e: any) {
    console.error('Get freight board error:', e);
    res.status(500).json({ error: 'Failed to get freight board' });
  }
});

// GET /api/transport/portals/:slug/freight/summary - Daily summary
router.get('/portals/:slug/freight/summary', async (req, res) => {
  const { slug } = req.params;
  const { date } = req.query;
  
  try {
    const summary = await getFreightBoardSummary(
      slug,
      date ? new Date(date as string) : undefined
    );
    
    res.json({ summary });
  } catch (e: any) {
    console.error('Get freight summary error:', e);
    res.status(500).json({ error: 'Failed to get summary' });
  }
});

// GET /api/transport/portals/:slug/freight/pending-pickups - Pickup queue
router.get('/portals/:slug/freight/pending-pickups', async (req, res) => {
  const { slug } = req.params;
  
  try {
    const pickups = await getPendingPickups(slug);
    res.json({ pickups, count: pickups.length });
  } catch (e: any) {
    console.error('Get pending pickups error:', e);
    res.status(500).json({ error: 'Failed to get pickups' });
  }
});

// GET /api/transport/portals/:slug/freight/pending-deliveries - Delivery queue
router.get('/portals/:slug/freight/pending-deliveries', async (req, res) => {
  const { slug } = req.params;
  
  try {
    const deliveries = await getPendingDeliveries(slug);
    res.json({ deliveries, count: deliveries.length });
  } catch (e: any) {
    console.error('Get pending deliveries error:', e);
    res.status(500).json({ error: 'Failed to get deliveries' });
  }
});

// GET /api/transport/portals/:slug/freight/exceptions-board - Open exceptions
router.get('/portals/:slug/freight/exceptions-board', async (req, res) => {
  const { slug } = req.params;
  
  try {
    const exceptions = await getOpenExceptionsBoard(slug);
    res.json({ exceptions, count: exceptions.length });
  } catch (e: any) {
    console.error('Get exceptions board error:', e);
    res.status(500).json({ error: 'Failed to get exceptions' });
  }
});

// GET /api/transport/portals/:slug/sailings/:sailingId/freight-summary - Sailing freight
router.get('/portals/:slug/sailings/:sailingId/freight-summary', async (req, res) => {
  const { slug, sailingId } = req.params;
  
  try {
    const result = await getSailingFreightSummary(slug, sailingId);
    res.json(result);
  } catch (e: any) {
    console.error('Get sailing freight summary error:', e);
    res.status(500).json({ error: 'Failed to get freight summary' });
  }
});
```

## Deliverables
- [ ] server/services/freightBoardService.ts
- [ ] Routes added to server/routes/transport.ts:
  - GET /api/transport/portals/:slug/freight/board
  - GET /api/transport/portals/:slug/freight/summary
  - GET /api/transport/portals/:slug/freight/pending-pickups
  - GET /api/transport/portals/:slug/freight/pending-deliveries
  - GET /api/transport/portals/:slug/freight/exceptions-board
  - GET /api/transport/portals/:slug/sailings/:sailingId/freight-summary
- [ ] Board summary includes:
  - Manifests by status (draft, in-transit, delivered)
  - Item counts by status
  - Weight totals (total, loaded, delivered)
  - Revenue (total, pending, collected)
  - Open exceptions count
- [ ] Board entries include last activity and exception counts
- [ ] Action queues (pending pickups, pending deliveries)
- [ ] Sailing freight summary for load planning
- [ ] Test: GET /api/transport/portals/bamfield/freight/board returns entries with summary
- [ ] Test: Summary shows correct totals from manifests and items

Report with freight board showing summary statistics and manifest entries.