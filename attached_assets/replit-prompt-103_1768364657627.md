# PROMPT 24 - BUNDLE 103: Value Events & Ledger (Functions-Only)

## Context
- Previous migration: 102_jobs_cold_start_communities.sql
- This is migration 103
- Part of Prompt 24B/24C - Monetization hooks and guardrails

## Objective
Create the value capture system with functions-only guardrails (no triggers). This enables monetization of urgency, emergency, replacement, and coordination moments.

## DESIGN DECISION: Functions-Only (Locked)
- No database triggers
- App-level enforcement via helper functions
- Lower blast radius, easy to tighten later
- Functions: cc_has_entitlement, cc_entitlement_value, cc_record_value_event

---

## Migration: server/migrations/103_value_events_ledger_functions.sql

```sql
-- ============================================================
-- MIGRATION 103: VALUE EVENTS & LEDGER (FUNCTIONS-ONLY)
-- Part of Prompt 24B/24C - Monetization Infrastructure
-- ============================================================

BEGIN;

-- ============================================================
-- 1) VALUE EVENTS (Billable Moments)
-- Every monetizable moment is logged here
-- ============================================================

CREATE TYPE value_event_type AS ENUM (
  -- Contractor events
  'worker_placed',
  'run_filled',
  'emergency_replacement',
  'materials_routed',
  
  -- Inventory events
  'occupancy_unlocked',
  'bundle_confirmed',
  
  -- Coordinator events
  'cross_tenant_reservation',
  'incident_resolved',
  
  -- PIC events
  'turnover_orchestrated',
  'workforce_cluster',
  'housing_bundle',
  'emergency_coverage',
  
  -- System events
  'subscription_charge',
  'usage_overage',
  'premium_feature',
  'custom'
);

CREATE TABLE IF NOT EXISTS cc_value_events (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Event type
  event_type value_event_type NOT NULL,
  event_code text,
  
  -- Who
  tenant_id uuid REFERENCES cc_tenants(id),
  party_id uuid REFERENCES cc_parties(id),
  individual_id uuid REFERENCES cc_individuals(id),
  actor_type_id uuid REFERENCES cc_actor_types(id),
  
  -- Context
  related_entity_type text,
  related_entity_id uuid,
  
  -- Value
  base_amount numeric NOT NULL DEFAULT 0,
  scarcity_multiplier numeric DEFAULT 1.0,
  urgency_multiplier numeric DEFAULT 1.0,
  final_amount numeric NOT NULL DEFAULT 0,
  currency text DEFAULT 'CAD',
  
  -- Billing
  is_billable boolean NOT NULL DEFAULT true,
  is_billed boolean DEFAULT false,
  billed_at timestamptz,
  ledger_entry_id uuid,
  
  -- Status
  status text NOT NULL DEFAULT 'pending',
  waived boolean DEFAULT false,
  waived_reason text,
  waived_by_user_id uuid REFERENCES cc_user_profiles(id),
  
  -- Metadata
  metadata jsonb DEFAULT '{}',
  occurred_at timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX idx_cc_value_events_tenant ON cc_value_events(tenant_id);
CREATE INDEX idx_cc_value_events_party ON cc_value_events(party_id);
CREATE INDEX idx_cc_value_events_type ON cc_value_events(event_type);
CREATE INDEX idx_cc_value_events_status ON cc_value_events(status);
CREATE INDEX idx_cc_value_events_billable ON cc_value_events(is_billable, is_billed) WHERE is_billable = true;
CREATE INDEX idx_cc_value_events_occurred ON cc_value_events(occurred_at);
CREATE INDEX idx_cc_value_events_related ON cc_value_events(related_entity_type, related_entity_id);

-- Enable RLS
ALTER TABLE cc_value_events ENABLE ROW LEVEL SECURITY;

CREATE POLICY cc_value_events_service_bypass ON cc_value_events
  FOR ALL
  USING (current_setting('app.tenant_id', true) = '__SERVICE__')
  WITH CHECK (current_setting('app.tenant_id', true) = '__SERVICE__');

CREATE POLICY cc_value_events_tenant_read ON cc_value_events
  FOR SELECT
  USING (tenant_id::text = current_setting('app.tenant_id', true));

-- ============================================================
-- 2) LEDGER ENTRIES (Financial Record)
-- Append-only financial ledger
-- ============================================================

CREATE TYPE ledger_entry_type AS ENUM (
  'charge',
  'payment',
  'credit',
  'adjustment',
  'refund',
  'writeoff'
);

CREATE TABLE IF NOT EXISTS cc_ledger_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Who
  tenant_id uuid REFERENCES cc_tenants(id),
  party_id uuid REFERENCES cc_parties(id),
  individual_id uuid REFERENCES cc_individuals(id),
  
  -- Entry type
  entry_type ledger_entry_type NOT NULL,
  
  -- Amounts
  amount numeric NOT NULL,
  currency text DEFAULT 'CAD',
  
  -- Description
  description text NOT NULL,
  line_item_code text,
  
  -- Source
  source_type text,
  source_id uuid,
  value_event_id uuid REFERENCES cc_value_events(id),
  
  -- Period
  period_start date,
  period_end date,
  
  -- Invoice reference (for grouping)
  invoice_number text,
  invoice_date date,
  
  -- Payment reference
  payment_method text,
  payment_reference text,
  
  -- Status
  status text NOT NULL DEFAULT 'pending',
  
  -- Metadata
  metadata jsonb DEFAULT '{}',
  
  -- Timestamps (append-only - no updated_at)
  created_at timestamptz NOT NULL DEFAULT now(),
  
  -- Constraints
  CONSTRAINT ledger_has_owner CHECK (
    tenant_id IS NOT NULL OR party_id IS NOT NULL OR individual_id IS NOT NULL
  )
);

CREATE INDEX idx_cc_ledger_entries_tenant ON cc_ledger_entries(tenant_id);
CREATE INDEX idx_cc_ledger_entries_party ON cc_ledger_entries(party_id);
CREATE INDEX idx_cc_ledger_entries_type ON cc_ledger_entries(entry_type);
CREATE INDEX idx_cc_ledger_entries_status ON cc_ledger_entries(status);
CREATE INDEX idx_cc_ledger_entries_invoice ON cc_ledger_entries(invoice_number);
CREATE INDEX idx_cc_ledger_entries_value_event ON cc_ledger_entries(value_event_id);
CREATE INDEX idx_cc_ledger_entries_created ON cc_ledger_entries(created_at);

-- Enable RLS
ALTER TABLE cc_ledger_entries ENABLE ROW LEVEL SECURITY;

CREATE POLICY cc_ledger_entries_service_bypass ON cc_ledger_entries
  FOR ALL
  USING (current_setting('app.tenant_id', true) = '__SERVICE__')
  WITH CHECK (current_setting('app.tenant_id', true) = '__SERVICE__');

CREATE POLICY cc_ledger_entries_tenant_read ON cc_ledger_entries
  FOR SELECT
  USING (tenant_id::text = current_setting('app.tenant_id', true));

-- ============================================================
-- 3) HELPER FUNCTION: cc_has_entitlement
-- Check if tenant has a boolean entitlement
-- ============================================================

CREATE OR REPLACE FUNCTION cc_has_entitlement(
  p_tenant_id uuid,
  p_entitlement_key text
) RETURNS boolean AS $$
DECLARE
  v_result boolean;
BEGIN
  -- Check if tenant has active subscription with this entitlement
  SELECT pe.boolean_value INTO v_result
  FROM cc_subscriptions s
  JOIN cc_plans p ON s.plan_id = p.id
  JOIN cc_plan_entitlements pe ON pe.plan_id = p.id
  WHERE s.tenant_id = p_tenant_id
    AND s.status = 'active'
    AND pe.entitlement_key = p_entitlement_key
    AND pe.value_type = 'boolean'
  LIMIT 1;
  
  RETURN COALESCE(v_result, false);
END;
$$ LANGUAGE plpgsql STABLE;

-- ============================================================
-- 4) HELPER FUNCTION: cc_entitlement_value
-- Get numeric entitlement value (NULL = unlimited)
-- ============================================================

CREATE OR REPLACE FUNCTION cc_entitlement_value(
  p_tenant_id uuid,
  p_entitlement_key text
) RETURNS integer AS $$
DECLARE
  v_result integer;
BEGIN
  SELECT pe.numeric_value INTO v_result
  FROM cc_subscriptions s
  JOIN cc_plans p ON s.plan_id = p.id
  JOIN cc_plan_entitlements pe ON pe.plan_id = p.id
  WHERE s.tenant_id = p_tenant_id
    AND s.status = 'active'
    AND pe.entitlement_key = p_entitlement_key
    AND pe.value_type = 'numeric'
  ORDER BY pe.numeric_value DESC NULLS FIRST
  LIMIT 1;
  
  RETURN v_result; -- NULL means unlimited
END;
$$ LANGUAGE plpgsql STABLE;

-- ============================================================
-- 5) HELPER FUNCTION: cc_record_value_event
-- Record a value event and optionally create ledger entry
-- Returns the value_event_id
-- ============================================================

CREATE OR REPLACE FUNCTION cc_record_value_event(
  p_event_type value_event_type,
  p_tenant_id uuid,
  p_actor_type_id uuid,
  p_base_amount numeric,
  p_description text,
  p_related_entity_type text DEFAULT NULL,
  p_related_entity_id uuid DEFAULT NULL,
  p_scarcity_multiplier numeric DEFAULT 1.0,
  p_urgency_multiplier numeric DEFAULT 1.0,
  p_metadata jsonb DEFAULT '{}',
  p_create_ledger_entry boolean DEFAULT true
) RETURNS uuid AS $$
DECLARE
  v_event_id uuid;
  v_ledger_id uuid;
  v_final_amount numeric;
BEGIN
  -- Calculate final amount
  v_final_amount := p_base_amount * p_scarcity_multiplier * p_urgency_multiplier;
  
  -- Insert value event
  INSERT INTO cc_value_events (
    event_type,
    tenant_id,
    actor_type_id,
    base_amount,
    scarcity_multiplier,
    urgency_multiplier,
    final_amount,
    related_entity_type,
    related_entity_id,
    metadata,
    status
  ) VALUES (
    p_event_type,
    p_tenant_id,
    p_actor_type_id,
    p_base_amount,
    p_scarcity_multiplier,
    p_urgency_multiplier,
    v_final_amount,
    p_related_entity_type,
    p_related_entity_id,
    p_metadata,
    'recorded'
  ) RETURNING id INTO v_event_id;
  
  -- Create ledger entry if requested and amount > 0
  IF p_create_ledger_entry AND v_final_amount > 0 THEN
    INSERT INTO cc_ledger_entries (
      tenant_id,
      entry_type,
      amount,
      description,
      source_type,
      source_id,
      value_event_id,
      status
    ) VALUES (
      p_tenant_id,
      'charge',
      v_final_amount,
      p_description,
      'value_event',
      v_event_id,
      v_event_id,
      'pending'
    ) RETURNING id INTO v_ledger_id;
    
    -- Update value event with ledger reference
    UPDATE cc_value_events 
    SET ledger_entry_id = v_ledger_id,
        is_billed = true,
        billed_at = now()
    WHERE id = v_event_id;
  END IF;
  
  RETURN v_event_id;
END;
$$ LANGUAGE plpgsql;

-- ============================================================
-- 6) HELPER FUNCTION: cc_tenant_balance
-- Get current balance for a tenant
-- ============================================================

CREATE OR REPLACE FUNCTION cc_tenant_balance(p_tenant_id uuid)
RETURNS numeric AS $$
DECLARE
  v_charges numeric;
  v_credits numeric;
BEGIN
  -- Sum all charges
  SELECT COALESCE(SUM(amount), 0) INTO v_charges
  FROM cc_ledger_entries
  WHERE tenant_id = p_tenant_id
    AND entry_type IN ('charge')
    AND status != 'voided';
  
  -- Sum all credits/payments
  SELECT COALESCE(SUM(amount), 0) INTO v_credits
  FROM cc_ledger_entries
  WHERE tenant_id = p_tenant_id
    AND entry_type IN ('payment', 'credit', 'refund', 'adjustment', 'writeoff')
    AND status != 'voided';
  
  RETURN v_charges - v_credits;
END;
$$ LANGUAGE plpgsql STABLE;

-- ============================================================
-- 7) SEED BASE EVENT PRICING (for reference)
-- ============================================================

COMMENT ON TYPE value_event_type IS '
Event pricing reference (base amounts):
- worker_placed: $75
- run_filled: $35
- emergency_replacement: $200 (supports scarcity multiplier)
- materials_routed: $50
- occupancy_unlocked: 5% of incremental revenue
- bundle_confirmed: $15
- cross_tenant_reservation: $20
- incident_resolved: $50 (supports scarcity multiplier)
- turnover_orchestrated: $10
- workforce_cluster: $250
- housing_bundle: $50
- emergency_coverage: $100 (supports scarcity multiplier)
- subscription_charge: varies by plan
- usage_overage: varies
- premium_feature: varies
';

COMMIT;
```

---

## Drizzle Schema: Add to shared/schema.ts

```typescript
// ============================================================
// VALUE EVENTS (Bundle 103)
// ============================================================

export const valueEventTypeEnum = pgEnum("value_event_type", [
  "worker_placed", "run_filled", "emergency_replacement", "materials_routed",
  "occupancy_unlocked", "bundle_confirmed",
  "cross_tenant_reservation", "incident_resolved",
  "turnover_orchestrated", "workforce_cluster", "housing_bundle", "emergency_coverage",
  "subscription_charge", "usage_overage", "premium_feature", "custom"
]);

export const ccValueEvents = pgTable("cc_value_events", {
  id: uuid("id").primaryKey().defaultRandom(),
  eventType: valueEventTypeEnum("event_type").notNull(),
  eventCode: text("event_code"),
  
  tenantId: uuid("tenant_id").references(() => ccTenants.id),
  partyId: uuid("party_id").references(() => ccParties.id),
  individualId: uuid("individual_id").references(() => ccIndividuals.id),
  actorTypeId: uuid("actor_type_id").references(() => ccActorTypes.id),
  
  relatedEntityType: text("related_entity_type"),
  relatedEntityId: uuid("related_entity_id"),
  
  baseAmount: numeric("base_amount").notNull().default("0"),
  scarcityMultiplier: numeric("scarcity_multiplier").default("1.0"),
  urgencyMultiplier: numeric("urgency_multiplier").default("1.0"),
  finalAmount: numeric("final_amount").notNull().default("0"),
  currency: text("currency").default("CAD"),
  
  isBillable: boolean("is_billable").notNull().default(true),
  isBilled: boolean("is_billed").default(false),
  billedAt: timestamp("billed_at", { withTimezone: true }),
  ledgerEntryId: uuid("ledger_entry_id"),
  
  status: text("status").notNull().default("pending"),
  waived: boolean("waived").default(false),
  waivedReason: text("waived_reason"),
  waivedByUserId: uuid("waived_by_user_id").references(() => ccUserProfiles.id),
  
  metadata: jsonb("metadata").default({}),
  occurredAt: timestamp("occurred_at", { withTimezone: true }).notNull().defaultNow(),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
}, (table) => ({
  tenantIdx: index("idx_cc_value_events_tenant").on(table.tenantId),
  typeIdx: index("idx_cc_value_events_type").on(table.eventType),
  statusIdx: index("idx_cc_value_events_status").on(table.status),
}));

export type ValueEvent = typeof ccValueEvents.$inferSelect;

// ============================================================
// LEDGER ENTRIES (Bundle 103)
// ============================================================

export const ledgerEntryTypeEnum = pgEnum("ledger_entry_type", [
  "charge", "payment", "credit", "adjustment", "refund", "writeoff"
]);

export const ccLedgerEntries = pgTable("cc_ledger_entries", {
  id: uuid("id").primaryKey().defaultRandom(),
  
  tenantId: uuid("tenant_id").references(() => ccTenants.id),
  partyId: uuid("party_id").references(() => ccParties.id),
  individualId: uuid("individual_id").references(() => ccIndividuals.id),
  
  entryType: ledgerEntryTypeEnum("entry_type").notNull(),
  amount: numeric("amount").notNull(),
  currency: text("currency").default("CAD"),
  
  description: text("description").notNull(),
  lineItemCode: text("line_item_code"),
  
  sourceType: text("source_type"),
  sourceId: uuid("source_id"),
  valueEventId: uuid("value_event_id").references(() => ccValueEvents.id),
  
  periodStart: date("period_start"),
  periodEnd: date("period_end"),
  
  invoiceNumber: text("invoice_number"),
  invoiceDate: date("invoice_date"),
  
  paymentMethod: text("payment_method"),
  paymentReference: text("payment_reference"),
  
  status: text("status").notNull().default("pending"),
  metadata: jsonb("metadata").default({}),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
}, (table) => ({
  tenantIdx: index("idx_cc_ledger_entries_tenant").on(table.tenantId),
  typeIdx: index("idx_cc_ledger_entries_type").on(table.entryType),
  statusIdx: index("idx_cc_ledger_entries_status").on(table.status),
  valueEventIdx: index("idx_cc_ledger_entries_value_event").on(table.valueEventId),
}));

export type LedgerEntry = typeof ccLedgerEntries.$inferSelect;
```

---

## TypeScript Service: server/services/entitlements.ts

```typescript
import { db } from "../db";
import { sql } from "drizzle-orm";

export class EntitlementService {
  /**
   * Check if tenant has a boolean entitlement
   */
  async hasEntitlement(tenantId: string, entitlementKey: string): Promise<boolean> {
    const result = await db.execute(
      sql`SELECT cc_has_entitlement(${tenantId}::uuid, ${entitlementKey}) as has_it`
    );
    return result.rows[0]?.has_it ?? false;
  }

  /**
   * Get numeric entitlement value (null = unlimited)
   */
  async getEntitlementValue(tenantId: string, entitlementKey: string): Promise<number | null> {
    const result = await db.execute(
      sql`SELECT cc_entitlement_value(${tenantId}::uuid, ${entitlementKey}) as value`
    );
    return result.rows[0]?.value ?? null;
  }

  /**
   * Get tenant's current balance
   */
  async getTenantBalance(tenantId: string): Promise<number> {
    const result = await db.execute(
      sql`SELECT cc_tenant_balance(${tenantId}::uuid) as balance`
    );
    return Number(result.rows[0]?.balance ?? 0);
  }

  /**
   * Record a value event and optionally create ledger entry
   */
  async recordValueEvent(params: {
    eventType: string;
    tenantId: string;
    actorTypeId: string;
    baseAmount: number;
    description: string;
    relatedEntityType?: string;
    relatedEntityId?: string;
    scarcityMultiplier?: number;
    urgencyMultiplier?: number;
    metadata?: Record<string, any>;
    createLedgerEntry?: boolean;
  }): Promise<string> {
    const result = await db.execute(sql`
      SELECT cc_record_value_event(
        ${params.eventType}::value_event_type,
        ${params.tenantId}::uuid,
        ${params.actorTypeId}::uuid,
        ${params.baseAmount}::numeric,
        ${params.description},
        ${params.relatedEntityType ?? null},
        ${params.relatedEntityId ?? null}::uuid,
        ${params.scarcityMultiplier ?? 1.0}::numeric,
        ${params.urgencyMultiplier ?? 1.0}::numeric,
        ${JSON.stringify(params.metadata ?? {})}::jsonb,
        ${params.createLedgerEntry ?? true}
      ) as event_id
    `);
    return result.rows[0]?.event_id;
  }
}

export const entitlementService = new EntitlementService();
```

---

## Acceptance Criteria

1. [ ] Migration 103 runs without errors
2. [ ] cc_value_events table created with all columns
3. [ ] cc_ledger_entries table created with owner constraint
4. [ ] value_event_type enum created with all event types
5. [ ] ledger_entry_type enum created
6. [ ] cc_has_entitlement function created and works
7. [ ] cc_entitlement_value function created and works
8. [ ] cc_record_value_event function created and works
9. [ ] cc_tenant_balance function created and works
10. [ ] RLS enabled on both tables
11. [ ] NO triggers created (functions-only approach)
12. [ ] Drizzle schema updated and synced

---

## Test Queries

```sql
-- Verify tables exist
SELECT table_name 
FROM information_schema.tables 
WHERE table_schema = 'public' 
  AND table_name IN ('cc_value_events', 'cc_ledger_entries');

-- Verify functions exist
SELECT routine_name 
FROM information_schema.routines 
WHERE routine_schema = 'public' 
  AND routine_name IN ('cc_has_entitlement', 'cc_entitlement_value', 'cc_record_value_event', 'cc_tenant_balance');

-- Verify no triggers on these tables
SELECT trigger_name 
FROM information_schema.triggers 
WHERE event_object_table IN ('cc_value_events', 'cc_ledger_entries');
-- Should return 0 rows

-- Test functions (use a real tenant_id after seeding)
-- SELECT cc_has_entitlement('your-tenant-uuid', 'workforce_attraction');
-- SELECT cc_entitlement_value('your-tenant-uuid', 'max_regions');
-- SELECT cc_tenant_balance('your-tenant-uuid');
```
