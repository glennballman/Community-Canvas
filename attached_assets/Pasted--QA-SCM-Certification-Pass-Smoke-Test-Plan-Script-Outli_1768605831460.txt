✅ QA → SCM Certification Pass: Smoke Test Plan + Script Outline (P2 Operator Spine)

Below is an exact, repo-ready plan to add an end-to-end smoke test that proves:

Operator actions work (Emergency / Legal / Insurance / Dispute / Authority)

Audit is written (tamper-evident operator_events)

Monetization events are emitted (cc_monetization_events)

Authority grants can be issued + revoked and status updates correctly

This is designed to run in CI and produce SCM-ready proof artifacts (JSON + markdown).

1) Test Matrix (What we certify)
A) Emergency Run Spine

Start run

Grant scope (create)

Export playbook

Generate record pack

Share authority

Revoke authority grant

Resolve run

Proof signals: operator events exist for each action; monetization counts increment for export/share/pack; grant status transitions to revoked.

B) Legal Hold Spine

Create legal hold

Add target (run/pack/dossier/defense pack depending on what exists)

Release hold

Proof signals: hold state transitions; operator events for create/target/release.

C) Insurance Spine

Assemble dossier for claimId

Export dossier

Share dossier authority

Revoke grant (optional but ideal)

Proof signals: dossierId returned; operator events; monetization events for export/share.

D) Dispute Spine

Assemble defense pack for disputeId

Export defense pack

Share defense pack authority

Revoke grant (optional but ideal)

Proof signals: defensePackId returned; operator events; monetization events for export/share.

2) Preconditions & Inputs (No guessing at runtime)

Because claimId/disputeId may not exist in a clean env, the test supports two modes:

Mode 1: “Live IDs” (recommended for now)

Provide IDs via env vars:

QA_CLAIM_ID

QA_DISPUTE_ID

Mode 2: “Skip optional modules”

If IDs are missing, Insurance/Dispute flows are skipped but Emergency/Legal/Authority still certify.

3) Script location and outputs

Create:

scripts/qa/qa-operator-p2-smoke.ts

scripts/qa/qa-proof-writer.ts (helper)

Output folder: artifacts/qa/

The script should write:

artifacts/qa/p2-smoke-proof.json (machine-readable)

artifacts/qa/p2-smoke-proof.md (human-readable report)

4) Auth approach (works with your existing JWT)

You have two viable approaches—implement both; the script will use whichever is provided.

Option A: Direct JWT (best for CI)

Env var:

QA_JWT (raw JWT string)

Send header:

Authorization: Bearer ${QA_JWT}

Option B: Cookie session (dev convenience)

Env var:

QA_COOKIE (full cookie header value)

Send header:

Cookie: ${QA_COOKIE}

If your API only accepts cookies, use Option B. If it accepts Bearer, Option A is cleaner.

5) Endpoint calls (P2-only, envelope enforced)

All calls must:

hit /api/operator/p2/...

require { ok: true } success

throw if { ok: false, error }

Required endpoints (already implemented in your system)

Emergency:

POST /api/operator/p2/emergency/runs/start → { runId }

POST /api/operator/p2/emergency/runs/:runId/grants → { grantId? }

POST /api/operator/p2/emergency/runs/:runId/export-playbook

POST /api/operator/p2/emergency/runs/:runId/generate-record-pack

POST /api/operator/p2/emergency/runs/:runId/share-authority → { grantId?, accessUrl?, expiresAt? }

POST /api/operator/p2/emergency/runs/:runId/resolve

Legal:

POST /api/operator/p2/legal/holds → { holdId }

POST /api/operator/p2/legal/holds/:holdId/targets

POST /api/operator/p2/legal/holds/:holdId/release

Authority:

GET /api/operator/p2/authority/grants/:grantId → status/scopes/tokens

POST /api/operator/p2/authority/grants/:grantId/revoke (reason required)

Monetization usage:

GET /api/operator/p2/monetization/usage?period=YYYY-MM&includeDrills=0 → counts

Audit:

GET /api/operator/p2/audit/events?limit=200 (or your implemented path)

Optional:
Insurance (if QA_CLAIM_ID provided):

POST /api/operator/p2/insurance/claims/:claimId/assemble → { dossierId }

POST /api/operator/p2/insurance/dossiers/:dossierId/export

POST /api/operator/p2/insurance/dossiers/:dossierId/share-authority → { grantId }

Dispute (if QA_DISPUTE_ID provided):

POST /api/operator/p2/disputes/:disputeId/assemble-defense-pack → { defensePackId }

POST /api/operator/p2/defense-packs/:defensePackId/export

POST /api/operator/p2/defense-packs/:defensePackId/share-authority → { grantId }

6) Script outline (TypeScript, node 18+)
6.1 scripts/qa/qa-operator-p2-smoke.ts (skeleton)
import fs from "fs";
import path from "path";

type P2Ok<T extends object> = { ok: true } & T;
type P2Err = { ok: false; error: string };
type P2Resp<T extends object> = P2Ok<T> | P2Err;

const BASE = process.env.QA_BASE_URL || "http://localhost:3000";
const JWT = process.env.QA_JWT;
const COOKIE = process.env.QA_COOKIE;

const CLAIM_ID = process.env.QA_CLAIM_ID;
const DISPUTE_ID = process.env.QA_DISPUTE_ID;

function assert(cond: any, msg: string): asserts cond {
  if (!cond) throw new Error(msg);
}

async function p2<T extends object>(method: string, urlPath: string, body?: any): Promise<P2Ok<T>> {
  const headers: Record<string, string> = { "Content-Type": "application/json" };
  if (JWT) headers["Authorization"] = `Bearer ${JWT}`;
  if (COOKIE) headers["Cookie"] = COOKIE;

  const res = await fetch(`${BASE}${urlPath}`, {
    method,
    headers,
    body: body ? JSON.stringify(body) : undefined
  });

  const json = (await res.json()) as P2Resp<T>;
  assert(json && typeof (json as any).ok === "boolean", `Invalid response envelope from ${urlPath}`);
  if (json.ok === false) throw new Error(`${urlPath} failed: ${json.error}`);
  return json;
}

function nowIso() {
  return new Date().toISOString();
}

function ensureArtifactsDir() {
  const dir = path.resolve("artifacts/qa");
  fs.mkdirSync(dir, { recursive: true });
  return dir;
}

async function main() {
  assert(JWT || COOKIE, "Provide QA_JWT or QA_COOKIE");
  const artifactsDir = ensureArtifactsDir();

  const proof: any = {
    startedAt: nowIso(),
    baseUrl: BASE,
    steps: [],
    ids: {},
    assertions: [],
    monetization: {},
    audit: {}
  };

  // --- Emergency: start run
  const start = await p2<{ runId: string }>(
    "POST",
    "/api/operator/p2/emergency/runs/start",
    { runType: "storm", summary: "QA smoke test" }
  );
  proof.steps.push({ step: "emergency.start", ok: true, runId: start.runId });
  proof.ids.runId = start.runId;

  // --- Emergency: grant scope (best-effort)
  // Use a known test individual if you have one; otherwise skip if backend requires it.
  if (process.env.QA_GRANTEE_INDIVIDUAL_ID) {
    const grantee = process.env.QA_GRANTEE_INDIVIDUAL_ID;
    await p2(
      "POST",
      `/api/operator/p2/emergency/runs/${start.runId}/grants`,
      {
        granteeIndividualId: grantee,
        grantType: "tool_access",
        scopeJson: { note: "qa" },
        expiresAt: new Date(Date.now() + 60 * 60 * 1000).toISOString()
      }
    );
    proof.steps.push({ step: "emergency.grantScope", ok: true });
  } else {
    proof.steps.push({ step: "emergency.grantScope", ok: "skipped_missing_QA_GRANTEE_INDIVIDUAL_ID" });
  }

  // --- Export playbook
  await p2("POST", `/api/operator/p2/emergency/runs/${start.runId}/export-playbook`, { format: "zip_json" });
  proof.steps.push({ step: "emergency.exportPlaybook", ok: true });

  // --- Generate record pack
  await p2("POST", `/api/operator/p2/emergency/runs/${start.runId}/generate-record-pack`, { sealBundle: true });
  proof.steps.push({ step: "emergency.generateRecordPack", ok: true });

  // --- Share authority
  const share = await p2<{ grantId?: string; accessUrl?: string; expiresAt?: string }>(
    "POST",
    `/api/operator/p2/emergency/runs/${start.runId}/share-authority`,
    { scope: "run_only" }
  );
  proof.steps.push({ step: "emergency.shareAuthority", ok: true, ...share });
  const grantId = share.grantId;
  if (grantId) proof.ids.emergencyGrantId = grantId;

  // --- Grant fetch + revoke (if grantId returned)
  if (grantId) {
    const g1 = await p2<any>("GET", `/api/operator/p2/authority/grants/${grantId}`);
    proof.steps.push({ step: "authority.getGrant", ok: true, status: g1.status, scopes: g1.scopes });

    await p2("POST", `/api/operator/p2/authority/grants/${grantId}/revoke`, { reason: "QA smoke test revoke" });
    proof.steps.push({ step: "authority.revokeGrant", ok: true });

    const g2 = await p2<any>("GET", `/api/operator/p2/authority/grants/${grantId}`);
    proof.steps.push({ step: "authority.getGrantAfterRevoke", ok: true, status: g2.status });
    proof.assertions.push({ assert: "grant_status_revoked", pass: String(g2.status).toLowerCase().includes("revok") });
  } else {
    proof.steps.push({ step: "authority.revoke", ok: "skipped_no_grantId_returned" });
  }

  // --- Resolve run
  await p2("POST", `/api/operator/p2/emergency/runs/${start.runId}/resolve`, { summary: "QA resolved" });
  proof.steps.push({ step: "emergency.resolve", ok: true });

  // --- Legal hold create + target + release
  const hold = await p2<{ holdId: string }>("POST", "/api/operator/p2/legal/holds", {
    holdType: "regulatory",
    title: "QA hold",
    reason: "QA smoke test"
  });
  proof.steps.push({ step: "legal.createHold", ok: true, holdId: hold.holdId });
  proof.ids.holdId = hold.holdId;

  await p2("POST", `/api/operator/p2/legal/holds/${hold.holdId}/targets`, {
    targetType: "emergency_run",
    targetId: start.runId,
    note: "QA links run to hold"
  });
  proof.steps.push({ step: "legal.addTarget", ok: true });

  await p2("POST", `/api/operator/p2/legal/holds/${hold.holdId}/release`, { reason: "QA release" });
  proof.steps.push({ step: "legal.releaseHold", ok: true });

  // --- Optional: Insurance
  if (CLAIM_ID) {
    const dos = await p2<{ dossierId: string }>("POST", `/api/operator/p2/insurance/claims/${CLAIM_ID}/assemble`, {});
    proof.ids.dossierId = dos.dossierId;
    proof.steps.push({ step: "insurance.assembleDossier", ok: true, dossierId: dos.dossierId });

    await p2("POST", `/api/operator/p2/insurance/dossiers/${dos.dossierId}/export`, { format: "zip_json" });
    proof.steps.push({ step: "insurance.exportDossier", ok: true });

    const s = await p2<{ grantId?: string }>(
      "POST",
      `/api/operator/p2/insurance/dossiers/${dos.dossierId}/share-authority`,
      { scope: "dossier_only" }
    );
    proof.steps.push({ step: "insurance.shareAuthority", ok: true, ...s });
  } else {
    proof.steps.push({ step: "insurance", ok: "skipped_missing_QA_CLAIM_ID" });
  }

  // --- Optional: Dispute
  if (DISPUTE_ID) {
    const pack = await p2<{ defensePackId: string }>(
      "POST",
      `/api/operator/p2/disputes/${DISPUTE_ID}/assemble-defense-pack`,
      {}
    );
    proof.ids.defensePackId = pack.defensePackId;
    proof.steps.push({ step: "dispute.assembleDefensePack", ok: true, defensePackId: pack.defensePackId });

    await p2("POST", `/api/operator/p2/defense-packs/${pack.defensePackId}/export`, { format: "zip_json" });
    proof.steps.push({ step: "dispute.exportDefensePack", ok: true });

    const s = await p2<{ grantId?: string }>(
      "POST",
      `/api/operator/p2/defense-packs/${pack.defensePackId}/share-authority`,
      { scope: "defense_pack_only" }
    );
    proof.steps.push({ step: "dispute.shareAuthority", ok: true, ...s });
  } else {
    proof.steps.push({ step: "dispute", ok: "skipped_missing_QA_DISPUTE_ID" });
  }

  // --- Monetization usage snapshot
  const period = new Date().toISOString().slice(0, 7);
  const usage = await p2<{ period: string; counts: Array<{ eventType: string; count: number }> }>(
    "GET",
    `/api/operator/p2/monetization/usage?period=${period}&includeDrills=0`
  );
  proof.monetization = usage;
  proof.steps.push({ step: "monetization.usage", ok: true, period: usage.period, countRows: usage.counts.length });

  // --- Audit events snapshot (best-effort)
  try {
    const audit = await p2<any>("GET", `/api/operator/p2/audit/events?limit=200`);
    proof.audit = audit;
    proof.steps.push({ step: "audit.events", ok: true });
  } catch (e: any) {
    proof.steps.push({ step: "audit.events", ok: "failed", error: String(e?.message || e) });
  }

  proof.finishedAt = nowIso();

  // Write artifacts
  fs.writeFileSync(path.join(artifactsDir, "p2-smoke-proof.json"), JSON.stringify(proof, null, 2), "utf8");

  // Simple markdown report
  const md = [
    `# P2 Operator Smoke Proof`,
    ``,
    `- Started: ${proof.startedAt}`,
    `- Finished: ${proof.finishedAt}`,
    `- Base: ${proof.baseUrl}`,
    ``,
    `## IDs`,
    "```json",
    JSON.stringify(proof.ids, null, 2),
    "```",
    ``,
    `## Steps`,
    ...proof.steps.map((s: any) => `- **${s.step}**: ${typeof s.ok === "string" ? s.ok : s.ok ? "PASS" : "FAIL"}`),
    ``,
    `## Assertions`,
    ...proof.assertions.map((a: any) => `- ${a.assert}: ${a.pass ? "PASS" : "FAIL"}`)
  ].join("\n");
  fs.writeFileSync(path.join(artifactsDir, "p2-smoke-proof.md"), md, "utf8");

  console.log("✅ Wrote proof artifacts to artifacts/qa/");
}

main().catch((e) => {
  console.error("❌ Smoke test failed:", e);
  process.exit(1);
});

Key env vars supported

QA_BASE_URL (default http://localhost:3000)

QA_JWT or QA_COOKIE

QA_CLAIM_ID (optional)

QA_DISPUTE_ID (optional)

QA_GRANTEE_INDIVIDUAL_ID (optional)

7) SCM-ready certification outputs (how to use these artifacts)

You now have:

p2-smoke-proof.json → machine truth

p2-smoke-proof.md → human proof

Next, you can add a lightweight SCM ingest (optional):

scripts/qa/scm-ingest.ts that reads p2-smoke-proof.json and writes:

artifacts/qa/scm/p2-operator-cert.json

with certifiable: true/false per module based on step PASS + assertions.

8) Add a single CI command

Run:

npx tsx scripts/qa/qa-operator-p2-smoke.ts


If you already have CI runners:

export QA_JWT (recommended)

(optional) export QA_CLAIM_ID, QA_DISPUTE_ID