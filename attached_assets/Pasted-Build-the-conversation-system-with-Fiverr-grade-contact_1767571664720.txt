Build the conversation system with Fiverr-grade contact gating. This uses the party resolver and contact redaction libraries.

### File: server/lib/partyResolver.ts
```typescript
import { pool } from '../db';

export type PartyRole = 'owner' | 'contractor' | 'operator';

export interface ResolvedActor {
  individual_id: string;
  tenant_id: string | null;
  actor_party_id: string;
  party_kind: 'individual' | 'organization';
  display_name: string;
}

function getIndividualId(req: any): string | null {
  return req?.ctx?.individual_id || req?.user?.id || null;
}

/**
 * Hybrid Party Resolution (Option C)
 * - If tenant_id exists: ensure org party exists, ensure membership
 * - If no tenant_id: create/find individual party
 */
export async function resolveActorParty(req: any, role: PartyRole): Promise<ResolvedActor | null> {
  const individual_id = getIndividualId(req);
  const tenant_id = req?.ctx?.tenant_id || null;

  if (!individual_id) {
    console.warn('resolveActorParty: No individual_id found in request');
    return null;
  }

  const client = await pool.connect();
  try {
    await client.query('BEGIN');

    const individualResult = await client.query(
      `SELECT COALESCE(NULLIF(preferred_name, ''), full_name) AS display_name
       FROM cc_individuals WHERE id = $1`,
      [individual_id]
    );
    const individualDisplayName = individualResult.rows[0]?.display_name || 'Unknown User';

    // TENANT (ORG) CONTEXT
    if (tenant_id) {
      const orgPartyResult = await client.query(
        `SELECT id, trade_name, legal_name FROM parties
         WHERE tenant_id = $1 AND party_kind = 'organization'
         ORDER BY created_at ASC LIMIT 1`,
        [tenant_id]
      );

      let org_party_id = orgPartyResult.rows[0]?.id as string | undefined;
      let org_display_name = orgPartyResult.rows[0]?.trade_name || 
                             orgPartyResult.rows[0]?.legal_name || 'Unknown Organization';

      if (!org_party_id) {
        const tenantResult = await client.query(
          `SELECT name, email, phone, business_number,
                  address_line1, address_line2, city, province, postal_code, country
           FROM tenants WHERE id = $1`,
          [tenant_id]
        );

        const tenant = tenantResult.rows[0];
        if (!tenant?.name) {
          await client.query('ROLLBACK');
          console.error('resolveActorParty: Tenant not found or missing name');
          return null;
        }

        const createResult = await client.query(
          `INSERT INTO parties (
              tenant_id, party_kind, party_type, status,
              legal_name, trade_name, tax_id,
              primary_contact_email, primary_contact_phone,
              address_line1, address_line2, city, province, postal_code, country
           ) VALUES ($1, 'organization', $2::party_type, 'active', $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
           RETURNING id, trade_name, legal_name`,
          [
            tenant_id, role, tenant.name, tenant.name,
            tenant.business_number || null,
            tenant.email || null, tenant.phone || null,
            tenant.address_line1 || null, tenant.address_line2 || null,
            tenant.city || null, tenant.province || 'BC',
            tenant.postal_code || null, tenant.country || 'CA'
          ]
        );

        org_party_id = createResult.rows[0].id;
        org_display_name = createResult.rows[0].trade_name || createResult.rows[0].legal_name;
      }

      // Ensure membership
      await client.query(
        `INSERT INTO party_memberships (party_id, individual_id, role, is_active)
         VALUES ($1, $2, 'admin', true)
         ON CONFLICT (party_id, individual_id)
         DO UPDATE SET is_active = true, updated_at = now()`,
        [org_party_id, individual_id]
      );

      await client.query('COMMIT');

      return {
        individual_id,
        tenant_id,
        actor_party_id: org_party_id,
        party_kind: 'organization',
        display_name: org_display_name
      };
    }

    // NO TENANT - Individual party
    const existingIndParty = await client.query(
      `SELECT id, trade_name, legal_name FROM parties
       WHERE party_kind = 'individual' AND metadata->>'individual_id' = $1
       ORDER BY created_at ASC LIMIT 1`,
      [individual_id]
    );

    let ind_party_id = existingIndParty.rows[0]?.id as string | undefined;
    let ind_display_name = existingIndParty.rows[0]?.trade_name || 
                           existingIndParty.rows[0]?.legal_name || 
                           individualDisplayName;

    if (!ind_party_id) {
      const createResult = await client.query(
        `INSERT INTO parties (party_kind, party_type, status, legal_name, trade_name, metadata)
         VALUES ('individual', $1::party_type, 'active', $2, $2, jsonb_build_object('individual_id', $3))
         RETURNING id, trade_name`,
        [role, individualDisplayName, individual_id]
      );

      ind_party_id = createResult.rows[0].id;
      ind_display_name = createResult.rows[0].trade_name;
    }

    await client.query('COMMIT');

    return {
      individual_id,
      tenant_id: null,
      actor_party_id: ind_party_id,
      party_kind: 'individual',
      display_name: ind_display_name
    };

  } catch (error) {
    await client.query('ROLLBACK');
    console.error('resolveActorParty error:', error);
    throw error;
  } finally {
    client.release();
  }
}

export async function isPartyMember(party_id: string, individual_id: string): Promise<boolean> {
  const result = await pool.query(
    `SELECT 1 FROM party_memberships 
     WHERE party_id = $1 AND individual_id = $2 AND is_active = true LIMIT 1`,
    [party_id, individual_id]
  );
  return result.rows.length > 0;
}

/**
 * Check if contact can be unlocked for a conversation
 * Gates: prior_relationship OR deposit_verified OR owner_override
 */
export async function canUnlockContact(conversation_id: string): Promise<{
  canUnlock: boolean;
  gate: string;
  reason: string;
}> {
  const client = await pool.connect();
  try {
    const convResult = await client.query(
      `SELECT * FROM conversations WHERE id = $1`,
      [conversation_id]
    );

    if (convResult.rows.length === 0) {
      return { canUnlock: false, gate: 'none', reason: 'Conversation not found' };
    }

    const conv = convResult.rows[0];

    if (conv.contact_unlocked) {
      return { canUnlock: true, gate: conv.contact_unlock_gate || 'already_unlocked', reason: 'Contact already unlocked' };
    }

    // Check prior relationship
    const priorResult = await client.query(
      `SELECT 1 FROM conversations
       WHERE contractor_party_id = $1 AND owner_party_id = $2
         AND state = 'completed' AND id != $3 LIMIT 1`,
      [conv.contractor_party_id, conv.owner_party_id, conversation_id]
    );

    if (priorResult.rows.length > 0) {
      return { canUnlock: true, gate: 'prior_relationship', reason: 'Prior completed work together' };
    }

    // Check deposit verified
    const depositResult = await client.query(
      `SELECT 1 FROM payment_promises pp
       JOIN payment_milestones pm ON pm.payment_promise_id = pp.id
       WHERE pp.conversation_id = $1
         AND pm.trigger_type IN ('on_award', 'on_contract_sign')
         AND pm.status = 'verified' LIMIT 1`,
      [conversation_id]
    );

    if (depositResult.rows.length > 0) {
      return { canUnlock: true, gate: 'deposit_verified', reason: 'Deposit has been verified' };
    }

    return { canUnlock: false, gate: 'none', reason: 'Deposit required before contact details can be shared' };
  } finally {
    client.release();
  }
}
```

### File: server/lib/contactRedaction.ts
```typescript
/**
 * Tiered Contact Redaction Engine
 * Tier 1: Always redact (high confidence) - emails, URLs, phone numbers
 * Tier 2: Conditional redact - only if Tier 1 triggered OR social keywords present
 */

const TIER1_PATTERNS = [
  { name: 'phone_dashed', regex: /\b\d{3}[-.\s]\d{3}[-.\s]\d{4}\b/g },
  { name: 'phone_parens', regex: /\(\d{3}\)\s*\d{3}[-.\s]?\d{4}/g },
  { name: 'phone_intl', regex: /\+1\s*\d{3}[-.\s]?\d{3}[-.\s]?\d{4}/g },
  { name: 'phone_10digit', regex: /\b\d{10}\b/g },
  { name: 'email', regex: /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b/g },
  { name: 'email_obfuscated', regex: /\b[A-Za-z0-9._%+-]+\s*(at|@)\s*[A-Za-z0-9.-]+\s*(dot|\.)\s*(com|ca|net|org|io)\b/gi },
  { name: 'url_http', regex: /https?:\/\/[^\s]+/g },
  { name: 'url_www', regex: /www\.[^\s]+/g },
];

const TIER2_PATTERNS = [
  { name: 'phone_spelled', regex: /\b(two|three|four|five|six|seven|eight|nine)\s+(five|zero|one|two|three|four|six|seven|eight|nine)\s+(zero|one|two|three|four|five|six|seven|eight|nine)/gi },
];

const SOCIAL_KEYWORDS = /\b(instagram|ig|facebook|fb|whatsapp|telegram|signal|messenger|snapchat|tiktok|twitter|x\.com)\b/i;
const CONTACT_INTENT = /\b(text|call|phone|email|message|reach|contact)\s*(me|us)\b/gi;

export interface RedactionResult {
  wasRedacted: boolean;
  cleanContent: string;
  originalContent: string;
  detectedItems: Array<{ tier: 1 | 2; type: string; value: string }>;
  hasContactIntent: boolean;
}

export function redactContactInfo(content: string): RedactionResult {
  let cleanContent = content;
  const detectedItems: RedactionResult['detectedItems'] = [];
  let tier1Triggered = false;

  const hasSocialKeywords = SOCIAL_KEYWORDS.test(content);
  const hasContactIntent = CONTACT_INTENT.test(content);

  // Apply Tier 1 (always)
  for (const pattern of TIER1_PATTERNS) {
    const matches = content.match(pattern.regex);
    if (matches) {
      tier1Triggered = true;
      for (const match of matches) {
        if (!detectedItems.find(d => d.value === match)) {
          detectedItems.push({ tier: 1, type: pattern.name, value: match });
        }
        cleanContent = cleanContent.replace(new RegExp(escapeRegex(match), 'g'), '[contact info protected]');
      }
    }
  }

  // Apply Tier 2 only if Tier 1 triggered OR social keywords present
  if (tier1Triggered || hasSocialKeywords) {
    for (const pattern of TIER2_PATTERNS) {
      const matches = content.match(pattern.regex);
      if (matches) {
        for (const match of matches) {
          if (!detectedItems.find(d => d.value === match)) {
            detectedItems.push({ tier: 2, type: pattern.name, value: match });
          }
          cleanContent = cleanContent.replace(new RegExp(escapeRegex(match), 'g'), '[contact info protected]');
        }
      }
    }
  }

  return { wasRedacted: detectedItems.length > 0, cleanContent, originalContent: content, detectedItems, hasContactIntent };
}

function escapeRegex(string: string): string {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

export function shouldBlockMessage(conversation_id: string, recent_redaction_count: number): { blocked: boolean; reason?: string } {
  if (recent_redaction_count >= 3) {
    return { blocked: false, reason: 'Multiple contact sharing attempts detected. Please wait for deposit confirmation.' };
  }
  return { blocked: false };
}
```

### File: server/routes/conversations.ts
```typescript
import { Router, Request, Response } from 'express';
import { pool } from '../db';
import { resolveActorParty, canUnlockContact } from '../lib/partyResolver';
import { redactContactInfo, shouldBlockMessage } from '../lib/contactRedaction';

const router = Router();

// ============================================================
// CREATE OR GET CONVERSATION
// ============================================================
router.post('/conversations', async (req: Request, res: Response) => {
  try {
    const { opportunity_id } = req.body;

    if (!opportunity_id) {
      return res.status(400).json({ error: 'opportunity_id required' });
    }

    const contractor = await resolveActorParty(req, 'contractor');
    if (!contractor) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const client = await pool.connect();
    try {
      await client.query('BEGIN');

      // Get opportunity
      const oppResult = await client.query(
        `SELECT o.id, o.owner_tenant_id, o.title FROM opportunities o WHERE o.id = $1`,
        [opportunity_id]
      );

      if (oppResult.rows.length === 0) {
        await client.query('ROLLBACK');
        return res.status(404).json({ error: 'Opportunity not found' });
      }

      const opp = oppResult.rows[0];

      if (!opp.owner_tenant_id) {
        await client.query('ROLLBACK');
        return res.status(400).json({ error: 'Opportunity has no owner' });
      }

      // Find or create owner party
      let ownerPartyResult = await client.query(
        `SELECT id FROM parties WHERE tenant_id = $1 AND party_kind = 'organization' ORDER BY created_at ASC LIMIT 1`,
        [opp.owner_tenant_id]
      );

      let ownerPartyId = ownerPartyResult.rows[0]?.id;

      if (!ownerPartyId) {
        const ownerTenantResult = await client.query(
          `SELECT name, email, phone FROM tenants WHERE id = $1`,
          [opp.owner_tenant_id]
        );
        const ownerTenant = ownerTenantResult.rows[0];

        if (!ownerTenant?.name) {
          await client.query('ROLLBACK');
          return res.status(400).json({ error: 'Owner tenant not found' });
        }

        const createOwnerResult = await client.query(
          `INSERT INTO parties (tenant_id, party_kind, party_type, status, legal_name, trade_name, primary_contact_email, primary_contact_phone)
           VALUES ($1, 'organization', 'owner', 'active', $2, $2, $3, $4) RETURNING id`,
          [opp.owner_tenant_id, ownerTenant.name, ownerTenant.email, ownerTenant.phone]
        );
        ownerPartyId = createOwnerResult.rows[0].id;
      }

      if (contractor.actor_party_id === ownerPartyId) {
        await client.query('ROLLBACK');
        return res.status(400).json({ error: 'Cannot start conversation with yourself' });
      }

      // Check existing
      const existingResult = await client.query(
        `SELECT * FROM conversations WHERE opportunity_id = $1 AND contractor_party_id = $2`,
        [opportunity_id, contractor.actor_party_id]
      );

      if (existingResult.rows.length > 0) {
        await client.query('COMMIT');
        return res.json({ 
          conversation: existingResult.rows[0], 
          created: false,
          actor: { party_id: contractor.actor_party_id, individual_id: contractor.individual_id, display_name: contractor.display_name }
        });
      }

      // Check prior relationship
      const priorResult = await client.query(
        `SELECT 1 FROM conversations WHERE contractor_party_id = $1 AND owner_party_id = $2 AND state = 'completed' LIMIT 1`,
        [contractor.actor_party_id, ownerPartyId]
      );
      const hasPriorRelationship = priorResult.rows.length > 0;

      // Create conversation
      const createResult = await client.query(
        `INSERT INTO conversations (
          opportunity_id, contractor_party_id, owner_party_id,
          contractor_actor_party_id, owner_actor_party_id,
          state, contact_unlocked, contact_unlock_gate, contact_unlock_reason
        ) VALUES ($1, $2, $3, $4, $5, 'interest', $6, $7, $8)
        RETURNING *`,
        [
          opportunity_id, contractor.actor_party_id, ownerPartyId,
          contractor.actor_party_id, ownerPartyId,
          hasPriorRelationship,
          hasPriorRelationship ? 'prior_relationship' : 'none',
          hasPriorRelationship ? 'Prior completed work together' : null
        ]
      );

      const conversation = createResult.rows[0];

      // System message
      await client.query(
        `INSERT INTO messages (conversation_id, sender_party_id, sender_individual_id, message_type, content, visibility)
         VALUES ($1, NULL, NULL, 'system', $2, 'normal')`,
        [
          conversation.id,
          hasPriorRelationship 
            ? 'Conversation started. Contact details are available (prior relationship).'
            : 'Conversation started. Contact details will be shared after deposit is confirmed.'
        ]
      );

      await client.query('COMMIT');

      res.status(201).json({ 
        conversation, 
        created: true,
        actor: { party_id: contractor.actor_party_id, individual_id: contractor.individual_id, display_name: contractor.display_name }
      });

    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Error creating conversation:', error);
    res.status(500).json({ error: 'Failed to create conversation' });
  }
});

// ============================================================
// GET MY CONVERSATIONS
// ============================================================
router.get('/conversations', async (req: Request, res: Response) => {
  try {
    const actor = await resolveActorParty(req, 'contractor');
    if (!actor) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const { opportunity_id, state } = req.query;

    let query = `
      SELECT c.*, o.title as opportunity_title, o.opportunity_ref, o.work_category,
             owner_p.trade_name as owner_name, contractor_p.trade_name as contractor_name,
             (SELECT content FROM messages WHERE conversation_id = c.id ORDER BY created_at DESC LIMIT 1) as last_message_preview
      FROM conversations c
      JOIN opportunities o ON c.opportunity_id = o.id
      LEFT JOIN parties owner_p ON c.owner_party_id = owner_p.id
      LEFT JOIN parties contractor_p ON c.contractor_party_id = contractor_p.id
      WHERE (c.owner_party_id = $1 OR c.contractor_party_id = $1)
    `;
    const params: any[] = [actor.actor_party_id];

    if (opportunity_id) {
      params.push(opportunity_id);
      query += ` AND c.opportunity_id = $${params.length}`;
    }
    if (state) {
      params.push(state);
      query += ` AND c.state = $${params.length}::conversation_state`;
    }

    query += ` ORDER BY COALESCE(c.last_message_at, c.created_at) DESC`;

    const result = await pool.query(query, params);

    const conversations = result.rows.map(c => ({
      ...c,
      my_role: c.owner_party_id === actor.actor_party_id ? 'owner' : 'contractor',
      unread_count: c.owner_party_id === actor.actor_party_id ? c.unread_owner : c.unread_contractor
    }));

    res.json({ conversations, actor: { party_id: actor.actor_party_id, individual_id: actor.individual_id, display_name: actor.display_name } });
  } catch (error) {
    console.error('Error fetching conversations:', error);
    res.status(500).json({ error: 'Failed to fetch conversations' });
  }
});

// ============================================================
// GET SINGLE CONVERSATION
// ============================================================
router.get('/conversations/:id', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const actor = await resolveActorParty(req, 'contractor');

    if (!actor) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const result = await pool.query(
      `SELECT c.*, o.title as opportunity_title, o.opportunity_ref, o.work_category, o.site_address,
              owner_p.trade_name as owner_name, owner_p.primary_contact_email as owner_email, owner_p.primary_contact_phone as owner_phone,
              contractor_p.trade_name as contractor_name, contractor_p.primary_contact_email as contractor_email, contractor_p.primary_contact_phone as contractor_phone
       FROM conversations c
       JOIN opportunities o ON c.opportunity_id = o.id
       LEFT JOIN parties owner_p ON c.owner_party_id = owner_p.id
       LEFT JOIN parties contractor_p ON c.contractor_party_id = contractor_p.id
       WHERE c.id = $1 AND (c.owner_party_id = $2 OR c.contractor_party_id = $2)`,
      [id, actor.actor_party_id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Conversation not found' });
    }

    const conv = result.rows[0];
    const isOwner = conv.owner_party_id === actor.actor_party_id;

    const response: any = {
      ...conv,
      my_role: isOwner ? 'owner' : 'contractor',
      unread_count: isOwner ? conv.unread_owner : conv.unread_contractor
    };

    // Redact contact info if not unlocked
    if (!conv.contact_unlocked) {
      if (isOwner) {
        delete response.contractor_email;
        delete response.contractor_phone;
      } else {
        delete response.owner_email;
        delete response.owner_phone;
      }
    }

    res.json({ conversation: response, actor: { party_id: actor.actor_party_id, individual_id: actor.individual_id, display_name: actor.display_name } });
  } catch (error) {
    console.error('Error fetching conversation:', error);
    res.status(500).json({ error: 'Failed to fetch conversation' });
  }
});

// ============================================================
// GET CONTACT UNLOCK STATUS
// ============================================================
router.get('/conversations/:id/contact-status', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const actor = await resolveActorParty(req, 'contractor');

    if (!actor) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const convResult = await pool.query(
      `SELECT * FROM conversations WHERE id = $1 AND (owner_party_id = $2 OR contractor_party_id = $2)`,
      [id, actor.actor_party_id]
    );

    if (convResult.rows.length === 0) {
      return res.status(404).json({ error: 'Conversation not found' });
    }

    const unlockStatus = await canUnlockContact(id);

    res.json({
      contact_unlocked: convResult.rows[0].contact_unlocked,
      contact_unlock_gate: convResult.rows[0].contact_unlock_gate,
      can_unlock: unlockStatus.canUnlock,
      unlock_gate: unlockStatus.gate,
      reason: unlockStatus.reason
    });
  } catch (error) {
    console.error('Error checking contact status:', error);
    res.status(500).json({ error: 'Failed to check contact status' });
  }
});

// ============================================================
// SEND MESSAGE (WITH REDACTION)
// ============================================================
router.post('/conversations/:id/messages', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { content, message_type = 'text', structured_data, attachments } = req.body;

    const actor = await resolveActorParty(req, 'contractor');
    if (!actor) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    if (!content || content.trim().length === 0) {
      return res.status(400).json({ error: 'Message content required' });
    }

    const client = await pool.connect();
    try {
      await client.query('BEGIN');

      const convResult = await client.query(`SELECT * FROM conversations WHERE id = $1`, [id]);

      if (convResult.rows.length === 0) {
        await client.query('ROLLBACK');
        return res.status(404).json({ error: 'Conversation not found' });
      }

      const conversation = convResult.rows[0];

      if (conversation.owner_party_id !== actor.actor_party_id && conversation.contractor_party_id !== actor.actor_party_id) {
        await client.query('ROLLBACK');
        return res.status(403).json({ error: 'Not authorized for this conversation' });
      }

      const isOwner = conversation.owner_party_id === actor.actor_party_id;

      // Apply redaction if not unlocked
      let finalContent = content;
      let wasRedacted = false;
      let redactedContent: string | null = null;
      let redactionReason: string | null = null;
      let detectedItems: any[] = [];

      if (!conversation.contact_unlocked) {
        const recentRedactions = await client.query(
          `SELECT COUNT(*) as count FROM message_redactions
           WHERE conversation_id = $1 AND sender_party_id = $2 AND created_at > now() - interval '1 hour'`,
          [id, actor.actor_party_id]
        );

        const blockCheck = shouldBlockMessage(id, parseInt(recentRedactions.rows[0].count));
        const redaction = redactContactInfo(content);
        
        if (redaction.wasRedacted) {
          wasRedacted = true;
          finalContent = redaction.cleanContent;
          redactedContent = redaction.originalContent;
          detectedItems = redaction.detectedItems;
          redactionReason = blockCheck.reason || 'Contact details are shared after deposit is confirmed';

          await client.query(
            `INSERT INTO message_redactions (message_id, conversation_id, sender_party_id, sender_individual_id, original_content, detected_items)
             VALUES (NULL, $1, $2, $3, $4, $5)`,
            [id, actor.actor_party_id, actor.individual_id, redaction.originalContent, JSON.stringify(detectedItems)]
          );
        }
      }

      // Insert message
      const msgResult = await client.query(
        `INSERT INTO messages (conversation_id, sender_party_id, sender_individual_id, message_type, content, structured_data, attachments, was_redacted, redacted_content, redaction_reason)
         VALUES ($1, $2, $3, $4::message_type, $5, $6, $7, $8, $9, $10) RETURNING *`,
        [id, actor.actor_party_id, actor.individual_id, message_type, finalContent, 
         structured_data ? JSON.stringify(structured_data) : null,
         attachments ? JSON.stringify(attachments) : null,
         wasRedacted, redactedContent, redactionReason]
      );

      const message = msgResult.rows[0];

      // Update redaction log with message_id
      if (wasRedacted) {
        await client.query(
          `UPDATE message_redactions SET message_id = $1 WHERE conversation_id = $2 AND message_id IS NULL ORDER BY created_at DESC LIMIT 1`,
          [message.id, id]
        );
      }

      // Update conversation
      await client.query(
        `UPDATE conversations SET
          last_message_at = now(), last_message_id = $1, message_count = message_count + 1,
          unread_owner = CASE WHEN $2 THEN unread_owner ELSE unread_owner + 1 END,
          unread_contractor = CASE WHEN $2 THEN unread_contractor + 1 ELSE unread_contractor END,
          updated_at = now()
         WHERE id = $3`,
        [message.id, isOwner, id]
      );

      await client.query('COMMIT');

      res.status(201).json({
        message: { ...message, sender_role: isOwner ? 'owner' : 'contractor' },
        wasRedacted,
        redactionNotice: wasRedacted ? 'Contact information was protected. Contact details are shared after deposit is confirmed.' : null,
        detectedItems: wasRedacted ? detectedItems.map(d => d.type) : []
      });

    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Error sending message:', error);
    res.status(500).json({ error: 'Failed to send message' });
  }
});

// ============================================================
// GET MESSAGES
// ============================================================
router.get('/conversations/:id/messages', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { limit = '50', before } = req.query;
    
    const actor = await resolveActorParty(req, 'contractor');
    if (!actor) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const client = await pool.connect();
    try {
      const convResult = await client.query(
        `SELECT * FROM conversations WHERE id = $1 AND (owner_party_id = $2 OR contractor_party_id = $2)`,
        [id, actor.actor_party_id]
      );

      if (convResult.rows.length === 0) {
        return res.status(404).json({ error: 'Conversation not found' });
      }

      const conversation = convResult.rows[0];
      const isOwner = conversation.owner_party_id === actor.actor_party_id;

      let query = `
        SELECT m.*, ind.full_name as sender_name, ind.preferred_name as sender_preferred_name, p.trade_name as sender_party_name,
               CASE WHEN m.sender_party_id = $2 THEN 'me' WHEN m.sender_party_id IS NULL THEN 'system' ELSE 'them' END as sender_role
        FROM messages m
        LEFT JOIN cc_individuals ind ON m.sender_individual_id = ind.id
        LEFT JOIN parties p ON m.sender_party_id = p.id
        WHERE m.conversation_id = $1 AND m.deleted_at IS NULL
      `;
      const params: any[] = [id, actor.actor_party_id];

      if (before) {
        params.push(before);
        query += ` AND m.created_at < $${params.length}`;
      }

      params.push(parseInt(limit as string));
      query += ` ORDER BY m.created_at DESC LIMIT $${params.length}`;

      const result = await client.query(query, params);

      // Mark as read
      const unreadField = isOwner ? 'unread_owner' : 'unread_contractor';
      await client.query(`UPDATE conversations SET ${unreadField} = 0 WHERE id = $1`, [id]);
      await client.query(
        `UPDATE messages SET read_at = now() WHERE conversation_id = $1 AND sender_party_id != $2 AND read_at IS NULL`,
        [id, actor.actor_party_id]
      );

      const messages = result.rows.reverse().map(m => ({
        ...m,
        sender_display_name: m.sender_preferred_name || m.sender_name || m.sender_party_name || 'System'
      }));

      res.json({ messages, contact_unlocked: conversation.contact_unlocked });

    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Error fetching messages:', error);
    res.status(500).json({ error: 'Failed to fetch messages' });
  }
});

// ============================================================
// UPDATE CONVERSATION STATE
// ============================================================
router.patch('/conversations/:id/state', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { state } = req.body;

    const actor = await resolveActorParty(req, 'contractor');
    if (!actor) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const validStates = ['interest', 'pre_bid', 'negotiation', 'awarded_pending', 'contracted', 'in_progress', 'completed', 'closed', 'cancelled'];
    if (!validStates.includes(state)) {
      return res.status(400).json({ error: 'Invalid state' });
    }

    const client = await pool.connect();
    try {
      await client.query('BEGIN');

      const convResult = await client.query(`SELECT * FROM conversations WHERE id = $1`, [id]);
      if (convResult.rows.length === 0) {
        await client.query('ROLLBACK');
        return res.status(404).json({ error: 'Conversation not found' });
      }

      const conversation = convResult.rows[0];
      const isOwner = conversation.owner_party_id === actor.actor_party_id;

      if (state === 'awarded_pending' && !isOwner) {
        await client.query('ROLLBACK');
        return res.status(403).json({ error: 'Only owner can award' });
      }

      // Check unlock (deposit-based, NOT state-based)
      const unlockStatus = await canUnlockContact(id);

      const result = await client.query(
        `UPDATE conversations SET
          state = $1::conversation_state, state_changed_at = now(),
          contact_unlocked = CASE WHEN $2 THEN true ELSE contact_unlocked END,
          contact_unlocked_at = CASE WHEN $2 AND NOT contact_unlocked THEN now() ELSE contact_unlocked_at END,
          contact_unlock_gate = CASE WHEN $2 AND NOT contact_unlocked THEN $3::contact_unlock_gate ELSE contact_unlock_gate END,
          contact_unlock_reason = CASE WHEN $2 AND NOT contact_unlocked THEN $4 ELSE contact_unlock_reason END,
          updated_at = now()
         WHERE id = $5 RETURNING *`,
        [state, unlockStatus.canUnlock && !conversation.contact_unlocked, unlockStatus.gate, unlockStatus.reason, id]
      );

      await client.query(
        `INSERT INTO messages (conversation_id, sender_party_id, sender_individual_id, message_type, content)
         VALUES ($1, $2, $3, 'system', $4)`,
        [id, actor.actor_party_id, actor.individual_id, `Status updated: ${state.replace(/_/g, ' ')}`]
      );

      await client.query('COMMIT');

      res.json({ conversation: result.rows[0], contact_unlocked: result.rows[0].contact_unlocked });

    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Error updating state:', error);
    res.status(500).json({ error: 'Failed to update state' });
  }
});

// ============================================================
// MANUAL CONTACT UNLOCK (Owner)
// ============================================================
router.post('/conversations/:id/unlock-contact', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { reason, gate = 'owner_override' } = req.body;

    const actor = await resolveActorParty(req, 'owner');
    if (!actor) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const client = await pool.connect();
    try {
      const convResult = await client.query(
        `SELECT * FROM conversations WHERE id = $1 AND owner_party_id = $2`,
        [id, actor.actor_party_id]
      );

      if (convResult.rows.length === 0) {
        return res.status(404).json({ error: 'Conversation not found or not authorized' });
      }

      const result = await client.query(
        `UPDATE conversations SET
          contact_unlocked = true, contact_unlocked_at = now(),
          contact_unlock_gate = $1::contact_unlock_gate, contact_unlock_reason = $2, updated_at = now()
         WHERE id = $3 RETURNING *`,
        [gate, reason || 'Owner approved contact sharing', id]
      );

      await client.query(
        `INSERT INTO messages (conversation_id, sender_party_id, sender_individual_id, message_type, content, visibility)
         VALUES ($1, $2, $3, 'system', 'Contact information is now shared between parties.', 'normal')`,
        [id, actor.actor_party_id, actor.individual_id]
      );

      res.json({ conversation: result.rows[0], contact_unlocked: true });

    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Error unlocking contact:', error);
    res.status(500).json({ error: 'Failed to unlock contact' });
  }
});

// ============================================================
// VERIFY DEPOSIT (Contractor confirms receipt)
// ============================================================
router.post('/conversations/:id/deposit-verified', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { payment_reference, notes } = req.body;

    const actor = await resolveActorParty(req, 'contractor');
    if (!actor) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const client = await pool.connect();
    try {
      await client.query('BEGIN');

      const convResult = await client.query(`SELECT * FROM conversations WHERE id = $1`, [id]);
      if (convResult.rows.length === 0) {
        await client.query('ROLLBACK');
        return res.status(404).json({ error: 'Conversation not found' });
      }

      const conversation = convResult.rows[0];

      if (conversation.contractor_party_id !== actor.actor_party_id) {
        await client.query('ROLLBACK');
        return res.status(403).json({ error: 'Only contractor can verify deposit receipt' });
      }

      // Update milestone
      const milestoneResult = await client.query(
        `UPDATE payment_milestones pm SET
          status = 'verified', paid_at = now(), payment_reference = $1, payment_notes = $2,
          verified_by_party_id = $3, verified_by_individual_id = $4, verified_at = now()
         FROM payment_promises pp
         WHERE pm.payment_promise_id = pp.id AND pp.conversation_id = $5
           AND pm.trigger_type IN ('on_award', 'on_contract_sign') AND pm.status != 'verified'
         RETURNING pm.*`,
        [payment_reference, notes, actor.actor_party_id, actor.individual_id, id]
      );

      // Unlock contact
      const updateResult = await client.query(
        `UPDATE conversations SET
          contact_unlocked = true, contact_unlocked_at = now(),
          contact_unlock_gate = 'deposit_verified', contact_unlock_reason = 'Deposit verified by contractor', updated_at = now()
         WHERE id = $1 RETURNING *`,
        [id]
      );

      await client.query(
        `INSERT INTO messages (conversation_id, sender_party_id, sender_individual_id, message_type, content)
         VALUES ($1, $2, $3, 'system', 'Deposit verified. Contact information is now shared.')`,
        [id, actor.actor_party_id, actor.individual_id]
      );

      await client.query('COMMIT');

      res.json({ conversation: updateResult.rows[0], milestone: milestoneResult.rows[0] || null, contact_unlocked: true });

    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Error verifying deposit:', error);
    res.status(500).json({ error: 'Failed to verify deposit' });
  }
});

export default router;
```

### Register the routes

In server/index.ts, add:
```typescript
import conversationsRouter from './routes/conversations';

// With other route registrations:
app.use('/api', conversationsRouter);
```

### Verification

Test these endpoints:
```bash
# 1. Create conversation
curl -X POST http://localhost:5000/api/conversations \
  -H "Content-Type: application/json" \
  -H "Cookie: YOUR_SESSION" \
  -d '{"opportunity_id": "OPP_UUID"}'

# 2. Send message with contact info (should be redacted)
curl -X POST http://localhost:5000/api/conversations/CONV_UUID/messages \
  -H "Content-Type: application/json" \
  -H "Cookie: YOUR_SESSION" \
  -d '{"content": "Hi! Email me at test@example.com or call 250-555-1234"}'

# 3. Check contact status
curl http://localhost:5000/api/conversations/CONV_UUID/contact-status \
  -H "Cookie: YOUR_SESSION"
```

### Expected Results

1. Conversation created with actor info
2. Contact info redacted: `[contact info protected]`
3. Contact status shows `contact_unlocked: false`

Tell me:
1. Do lib files create without errors?
2. Do conversations create correctly?
3. Is contact info being redacted?
4. Any runtime errors?