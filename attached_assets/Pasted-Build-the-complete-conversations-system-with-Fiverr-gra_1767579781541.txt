Build the complete conversations system with Fiverr-grade contact gating.
Assumes server/lib/partyResolver.ts and server/lib/contactRedaction.ts already exist from Prompt 3.

### File: server/routes/conversations.ts
```typescript
import { Router, Request, Response } from 'express';
import { pool } from '../db';
import { resolveActorParty, canUnlockContact } from '../lib/partyResolver';
import { redactContactInfo, shouldBlockMessage } from '../lib/contactRedaction';

const router = Router();

// ============================================================
// CREATE OR GET CONVERSATION
// ============================================================
router.post('/conversations', async (req: Request, res: Response) => {
  try {
    const { opportunity_id } = req.body;

    if (!opportunity_id) {
      return res.status(400).json({ error: 'opportunity_id required' });
    }

    const contractor = await resolveActorParty(req, 'contractor');
    if (!contractor) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const client = await pool.connect();
    try {
      await client.query('BEGIN');

      // Get opportunity
      const oppResult = await client.query(
        `SELECT o.id, o.owner_tenant_id, o.title, o.owner_type
         FROM opportunities o WHERE o.id = $1`,
        [opportunity_id]
      );

      if (oppResult.rows.length === 0) {
        await client.query('ROLLBACK');
        return res.status(404).json({ error: 'Opportunity not found' });
      }

      const opp = oppResult.rows[0];

      if (!opp.owner_tenant_id) {
        await client.query('ROLLBACK');
        return res.status(400).json({ error: 'Opportunity has no owner' });
      }

      // Find or create owner party
      let ownerPartyResult = await client.query(
        `SELECT id FROM parties 
         WHERE tenant_id = $1 AND party_kind = 'organization' 
         ORDER BY created_at ASC LIMIT 1`,
        [opp.owner_tenant_id]
      );

      let ownerPartyId = ownerPartyResult.rows[0]?.id;

      if (!ownerPartyId) {
        const ownerTenantResult = await client.query(
          `SELECT name, email, phone, business_number,
                  address_line1, city, province, postal_code
           FROM tenants WHERE id = $1`,
          [opp.owner_tenant_id]
        );
        const ownerTenant = ownerTenantResult.rows[0];

        if (!ownerTenant?.name) {
          await client.query('ROLLBACK');
          return res.status(400).json({ error: 'Owner tenant not found' });
        }

        const createOwnerResult = await client.query(
          `INSERT INTO parties (
            tenant_id, party_kind, party_type, status, 
            legal_name, trade_name, 
            primary_contact_email, primary_contact_phone,
            address_line1, city, province, postal_code
          ) VALUES ($1, 'organization', 'owner', 'active', $2, $2, $3, $4, $5, $6, $7, $8)
          RETURNING id`,
          [
            opp.owner_tenant_id, ownerTenant.name,
            ownerTenant.email, ownerTenant.phone,
            ownerTenant.address_line1, ownerTenant.city,
            ownerTenant.province || 'BC', ownerTenant.postal_code
          ]
        );
        ownerPartyId = createOwnerResult.rows[0].id;
      }

      // Can't start conversation with yourself
      if (contractor.actor_party_id === ownerPartyId) {
        await client.query('ROLLBACK');
        return res.status(400).json({ error: 'Cannot start conversation with yourself' });
      }

      // Check existing conversation
      const existingResult = await client.query(
        `SELECT * FROM conversations 
         WHERE opportunity_id = $1 AND contractor_party_id = $2`,
        [opportunity_id, contractor.actor_party_id]
      );

      if (existingResult.rows.length > 0) {
        await client.query('COMMIT');
        return res.json({ 
          conversation: existingResult.rows[0], 
          created: false,
          actor: {
            party_id: contractor.actor_party_id,
            individual_id: contractor.individual_id,
            display_name: contractor.display_name
          }
        });
      }

      // Check for prior relationship (auto-unlock)
      const priorResult = await client.query(
        `SELECT 1 FROM conversations 
         WHERE contractor_party_id = $1 AND owner_party_id = $2 
         AND state = 'completed' LIMIT 1`,
        [contractor.actor_party_id, ownerPartyId]
      );
      const hasPriorRelationship = priorResult.rows.length > 0;

      // Create conversation
      const createResult = await client.query(
        `INSERT INTO conversations (
          opportunity_id, contractor_party_id, owner_party_id,
          contractor_actor_party_id, owner_actor_party_id,
          state, contact_unlocked, contact_unlock_gate, contact_unlock_reason
        ) VALUES ($1, $2, $3, $4, $5, 'interest', $6, $7, $8)
        RETURNING *`,
        [
          opportunity_id,
          contractor.actor_party_id,
          ownerPartyId,
          contractor.actor_party_id,
          ownerPartyId,
          hasPriorRelationship,
          hasPriorRelationship ? 'prior_relationship' : 'none',
          hasPriorRelationship ? 'Prior completed work together' : null
        ]
      );

      const conversation = createResult.rows[0];

      // System message
      await client.query(
        `INSERT INTO messages (
          conversation_id, sender_party_id, sender_individual_id,
          message_type, content, visibility
        ) VALUES ($1, NULL, NULL, 'system', $2, 'normal')`,
        [
          conversation.id,
          hasPriorRelationship 
            ? 'Conversation started. Contact details are available (prior relationship).'
            : 'Conversation started. Contact details will be shared after deposit is confirmed.'
        ]
      );

      await client.query('COMMIT');

      res.status(201).json({ 
        conversation, 
        created: true,
        actor: {
          party_id: contractor.actor_party_id,
          individual_id: contractor.individual_id,
          display_name: contractor.display_name
        }
      });

    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Error creating conversation:', error);
    res.status(500).json({ error: 'Failed to create conversation' });
  }
});

// ============================================================
// GET MY CONVERSATIONS
// ============================================================
router.get('/conversations', async (req: Request, res: Response) => {
  try {
    const actor = await resolveActorParty(req, 'contractor');
    if (!actor) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const { opportunity_id, state, limit = '50' } = req.query;

    let query = `
      SELECT c.*,
             o.title as opportunity_title,
             o.opportunity_ref,
             o.work_category,
             o.owner_type,
             owner_p.trade_name as owner_name,
             contractor_p.trade_name as contractor_name,
             (SELECT content FROM messages 
              WHERE conversation_id = c.id 
              ORDER BY created_at DESC LIMIT 1) as last_message_preview
      FROM conversations c
      JOIN opportunities o ON c.opportunity_id = o.id
      LEFT JOIN parties owner_p ON c.owner_party_id = owner_p.id
      LEFT JOIN parties contractor_p ON c.contractor_party_id = contractor_p.id
      WHERE (c.owner_party_id = $1 OR c.contractor_party_id = $1)
    `;
    const params: any[] = [actor.actor_party_id];

    if (opportunity_id) {
      params.push(opportunity_id);
      query += ` AND c.opportunity_id = $${params.length}`;
    }

    if (state) {
      params.push(state);
      query += ` AND c.state = $${params.length}::conversation_state`;
    }

    query += ` ORDER BY COALESCE(c.last_message_at, c.created_at) DESC`;
    
    params.push(parseInt(limit as string));
    query += ` LIMIT $${params.length}`;

    const result = await pool.query(query, params);

    const conversations = result.rows.map(c => ({
      ...c,
      my_role: c.owner_party_id === actor.actor_party_id ? 'owner' : 'contractor',
      unread_count: c.owner_party_id === actor.actor_party_id 
        ? c.unread_owner 
        : c.unread_contractor
    }));

    res.json({ 
      conversations,
      count: conversations.length,
      actor: {
        party_id: actor.actor_party_id,
        individual_id: actor.individual_id,
        display_name: actor.display_name
      }
    });
  } catch (error) {
    console.error('Error fetching conversations:', error);
    res.status(500).json({ error: 'Failed to fetch conversations' });
  }
});

// ============================================================
// GET SINGLE CONVERSATION
// ============================================================
router.get('/conversations/:id', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const actor = await resolveActorParty(req, 'contractor');

    if (!actor) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const result = await pool.query(
      `SELECT c.*,
              o.title as opportunity_title,
              o.opportunity_ref,
              o.work_category,
              o.site_address,
              o.owner_type,
              o.budget_amount,
              owner_p.trade_name as owner_name,
              owner_p.primary_contact_email as owner_email,
              owner_p.primary_contact_phone as owner_phone,
              contractor_p.trade_name as contractor_name,
              contractor_p.primary_contact_email as contractor_email,
              contractor_p.primary_contact_phone as contractor_phone
       FROM conversations c
       JOIN opportunities o ON c.opportunity_id = o.id
       LEFT JOIN parties owner_p ON c.owner_party_id = owner_p.id
       LEFT JOIN parties contractor_p ON c.contractor_party_id = contractor_p.id
       WHERE c.id = $1
         AND (c.owner_party_id = $2 OR c.contractor_party_id = $2)`,
      [id, actor.actor_party_id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Conversation not found' });
    }

    const conv = result.rows[0];
    const isOwner = conv.owner_party_id === actor.actor_party_id;

    // Build response
    const response: any = {
      ...conv,
      my_role: isOwner ? 'owner' : 'contractor',
      unread_count: isOwner ? conv.unread_owner : conv.unread_contractor
    };

    // CONTACT GATING: Redact contact info if not unlocked
    if (!conv.contact_unlocked) {
      if (isOwner) {
        delete response.contractor_email;
        delete response.contractor_phone;
      } else {
        delete response.owner_email;
        delete response.owner_phone;
      }
    }

    res.json({ 
      conversation: response,
      actor: {
        party_id: actor.actor_party_id,
        individual_id: actor.individual_id,
        display_name: actor.display_name
      }
    });
  } catch (error) {
    console.error('Error fetching conversation:', error);
    res.status(500).json({ error: 'Failed to fetch conversation' });
  }
});

// ============================================================
// GET CONTACT UNLOCK STATUS
// ============================================================
router.get('/conversations/:id/contact-status', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const actor = await resolveActorParty(req, 'contractor');

    if (!actor) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    // Verify access
    const convResult = await pool.query(
      `SELECT * FROM conversations WHERE id = $1
       AND (owner_party_id = $2 OR contractor_party_id = $2)`,
      [id, actor.actor_party_id]
    );

    if (convResult.rows.length === 0) {
      return res.status(404).json({ error: 'Conversation not found' });
    }

    const conv = convResult.rows[0];
    const unlockStatus = await canUnlockContact(id);

    res.json({
      contact_unlocked: conv.contact_unlocked,
      contact_unlock_gate: conv.contact_unlock_gate,
      contact_unlocked_at: conv.contact_unlocked_at,
      can_unlock: unlockStatus.canUnlock,
      unlock_gate: unlockStatus.gate,
      reason: unlockStatus.reason
    });
  } catch (error) {
    console.error('Error checking contact status:', error);
    res.status(500).json({ error: 'Failed to check contact status' });
  }
});

// ============================================================
// SEND MESSAGE (WITH TIERED REDACTION)
// ============================================================
router.post('/conversations/:id/messages', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { content, message_type = 'text', structured_data, attachments } = req.body;

    const actor = await resolveActorParty(req, 'contractor');
    if (!actor) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    if (!content || content.trim().length === 0) {
      return res.status(400).json({ error: 'Message content required' });
    }

    if (content.length > 10000) {
      return res.status(400).json({ error: 'Message too long (max 10000 characters)' });
    }

    const client = await pool.connect();
    try {
      await client.query('BEGIN');

      // Verify conversation exists
      const convResult = await client.query(
        `SELECT * FROM conversations WHERE id = $1`,
        [id]
      );

      if (convResult.rows.length === 0) {
        await client.query('ROLLBACK');
        return res.status(404).json({ error: 'Conversation not found' });
      }

      const conversation = convResult.rows[0];

      // Verify sender is part of conversation
      if (conversation.owner_party_id !== actor.actor_party_id &&
          conversation.contractor_party_id !== actor.actor_party_id) {
        await client.query('ROLLBACK');
        return res.status(403).json({ error: 'Not authorized for this conversation' });
      }

      const isOwner = conversation.owner_party_id === actor.actor_party_id;

      // CONTACT REDACTION if not unlocked
      let finalContent = content;
      let wasRedacted = false;
      let redactedContent: string | null = null;
      let redactionReason: string | null = null;
      let detectedItems: any[] = [];

      if (!conversation.contact_unlocked) {
        // Check recent redaction count (rate limiting)
        const recentRedactions = await client.query(
          `SELECT COUNT(*) as count FROM message_redactions
           WHERE conversation_id = $1 
             AND sender_party_id = $2
             AND created_at > now() - interval '1 hour'`,
          [id, actor.actor_party_id]
        );

        const recentCount = parseInt(recentRedactions.rows[0].count);
        const blockCheck = shouldBlockMessage(id, recentCount);

        const redaction = redactContactInfo(content);
        
        if (redaction.wasRedacted) {
          wasRedacted = true;
          finalContent = redaction.cleanContent;
          redactedContent = redaction.originalContent;
          detectedItems = redaction.detectedItems;
          redactionReason = blockCheck.reason || 'Contact details are shared after deposit is confirmed';

          // Log redaction attempt
          await client.query(
            `INSERT INTO message_redactions (
              message_id, conversation_id, 
              sender_party_id, sender_individual_id,
              original_content, detected_items
            ) VALUES (NULL, $1, $2, $3, $4, $5)`,
            [
              id,
              actor.actor_party_id,
              actor.individual_id,
              redaction.originalContent,
              JSON.stringify(detectedItems)
            ]
          );
        }
      }

      // Insert message
      const msgResult = await client.query(
        `INSERT INTO messages (
          conversation_id, 
          sender_party_id, sender_individual_id,
          message_type, content,
          structured_data, attachments,
          was_redacted, redacted_content, redaction_reason
        ) VALUES ($1, $2, $3, $4::message_type, $5, $6, $7, $8, $9, $10)
        RETURNING *`,
        [
          id,
          actor.actor_party_id,
          actor.individual_id,
          message_type,
          finalContent,
          structured_data ? JSON.stringify(structured_data) : null,
          attachments ? JSON.stringify(attachments) : null,
          wasRedacted,
          redactedContent,
          redactionReason
        ]
      );

      const message = msgResult.rows[0];

      // Update redaction log with message_id
      if (wasRedacted) {
        await client.query(
          `UPDATE message_redactions SET message_id = $1
           WHERE conversation_id = $2 AND message_id IS NULL
           ORDER BY created_at DESC LIMIT 1`,
          [message.id, id]
        );
      }

      // Update conversation metadata
      await client.query(
        `UPDATE conversations SET
          last_message_at = now(),
          last_message_id = $1,
          message_count = message_count + 1,
          unread_owner = CASE WHEN $2 THEN unread_owner ELSE unread_owner + 1 END,
          unread_contractor = CASE WHEN $2 THEN unread_contractor + 1 ELSE unread_contractor END,
          updated_at = now()
         WHERE id = $3`,
        [message.id, isOwner, id]
      );

      await client.query('COMMIT');

      res.status(201).json({
        message: {
          ...message,
          sender_role: isOwner ? 'owner' : 'contractor',
          sender_display_name: actor.display_name
        },
        wasRedacted,
        redactionNotice: wasRedacted
          ? 'Contact information was protected. Contact details are shared after deposit is confirmed.'
          : null,
        detectedItems: wasRedacted ? detectedItems.map(d => d.type) : []
      });

    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Error sending message:', error);
    res.status(500).json({ error: 'Failed to send message' });
  }
});

// ============================================================
// GET MESSAGES
// ============================================================
router.get('/conversations/:id/messages', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { limit = '50', before, after } = req.query;
    
    const actor = await resolveActorParty(req, 'contractor');
    if (!actor) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const client = await pool.connect();
    try {
      // Verify access
      const convResult = await client.query(
        `SELECT * FROM conversations WHERE id = $1
         AND (owner_party_id = $2 OR contractor_party_id = $2)`,
        [id, actor.actor_party_id]
      );

      if (convResult.rows.length === 0) {
        return res.status(404).json({ error: 'Conversation not found' });
      }

      const conversation = convResult.rows[0];
      const isOwner = conversation.owner_party_id === actor.actor_party_id;

      // Build query
      let query = `
        SELECT m.*,
               ind.full_name as sender_name,
               ind.preferred_name as sender_preferred_name,
               p.trade_name as sender_party_name,
               CASE 
                 WHEN m.sender_party_id = $2 THEN 'me'
                 WHEN m.sender_party_id IS NULL THEN 'system'
                 ELSE 'them'
               END as sender_role
        FROM messages m
        LEFT JOIN cc_individuals ind ON m.sender_individual_id = ind.id
        LEFT JOIN parties p ON m.sender_party_id = p.id
        WHERE m.conversation_id = $1
          AND m.deleted_at IS NULL
          AND m.visibility != 'hidden'
      `;
      const params: any[] = [id, actor.actor_party_id];

      if (before) {
        params.push(before);
        query += ` AND m.created_at < $${params.length}`;
      }

      if (after) {
        params.push(after);
        query += ` AND m.created_at > $${params.length}`;
      }

      params.push(parseInt(limit as string));
      query += ` ORDER BY m.created_at DESC LIMIT $${params.length}`;

      const result = await client.query(query, params);

      // Mark conversation as read for this party
      const unreadField = isOwner ? 'unread_owner' : 'unread_contractor';
      await client.query(
        `UPDATE conversations SET ${unreadField} = 0, updated_at = now() WHERE id = $1`,
        [id]
      );

      // Mark messages as read
      await client.query(
        `UPDATE messages SET read_at = now()
         WHERE conversation_id = $1
           AND sender_party_id != $2
           AND read_at IS NULL`,
        [id, actor.actor_party_id]
      );

      // Format messages (reverse to chronological order)
      const messages = result.rows.reverse().map(m => ({
        ...m,
        sender_display_name: m.sender_preferred_name || m.sender_name || m.sender_party_name || 'System'
      }));

      res.json({ 
        messages,
        count: messages.length,
        contact_unlocked: conversation.contact_unlocked,
        has_more: result.rows.length === parseInt(limit as string)
      });

    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Error fetching messages:', error);
    res.status(500).json({ error: 'Failed to fetch messages' });
  }
});

// ============================================================
// UPDATE CONVERSATION STATE
// ============================================================
router.patch('/conversations/:id/state', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { state } = req.body;

    const actor = await resolveActorParty(req, 'contractor');
    if (!actor) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const validStates = [
      'interest', 'pre_bid', 'negotiation', 'awarded_pending',
      'contracted', 'in_progress', 'completed', 'closed', 'cancelled'
    ];

    if (!validStates.includes(state)) {
      return res.status(400).json({ error: `Invalid state. Valid: ${validStates.join(', ')}` });
    }

    const client = await pool.connect();
    try {
      await client.query('BEGIN');

      const convResult = await client.query(
        `SELECT * FROM conversations WHERE id = $1`,
        [id]
      );

      if (convResult.rows.length === 0) {
        await client.query('ROLLBACK');
        return res.status(404).json({ error: 'Conversation not found' });
      }

      const conversation = convResult.rows[0];
      const isOwner = conversation.owner_party_id === actor.actor_party_id;
      const isContractor = conversation.contractor_party_id === actor.actor_party_id;

      if (!isOwner && !isContractor) {
        await client.query('ROLLBACK');
        return res.status(403).json({ error: 'Not authorized' });
      }

      // State transition rules
      if (state === 'awarded_pending' && !isOwner) {
        await client.query('ROLLBACK');
        return res.status(403).json({ error: 'Only owner can award' });
      }

      if (state === 'contracted' && !isContractor) {
        await client.query('ROLLBACK');
        return res.status(403).json({ error: 'Only contractor can confirm contract' });
      }

      // Check if contact should unlock (deposit-based, NOT state-based)
      const unlockStatus = await canUnlockContact(id);
      const shouldUnlock = unlockStatus.canUnlock && !conversation.contact_unlocked;

      const result = await client.query(
        `UPDATE conversations SET
          state = $1::conversation_state,
          state_changed_at = now(),
          contact_unlocked = CASE WHEN $2 THEN true ELSE contact_unlocked END,
          contact_unlocked_at = CASE WHEN $2 THEN now() ELSE contact_unlocked_at END,
          contact_unlock_gate = CASE WHEN $2 THEN $3::contact_unlock_gate ELSE contact_unlock_gate END,
          contact_unlock_reason = CASE WHEN $2 THEN $4 ELSE contact_unlock_reason END,
          updated_at = now()
         WHERE id = $5
         RETURNING *`,
        [state, shouldUnlock, unlockStatus.gate, unlockStatus.reason, id]
      );

      // System message
      let stateMessage = `Status updated to: ${state.replace(/_/g, ' ')}`;
      if (shouldUnlock) {
        stateMessage += '. Contact information is now available.';
      }

      await client.query(
        `INSERT INTO messages (
          conversation_id, sender_party_id, sender_individual_id,
          message_type, content
        ) VALUES ($1, $2, $3, 'system', $4)`,
        [id, actor.actor_party_id, actor.individual_id, stateMessage]
      );

      await client.query('COMMIT');

      res.json({ 
        conversation: result.rows[0],
        contact_unlocked: result.rows[0].contact_unlocked,
        state_changed: true
      });

    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Error updating state:', error);
    res.status(500).json({ error: 'Failed to update state' });
  }
});

// ============================================================
// MANUAL CONTACT UNLOCK (Owner Only)
// ============================================================
router.post('/conversations/:id/unlock-contact', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { reason } = req.body;

    const actor = await resolveActorParty(req, 'owner');
    if (!actor) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const client = await pool.connect();
    try {
      // Only owner can manually unlock
      const convResult = await client.query(
        `SELECT * FROM conversations WHERE id = $1 AND owner_party_id = $2`,
        [id, actor.actor_party_id]
      );

      if (convResult.rows.length === 0) {
        return res.status(404).json({ error: 'Conversation not found or not authorized' });
      }

      if (convResult.rows[0].contact_unlocked) {
        return res.json({ 
          conversation: convResult.rows[0], 
          contact_unlocked: true,
          message: 'Contact already unlocked'
        });
      }

      const result = await client.query(
        `UPDATE conversations SET
          contact_unlocked = true,
          contact_unlocked_at = now(),
          contact_unlock_gate = 'owner_override'::contact_unlock_gate,
          contact_unlock_reason = $1,
          updated_at = now()
         WHERE id = $2
         RETURNING *`,
        [reason || 'Owner approved contact sharing', id]
      );

      // System message
      await client.query(
        `INSERT INTO messages (
          conversation_id, sender_party_id, sender_individual_id,
          message_type, content, visibility
        ) VALUES ($1, $2, $3, 'system', 'Contact information is now shared between parties.', 'normal')`,
        [id, actor.actor_party_id, actor.individual_id]
      );

      res.json({ 
        conversation: result.rows[0],
        contact_unlocked: true
      });

    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Error unlocking contact:', error);
    res.status(500).json({ error: 'Failed to unlock contact' });
  }
});

// ============================================================
// VERIFY DEPOSIT (Contractor Confirms Receipt → Triggers Unlock)
// ============================================================
router.post('/conversations/:id/deposit-verified', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { payment_reference, notes } = req.body;

    const actor = await resolveActorParty(req, 'contractor');
    if (!actor) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const client = await pool.connect();
    try {
      await client.query('BEGIN');

      // Get conversation
      const convResult = await client.query(
        `SELECT * FROM conversations WHERE id = $1`,
        [id]
      );

      if (convResult.rows.length === 0) {
        await client.query('ROLLBACK');
        return res.status(404).json({ error: 'Conversation not found' });
      }

      const conversation = convResult.rows[0];

      // Only contractor can verify deposit receipt
      if (conversation.contractor_party_id !== actor.actor_party_id) {
        await client.query('ROLLBACK');
        return res.status(403).json({ error: 'Only contractor can verify deposit receipt' });
      }

      // Find and update deposit milestone
      const milestoneResult = await client.query(
        `UPDATE payment_milestones pm SET
          status = 'verified',
          paid_at = now(),
          payment_reference = $1,
          payment_notes = $2,
          verified_by_party_id = $3,
          verified_by_individual_id = $4,
          verified_at = now()
         FROM payment_promises pp
         WHERE pm.payment_promise_id = pp.id
           AND pp.conversation_id = $5
           AND pm.trigger_type IN ('on_award', 'on_contract_sign')
           AND pm.status != 'verified'
         RETURNING pm.*`,
        [payment_reference, notes, actor.actor_party_id, actor.individual_id, id]
      );

      // Unlock contact
      const updateResult = await client.query(
        `UPDATE conversations SET
          contact_unlocked = true,
          contact_unlocked_at = now(),
          contact_unlock_gate = 'deposit_verified',
          contact_unlock_reason = 'Deposit verified by contractor',
          updated_at = now()
         WHERE id = $1
         RETURNING *`,
        [id]
      );

      // System message
      await client.query(
        `INSERT INTO messages (
          conversation_id, sender_party_id, sender_individual_id,
          message_type, content
        ) VALUES ($1, $2, $3, 'system', $4)`,
        [
          id,
          actor.actor_party_id,
          actor.individual_id,
          'Deposit verified. Contact information is now shared between parties.'
        ]
      );

      await client.query('COMMIT');

      res.json({
        conversation: updateResult.rows[0],
        milestone: milestoneResult.rows[0] || null,
        contact_unlocked: true
      });

    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Error verifying deposit:', error);
    res.status(500).json({ error: 'Failed to verify deposit' });
  }
});

// ============================================================
// GET UNREAD COUNT (For notifications/badges)
// ============================================================
router.get('/conversations/unread/count', async (req: Request, res: Response) => {
  try {
    const actor = await resolveActorParty(req, 'contractor');
    if (!actor) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const result = await pool.query(
      `SELECT 
         COUNT(*) FILTER (WHERE owner_party_id = $1 AND unread_owner > 0) as unread_as_owner,
         COUNT(*) FILTER (WHERE contractor_party_id = $1 AND unread_contractor > 0) as unread_as_contractor,
         SUM(CASE WHEN owner_party_id = $1 THEN unread_owner ELSE 0 END) as total_unread_owner,
         SUM(CASE WHEN contractor_party_id = $1 THEN unread_contractor ELSE 0 END) as total_unread_contractor
       FROM conversations
       WHERE owner_party_id = $1 OR contractor_party_id = $1`,
      [actor.actor_party_id]
    );

    const counts = result.rows[0];

    res.json({
      conversations_with_unread: parseInt(counts.unread_as_owner) + parseInt(counts.unread_as_contractor),
      total_unread_messages: parseInt(counts.total_unread_owner || 0) + parseInt(counts.total_unread_contractor || 0)
    });
  } catch (error) {
    console.error('Error fetching unread count:', error);
    res.status(500).json({ error: 'Failed to fetch unread count' });
  }
});

export default router;
```

### Register the Routes

In server/index.ts, add with other imports:
```typescript
import conversationsRouter from './routes/conversations';
```

Add with other route registrations:
```typescript
app.use('/api', conversationsRouter);
```

### Verification

Test these endpoints:
```bash
# 1. Create conversation (as contractor)
curl -X POST http://localhost:5000/api/conversations \
  -H "Content-Type: application/json" \
  -H "Cookie: YOUR_SESSION" \
  -d '{"opportunity_id": "OPPORTUNITY_UUID"}'

# 2. Get my conversations
curl http://localhost:5000/api/conversations \
  -H "Cookie: YOUR_SESSION"

# 3. Send message with contact info (should be redacted)
curl -X POST http://localhost:5000/api/conversations/CONV_UUID/messages \
  -H "Content-Type: application/json" \
  -H "Cookie: YOUR_SESSION" \
  -d '{"content": "Hi! Email me at test@example.com or call 250-555-1234"}'

# 4. Check contact status
curl http://localhost:5000/api/conversations/CONV_UUID/contact-status \
  -H "Cookie: YOUR_SESSION"

# 5. Get messages
curl http://localhost:5000/api/conversations/CONV_UUID/messages \
  -H "Cookie: YOUR_SESSION"

# 6. Get unread count
curl http://localhost:5000/api/conversations/unread/count \
  -H "Cookie: YOUR_SESSION"
```

### Expected Results

1. **Create conversation**: Returns conversation with `created: true`, actor info, system message added
2. **List conversations**: Shows `my_role`, `unread_count`, `last_message_preview`
3. **Send message with contact**: 
   - Content shows `[contact info protected]` 
   - Response has `wasRedacted: true`
   - `detectedItems: ['email', 'phone_dashed']`
4. **Contact status**: `contact_unlocked: false`, `reason: 'Deposit required...'`
5. **Messages**: Each has `sender_display_name`, `sender_role` (me/them/system)
6. **Unread count**: Shows total unread for notification badges

### Key Features Implemented

| Feature | Implementation |
|---------|---------------|
| Contact gating | Emails/phones hidden until deposit verified |
| Tiered redaction | Tier 1 (always) + Tier 2 (conditional) |
| Prior relationship unlock | Auto-unlock if completed job together before |
| Deposit verification | Contractor confirms → contact unlocks |
| Owner manual override | Owner can unlock anytime |
| Unread tracking | Separate counters for owner/contractor |
| State machine | interest → pre_bid → negotiation → awarded → contracted → in_progress → completed |

Tell me:
1. Does conversation creation work?
2. Are messages being redacted correctly?
3. Does contact-status endpoint work?
4. Does unread count work?
5. Any errors?